(()=>{var __webpack_modules__={1:(module,exports)=>{eval('/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar Jose = {};\n\n/**\n * Javascript Object Signing and Encryption library.\n *\n * @author Alok Menghrajani <alok@squareup.com>\n */\n\n/**\n * Initializes a JoseJWE object.\n */\nvar JoseJWE = {};\n\n/**\n * Initializes a JoseJWS object.\n */\nvar JoseJWS = {};\n\n/**\n * Set crypto provider to use (window.crypto, node-webcrypto-ossl, node-webcrypto-pkcs11 etc.).\n */\nexports.setCrypto = function (cp) {\n  Jose.crypto = cp;\n};\n\n/**\n * Default to the global "crypto" variable\n */\nif (typeof(crypto) !== \'undefined\') {\n  exports.setCrypto(crypto);\n}\n\n/**\n * Use Node versions of atob, btoa functions outside the browser\n */\nif (typeof atob !== "function") {\n  atob = function (str) {\n    return new Buffer(str, \'base64\').toString(\'binary\');\n  };\n}\n\nif (typeof btoa !== "function") {\n  btoa = function (str) {\n    var buffer;\n    if (str instanceof Buffer) {\n      buffer = str;\n    } else {\n      buffer = new Buffer(str.toString(), \'binary\');\n    }\n    return buffer.toString(\'base64\');\n  };\n}\n\n/**\n * Checks if we have all the required APIs.\n *\n * It might make sense to take a Cryptographer and delegate some of the checks\n * to the cryptographer. I however wanted to keep things simple, so I put all\n * the checks here for now.\n *\n * This list is generated manually and needs to be kept up-to-date.\n *\n * Casual testing shows that:\n * - things work in Chrome 40.0.2214.115\n * - things work in Firefox 35.0.1\n * - Safari 7.1.3 doesn\'t support JWK keys.\n * - Internet Explorer doesn\'t support Promises.\n *\n * Note: We don\'t check if the browser supports specific crypto operations.\n *       I.e. it\'s possible for this function to return true, but encryption or\n *       decryption to subsequently fail because the browser does not support a\n *       given encryption, decryption, key wrapping, key unwrapping or hmac\n *       operation.\n *\n * @return bool\n */\nJose.caniuse = function() {\n  var r = true;\n\n  // Promises/A+ (https://promisesaplus.com/)\n  r = r && (typeof Promise == "function");\n  r = r && (typeof Promise.reject == "function");\n  r = r && (typeof Promise.prototype.then == "function");\n  r = r && (typeof Promise.all == "function");\n\n  // Crypto (http://www.w3.org/TR/WebCryptoAPI/)\n  r = r && (typeof Jose.crypto == "object");\n  r = r && (typeof Jose.crypto.subtle == "object");\n  r = r && (typeof Jose.crypto.getRandomValues == "function");\n  r = r && (typeof Jose.crypto.subtle.importKey == "function");\n  r = r && (typeof Jose.crypto.subtle.generateKey == "function");\n  r = r && (typeof Jose.crypto.subtle.exportKey == "function");\n  r = r && (typeof Jose.crypto.subtle.wrapKey == "function");\n  r = r && (typeof Jose.crypto.subtle.unwrapKey == "function");\n  r = r && (typeof Jose.crypto.subtle.encrypt == "function");\n  r = r && (typeof Jose.crypto.subtle.decrypt == "function");\n  r = r && (typeof Jose.crypto.subtle.sign == "function");\n\n  // ArrayBuffer (http://people.mozilla.org/~jorendorff/es6-draft.html#sec-arraybuffer-constructor)\n  r = r && (typeof ArrayBuffer == "function");\n  r = r && (typeof Uint8Array == "function" || typeof Uint8Array == "object"); // Safari uses "object"\n  r = r && (typeof Uint32Array == "function" || typeof Uint32Array == "object"); // Safari uses "object"\n  // skipping Uint32Array.prototype.buffer because https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-%typedarrayprototype%-object\n\n  // JSON (http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)\n  r = r && (typeof JSON == "object");\n  r = r && (typeof JSON.parse == "function");\n  r = r && (typeof JSON.stringify == "function");\n\n  // Base64 (http://www.w3.org/TR/html5/webappapis.html#dom-windowbase64-atob)\n  r = r && (typeof atob == "function");\n  r = r && (typeof btoa == "function");\n\n  // skipping Array functions (map, join, push, length, etc.)\n  // skipping String functions (split, charCodeAt, fromCharCode, replace, etc.)\n  // skipping regexp.test and parseInt\n\n  return r;\n};\n\n/**\n * Feel free to override this function.\n */\nJose.assert = function(expr, msg) {\n  if (!expr) {\n    throw new Error(msg);\n  }\n};\n\nexports.Jose = Jose;\nexports.JoseJWE = JoseJWE;\nexports.JoseJWS = JoseJWS;\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The WebCryptographer uses http://www.w3.org/TR/WebCryptoAPI/ to perform\n * various crypto operations. In theory, this should help build the library with\n * different underlying crypto APIs. I\'m however unclear if we\'ll run into code\n * duplication or callback vs Promise based API issues.\n */\nvar WebCryptographer = function() {\n  this.setKeyEncryptionAlgorithm("RSA-OAEP");\n  this.setContentEncryptionAlgorithm("A256GCM");\n  this.setContentSignAlgorithm("RS256");\n};\n\nJose.WebCryptographer = WebCryptographer;\n\n/**\n * Overrides the default key encryption algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setKeyEncryptionAlgorithm = function(alg) {\n  this.key_encryption = getCryptoConfig(alg);\n};\n\nWebCryptographer.prototype.getKeyEncryptionAlgorithm = function() {\n  return this.key_encryption.jwe_name;\n};\n\n/**\n * Overrides the default content encryption algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setContentEncryptionAlgorithm = function(alg) {\n  this.content_encryption = getCryptoConfig(alg);\n};\n\nWebCryptographer.prototype.getContentEncryptionAlgorithm = function() {\n  return this.content_encryption.jwe_name;\n};\n\n/**\n * Overrides the default content sign algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setContentSignAlgorithm = function(alg) {\n  this.content_sign = getSignConfig(alg);\n};\n\nWebCryptographer.prototype.getContentSignAlgorithm = function() {\n  return this.content_sign.jwa_name;\n};\n\n/**\n * Generates an IV.\n * This function mainly exists so that it can be mocked for testing purpose.\n *\n * @return Uint8Array with random bytes\n */\nWebCryptographer.prototype.createIV = function() {\n  var iv = new Uint8Array(new Array(this.content_encryption.iv_bytes));\n  return Jose.crypto.getRandomValues(iv);\n};\n\n/**\n * Creates a random content encryption key.\n * This function mainly exists so that it can be mocked for testing purpose.\n *\n * @return Promise<CryptoKey>\n */\nWebCryptographer.prototype.createCek = function() {\n  var hack = getCekWorkaround(this.content_encryption);\n  return Jose.crypto.subtle.generateKey(hack.id, true, hack.enc_op);\n};\n\nWebCryptographer.prototype.wrapCek = function(cek, key) {\n  return Jose.crypto.subtle.wrapKey("raw", cek, key, this.key_encryption.id);\n};\n\nWebCryptographer.prototype.unwrapCek = function(cek, key) {\n  var hack = getCekWorkaround(this.content_encryption);\n  var extractable = (this.content_encryption.specific_cek_bytes > 0);\n  var key_encryption = this.key_encryption.id;\n\n  return Jose.crypto.subtle.unwrapKey("raw", cek, key, key_encryption, hack.id, extractable, hack.dec_op);\n};\n\n/**\n * Returns algorithm and operation needed to create a CEK.\n *\n * In some cases, e.g. A128CBC-HS256, the CEK gets split into two keys. The Web\n * Crypto API does not allow us to generate an arbitrary number of bytes and\n * then create a CryptoKey without any associated algorithm. We therefore piggy\n * back on AES-CBS and HMAC which allows the creation of CEKs of size 16, 32, 64\n * and 128 bytes.\n */\nvar getCekWorkaround = function(alg) {\n  var len = alg.specific_cek_bytes;\n  if (len) {\n    if (len == 16) {\n      return {id: {name: "AES-CBC", length: 128}, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n    } else if (len == 32) {\n      return {id: {name: "AES-CBC", length: 256}, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n    } else if (len == 64) {\n      return {id: {name: "HMAC", hash: {name: "SHA-256"}}, enc_op: ["sign"], dec_op: ["verify"]};\n    } else if (len == 128) {\n      return {id: {name: "HMAC", hash: {name: "SHA-384"}}, enc_op: ["sign"], dec_op: ["verify"]};\n    } else {\n      Jose.assert(false, "getCekWorkaround: invalid len");\n    }\n  }\n  return {id: alg.id, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n};\n\n/**\n * Encrypts plain_text with cek.\n *\n * @param iv          Uint8Array\n * @param aad         Uint8Array\n * @param cek_promise Promise<CryptoKey>\n * @param plain_text  Uint8Array\n * @return Promise<json>\n */\nWebCryptographer.prototype.encrypt = function(iv, aad, cek_promise, plain_text) {\n  var config = this.content_encryption;\n  if (iv.length != config.iv_bytes) {\n    return Promise.reject(Error("invalid IV length"));\n  }\n  if (config.auth.aead) {\n    var tag_bytes = config.auth.tag_bytes;\n\n    var enc = {\n      name: config.id.name,\n      iv: iv,\n      additionalData: aad,\n      tagLength: tag_bytes * 8\n    };\n\n    return cek_promise.then(function(cek) {\n      return Jose.crypto.subtle.encrypt(enc, cek, plain_text).then(function(cipher_text) {\n        var offset = cipher_text.byteLength - tag_bytes;\n        return {\n          cipher: cipher_text.slice(0, offset),\n          tag: cipher_text.slice(offset)\n        };\n      });\n    });\n  } else {\n    var keys = splitKey(config, cek_promise, ["encrypt"]);\n    var mac_key_promise = keys[0];\n    var enc_key_promise = keys[1];\n\n    // Encrypt the plain text\n    var cipher_text_promise = enc_key_promise.then(function(enc_key) {\n      var enc = {\n        name: config.id.name,\n        iv: iv\n      };\n      return Jose.crypto.subtle.encrypt(enc, enc_key, plain_text);\n    });\n\n    // compute MAC\n    var mac_promise = cipher_text_promise.then(function(cipher_text) {\n      return truncatedMac(\n        config,\n        mac_key_promise,\n        aad,\n        iv,\n        cipher_text);\n    });\n\n    return Promise.all([cipher_text_promise, mac_promise]).then(function(all) {\n      var cipher_text = all[0];\n      var mac = all[1];\n      return {\n        cipher: cipher_text,\n        tag: mac\n      };\n    });\n  }\n};\n\n/**\n * Decrypts cipher_text with cek. Validates the tag.\n *\n * @param cek_promise    Promise<CryptoKey>\n * @param aad protected header\n * @param iv IV\n * @param cipher_text text to be decrypted\n * @param tag to be verified\n * @return Promise<string>\n */\nWebCryptographer.prototype.decrypt = function(cek_promise, aad, iv, cipher_text, tag) {\n  /**\n   * Compares two Uint8Arrays in constant time.\n   *\n   * @return Promise<void>\n   */\n  var compare = function(config, mac_key_promise, arr1, arr2) {\n    Jose.assert(arr1 instanceof Uint8Array, "compare: invalid input");\n    Jose.assert(arr2 instanceof Uint8Array, "compare: invalid input");\n\n    return mac_key_promise.then(function(mac_key) {\n      var hash1 = Jose.crypto.subtle.sign(config.auth.id, mac_key, arr1);\n      var hash2 = Jose.crypto.subtle.sign(config.auth.id, mac_key, arr2);\n      return Promise.all([hash1, hash2]).then(function(all) {\n        var hash1 = new Uint8Array(all[0]);\n        var hash2 = new Uint8Array(all[1]);\n        if (hash1.length != hash2.length) {\n          throw new Error("compare failed");\n        }\n        for (var i = 0; i < hash1.length; i++) {\n          if (hash1[i] != hash2[i]) {\n            throw new Error("compare failed");\n          }\n        }\n        return Promise.resolve(null);\n      });\n    });\n  };\n\n  if (iv.length != this.content_encryption.iv_bytes) {\n    return Promise.reject(Error("decryptCiphertext: invalid IV"));\n  }\n\n  var config = this.content_encryption;\n  if (config.auth.aead) {\n    var dec = {\n      name: config.id.name,\n      iv: iv,\n      additionalData: aad,\n      tagLength: config.auth.tag_bytes * 8\n    };\n\n    return cek_promise.then(function(cek) {\n      var buf = Utils.arrayBufferConcat(cipher_text, tag);\n      return Jose.crypto.subtle.decrypt(dec, cek, buf);\n    });\n  } else {\n    var keys = splitKey(config, cek_promise, ["decrypt"]);\n    var mac_key_promise = keys[0];\n    var enc_key_promise = keys[1];\n\n    // Validate the MAC\n    var mac_promise = truncatedMac(\n      config,\n      mac_key_promise,\n      aad,\n      iv,\n      cipher_text);\n\n    return Promise.all([enc_key_promise, mac_promise]).then(function(all) {\n      var enc_key = all[0];\n      var mac = all[1];\n\n      return compare(config, mac_key_promise, new Uint8Array(mac), tag).then(function() {\n        var dec = {\n          name: config.id.name,\n          iv: iv\n        };\n        return Jose.crypto.subtle.decrypt(dec, enc_key, cipher_text);\n      }).catch(function(err) {\n        return Promise.reject(Error("decryptCiphertext: MAC failed."));\n      });\n    });\n  }\n};\n\n/**\n * Signs plain_text.\n *\n * @param aad         json\n * @param payload     String or json\n * @param key_promise Promise<CryptoKey>\n * @return Promise<ArrayBuffer>\n */\nWebCryptographer.prototype.sign = function(aad, payload, key_promise) {\n  var config = this.content_sign;\n\n  if (aad.alg) {\n    config = getSignConfig(aad.alg);\n  }\n\n  // Encrypt the plain text\n  return key_promise.then(function(key) {\n    return Jose.crypto.subtle.sign(config.id, key, Utils.arrayFromString(Utils.Base64Url.encode(JSON.stringify(aad)) + \'.\' + Utils.Base64Url.encodeArray(payload)));\n  });\n};\n\n/**\n * Verify JWS.\n *\n * @param payload     Base64Url encoded payload\n * @param aad         String Base64Url encoded JSON representation of the protected JWS header\n * @param signature   Uint8Array containing the signature\n * @param key_promise Promise<CryptoKey>\n * @param key_id      value of the kid JoseHeader, it\'ll be passed as part of the result to the returned promise\n * @return Promise<json>\n */\nWebCryptographer.prototype.verify = function(aad, payload, signature, key_promise, key_id) {\n  var config = this.content_sign;\n\n  return key_promise.then(function(key) {\n    config = getSignConfig(getJwaNameForSignKey(key));\n    return Jose.crypto.subtle.verify(config.id, key, signature, Utils.arrayFromString(aad + "." + payload)).then(function(res) {\n      return {kid: key_id, verified: res};\n    });\n  });\n};\n\nJose.WebCryptographer.keyId = function(rsa_key) {\n  return Utils.sha256(rsa_key.n + "+" + rsa_key.d);\n};\n\n/**\n * Splits a CEK into two pieces: a MAC key and an ENC key.\n *\n * This code is structured around the fact that the crypto API does not provide\n * a way to validate truncated MACs. The MAC key is therefore always imported to\n * sign data.\n *\n * @param config (used for key lengths & algorithms)\n * @param cek_promise Promise<CryptoKey>  CEK key to split\n * @param purpose Array<String> usages of the imported key\n * @return [Promise<mac key>, Promise<enc key>]\n */\nvar splitKey = function(config, cek_promise, purpose) {\n  // We need to split the CEK key into a MAC and ENC keys\n  var cek_bytes_promise = cek_promise.then(function(cek) {\n    return Jose.crypto.subtle.exportKey("raw", cek);\n  });\n  var mac_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n    if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n      return Promise.reject(Error("encryptPlainText: incorrect cek length"));\n    }\n    var bytes = cek_bytes.slice(0, config.auth.key_bytes);\n    return Jose.crypto.subtle.importKey("raw", bytes, config.auth.id, false, ["sign"]);\n  });\n  var enc_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n    if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n      return Promise.reject(Error("encryptPlainText: incorrect cek length"));\n    }\n    var bytes = cek_bytes.slice(config.auth.key_bytes);\n    return Jose.crypto.subtle.importKey("raw", bytes, config.id, false, purpose);\n  });\n  return [mac_key_promise, enc_key_promise];\n};\n\n/**\n * Converts the Jose web algorithms into data which is\n * useful for the Web Crypto API.\n *\n * length = in bits\n * bytes = in bytes\n */\nvar getCryptoConfig = function(alg) {\n  switch (alg) {\n    // Key encryption\n    case "RSA-OAEP":\n      return {\n        jwe_name: "RSA-OAEP",\n        id: {name: "RSA-OAEP", hash: {name: "SHA-1"}}\n      };\n    case "RSA-OAEP-256":\n      // return {\n      //   jwe_name: "RSA-OAEP-256",\n      //   id: {name: "RSA-OAEP-256", hash: {name: "SHA-256"}}\n      // };\n\n      // ORIGINAL SQUARE HEADER CONFIG\n      return {\n        jwe_name: "RSA-OAEP-256",\n        id: {name: "RSA-OAEP", hash: {name: "SHA-256"}}\n      };\n    case "A128KW":\n      return {\n        jwe_name: "A128KW",\n        id: {name: "AES-KW", length: 128}\n      };\n    case "A256KW":\n      return {\n        jwe_name: "A256KW",\n        id: {name: "AES-KW", length: 256}\n      };\n    case "dir":\n      return {\n        jwe_name: "dir"\n      };\n\n    // Content encryption\n    case "A128CBC-HS256":\n      return {\n        jwe_name: "A128CBC-HS256",\n        id: {name: "AES-CBC", length: 128},\n        iv_bytes: 16,\n        specific_cek_bytes: 32,\n        auth: {\n          key_bytes: 16,\n          id: {name: "HMAC", hash: {name: "SHA-256"}},\n          truncated_bytes: 16\n        }\n      };\n    case "A256CBC-HS512":\n      return {\n        jwe_name: "A256CBC-HS512",\n        id: {name: "AES-CBC", length: 256},\n        iv_bytes: 16,\n        specific_cek_bytes: 64,\n        auth: {\n          key_bytes: 32,\n          id: {name: "HMAC", hash: {name: "SHA-512"}},\n          truncated_bytes: 32\n        }\n      };\n    case "A128GCM":\n      return {\n        jwe_name: "A128GCM",\n        id: {name: "AES-GCM", length: 128},\n        iv_bytes: 12,\n        auth: {\n          aead: true,\n          tag_bytes: 16\n        }\n      };\n    case "A256GCM":\n      return {\n        jwe_name: "A256GCM",\n        id: {name: "AES-GCM", length: 256},\n        iv_bytes: 12,\n        auth: {\n          aead: true,\n          tag_bytes: 16\n        }\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n/**\n * Computes a truncated MAC.\n *\n * @param config              configuration\n * @param mac_key_promise     Promise<CryptoKey>  mac key\n * @param aad                 Uint8Array\n * @param iv                  Uint8Array\n * @param cipher_text         Uint8Array\n * @return Promise<buffer>    truncated MAC\n */\nvar truncatedMac = function(config, mac_key_promise, aad, iv, cipher_text) {\n  return mac_key_promise.then(function(mac_key) {\n    var al = new Uint8Array(Utils.arrayFromInt32(aad.length * 8));\n    var al_full = new Uint8Array(8);\n    al_full.set(al, 4);\n    var buf = Utils.arrayBufferConcat(aad, iv, cipher_text, al_full);\n    return Jose.crypto.subtle.sign(config.auth.id, mac_key, buf).then(function(bytes) {\n      return bytes.slice(0, config.auth.truncated_bytes);\n    });\n  });\n};\n\n/**\n * Converts the Jose web algorithms into data which is\n * useful for the Web Crypto API.\n */\nvar getSignConfig = function(alg) {\n\n  switch (alg) {\n    case "RS256":\n      return {\n        jwa_name: "RS256",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-256"}}\n      };\n    case "RS384":\n      return {\n        jwa_name: "RS384",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-384"}}\n      };\n    case "RS512":\n      return {\n        jwa_name: "RS512",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-512"}}\n      };\n    case "PS256":\n      return {\n        jwa_name: "PS256",\n        id: {name: "RSA-PSS", hash: {name: "SHA-256"}, saltLength: 20}\n      };\n    case "PS384":\n      return {\n        jwa_name: "PS384",\n        id: {name: "RSA-PSS", hash: {name: "SHA-384"}, saltLength: 20}\n      };\n    case "PS512":\n      return {\n        jwa_name: "PS512",\n        id: {name: "RSA-PSS", hash: {name: "SHA-512"}, saltLength: 20}\n      };\n    case "HS256":\n      return {\n        jwa_name: "HS256",\n        id: {name: "HMAC", hash: {name: "SHA-256"}}\n      };\n    case "HS384":\n      return {\n        jwa_name: "HS384",\n        id: {name: "HMAC", hash: {name: "SHA-384"}}\n      };\n    case "HS512":\n      return {\n        jwa_name: "HS512",\n        id: {name: "HMAC", hash: {name: "SHA-512"}}\n      };\n    case "ES256":\n      return {\n        jwa_name: "ES256",\n        id: {name: "ECDSA", hash: {name: "SHA-256"}}\n      };\n    case "ES384":\n      return {\n        jwa_name: "ES384",\n        id: {name: "ECDSA", hash: {name: "SHA-384"}}\n      };\n    case "ES512":\n      return {\n        jwa_name: "ES512",\n        id: {name: "ECDSA", hash: {name: "SHA-512"}}\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n/**\n * Returns JWA name for a given CryptoKey\n * @param key CryptoKey\n */\nvar getJwaNameForSignKey = function(key) {\n\n  var rv = "",\n    sign_algo = key.algorithm.name,\n    hash_algo = key.algorithm.hash.name;\n\n  if(sign_algo == "RSASSA-PKCS1-v1_5") {\n    rv = "R";\n  } else if(sign_algo == "RSA-PSS") {\n    rv = "P";\n  } else {\n    throw new Error("unsupported sign/verify algorithm " + sign_algo);\n  }\n\n  if(hash_algo.indexOf("SHA-") === 0) {\n    rv += "S";\n  } else {\n    throw new Error("unsupported hash algorithm " + sign_algo);\n  }\n\n  rv += hash_algo.substring(4);\n\n  return rv;\n};\n\n/**\n * Derives key usage from algorithm\'s name\n *\n * @param alg String algorithm name\n * @returns {*}\n */\nvar getKeyUsageByAlg = function(alg) {\n\n  switch (alg) {\n    // signature\n    case "RS256":\n    case "RS384":\n    case "RS512":\n    case "PS256":\n    case "PS384":\n    case "PS512":\n    case "HS256":\n    case "HS384":\n    case "HS512":\n    case "ES256":\n    case "ES384":\n    case "ES512":\n      return {\n        publicKey: "verify",\n        privateKey: "sign"\n      };\n    // key encryption\n    case "RSA-OAEP":\n    case "RSA-OAEP-256":\n    case "A128KW":\n    case "A256KW":\n      return {\n        publicKey: "wrapKey",\n        privateKey: "unwrapKey"\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n// Visa-specific\nmodule.exports = WebCryptographer;\n\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nJose.Utils = {};\nvar Utils = {};\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  public RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for \'e\').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nJose.Utils.importRsaPublicKey = function(rsa_key, alg) {\n  var jwk;\n  var config;\n  var usage = getKeyUsageByAlg(alg);\n\n  if (usage.publicKey == "wrapKey") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rsa_key, ["n", "e"]);\n    config = getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    config = getSignConfig(rk.alg);\n    jwk = Utils.convertRsaKey(rk, ["n", "e"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey("jwk", jwk, config.id, false, [usage.publicKey]);\n};\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP and RSA. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  private RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for \'e\').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nJose.Utils.importRsaPrivateKey = function(rsa_key, alg) {\n  var jwk;\n  var config;\n  var usage = getKeyUsageByAlg(alg);\n\n  if (usage.privateKey == "unwrapKey") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rsa_key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]);\n    config = getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n    config = getSignConfig(alg);\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rk, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey("jwk", jwk, config.id, false, [usage.privateKey]);\n};\n\n// Private functions\n\nUtils.isString = function(str) {\n  return ((typeof(str) == "string") || (str instanceof String));\n};\n\n/**\n * Takes an arrayish (an array, ArrayBuffer or Uint8Array)\n * and returns an array or a Uint8Array.\n *\n * @param arr  arrayish\n * @return array or Uint8Array\n */\nUtils.arrayish = function(arr) {\n  if (arr instanceof Array) {\n    return arr;\n  }\n  if (arr instanceof Uint8Array) {\n    return arr;\n  }\n  if (arr instanceof ArrayBuffer) {\n    return new Uint8Array(arr);\n  }\n  Jose.assert(false, "arrayish: invalid input");\n};\n\n/**\n * Checks if an RSA key contains all the expected parameters. Also checks their\n * types. Converts hex encoded strings (or numbers) to base64.\n *\n * @param rsa_key     RSA key in json format. Parameters can be base64 encoded,\n *                    strings or number (for \'e\').\n * @param parameters  array<string>\n * @return json\n */\nUtils.convertRsaKey = function(rsa_key, parameters) {\n  var r = {};\n  var alg;\n\n  // Check that we have all the parameters\n  var missing = [];\n  parameters.map(function(p){if (typeof(rsa_key[p]) == "undefined") { missing.push(p); }});\n\n  if (missing.length > 0) {\n    Jose.assert(false, "convertRsaKey: Was expecting " + missing.join());\n  }\n\n  // kty is either missing or is set to "RSA"\n  if (typeof(rsa_key.kty) != "undefined") {\n    Jose.assert(rsa_key.kty == "RSA", "convertRsaKey: expecting rsa_key[\'kty\'] to be \'RSA\'");\n  }\n  r.kty = "RSA";\n\n  try {\n    getSignConfig(rsa_key.alg);\n    alg = rsa_key.alg;\n  } catch (err) {\n    try {\n      getCryptoConfig(rsa_key.alg);\n      alg = rsa_key.alg;\n    } catch (er) {\n      Jose.assert(alg, "convertRsaKey: expecting rsa_key[\'alg\'] to have a valid value");\n    }\n  }\n  r.alg = alg;\n\n  // note: we punt on checking key_ops\n\n  var intFromHex = function(e) {\n    return parseInt(e, 16);\n  };\n  for (var i = 0; i < parameters.length; i++) {\n    var p = parameters[i];\n    var v = rsa_key[p];\n    if (p == "e") {\n      if (typeof(v) == "number") {\n        v = Utils.Base64Url.encodeArray(Utils.stripLeadingZeros(Utils.arrayFromInt32(v)));\n      }\n    } else if (/^([0-9a-fA-F]{2}:)+[0-9a-fA-F]{2}$/.test(v)) {\n      var arr = v.split(":").map(intFromHex);\n      v = Utils.Base64Url.encodeArray(Utils.stripLeadingZeros(arr));\n    } else if (typeof(v) != "string") {\n      Jose.assert(false, "convertRsaKey: expecting rsa_key[\'" + p + "\'] to be a string");\n    }\n    r[p] = v;\n  }\n\n  return r;\n};\n\n/**\n * Converts a string into an array of ascii codes.\n *\n * @param str  ascii string\n * @return Uint8Array\n */\nUtils.arrayFromString = function(str) {\n  Jose.assert(Utils.isString(str), "arrayFromString: invalid input");\n  var arr = str.split(\'\').map(function(c) {\n    return c.charCodeAt(0);\n  });\n  return new Uint8Array(arr);\n};\n\n/**\n * Converts a string into an array of utf-8 codes.\n *\n* @param str  utf-8 string\n * @return Uint8Array\n */\nUtils.arrayFromUtf8String = function(str) {\n  Jose.assert(Utils.isString(str), "arrayFromUtf8String: invalid input");\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  str = unescape(encodeURIComponent(str));\n  return Utils.arrayFromString(str);\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  arrayish\n * @return ascii string\n */\nUtils.stringFromArray = function(arr) {\n  arr = Utils.arrayish(arr);\n  var r = \'\';\n  for (var i = 0; i < arr.length; i++) {\n    r += String.fromCharCode(arr[i]);\n  }\n\n  return r;\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  ArrayBuffer\n * @return ascii string\n */\nUtils.utf8StringFromArray = function(arr) {\n  Jose.assert(arr instanceof ArrayBuffer, "utf8StringFromArray: invalid input");\n\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  var r = Utils.stringFromArray(arr);\n  return decodeURIComponent(escape(r));\n};\n\n/**\n * Strips leading zero in an array.\n *\n * @param arr  arrayish\n * @return array\n */\nUtils.stripLeadingZeros = function(arr) {\n  if (arr instanceof ArrayBuffer) {\n    arr = new Uint8Array(arr);\n  }\n  var is_leading_zero = true;\n  var r = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (is_leading_zero && arr[i] === 0) {\n      continue;\n    }\n    is_leading_zero = false;\n    r.push(arr[i]);\n  }\n  return r;\n};\n\n/**\n * Converts a number into an array of 4 bytes (big endian).\n *\n * @param i  number\n * @return ArrayBuffer\n */\nUtils.arrayFromInt32 = function(i) {\n  Jose.assert(typeof(i) == "number", "arrayFromInt32: invalid input");\n  Jose.assert(i == i | 0, "arrayFromInt32: out of range");\n\n  var buf = new Uint8Array(new Uint32Array([i]).buffer);\n  var r = new Uint8Array(4);\n  for (var j = 0; j < 4; j++) {\n    r[j] = buf[3 - j];\n  }\n  return r.buffer;\n};\n\n/**\n * Concatenates arrayishes.\n *\n * @param arguments two or more arrayishes\n * @return Uint8Array\n */\nUtils.arrayBufferConcat = function(/* ... */) {\n  // Compute total size\n  var args = [];\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(Utils.arrayish(arguments[i]));\n    total += args[i].length;\n  }\n  var r = new Uint8Array(total);\n  var offset = 0;\n  for (i = 0; i < arguments.length; i++) {\n    for (var j = 0; j < args[i].length; j++) {\n      r[offset++] = args[i][j];\n    }\n  }\n  Jose.assert(offset == total, "arrayBufferConcat: unexpected offset");\n  return r;\n};\n\nUtils.Base64Url = {};\n\n/**\n * Base64Url encodes a string (no trailing \'=\')\n *\n * @param str  string\n * @return string\n */\nUtils.Base64Url.encode = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.encode: invalid input");\n  return btoa(str)\n    .replace(/\\+/g, "-")\n    .replace(/\\//g, "_")\n    .replace(/=+$/, "");\n};\n\n/**\n * Base64Url encodes an array\n *\n * @param arr array or ArrayBuffer\n * @return string\n */\nUtils.Base64Url.encodeArray = function(arr) {\n  return Utils.Base64Url.encode(Utils.stringFromArray(arr));\n};\n\n/**\n * Base64Url decodes a string\n *\n * @param str  string\n * @return string\n */\nUtils.Base64Url.decode = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.decode: invalid input");\n  // atob is nice and ignores missing \'=\'\n  return atob(str.replace(/-/g, "+").replace(/_/g, "/"));\n};\n\nUtils.Base64Url.decodeArray = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.decodeArray: invalid input");\n  return Utils.arrayFromString(Utils.Base64Url.decode(str));\n};\n\nUtils.sha256 = function(str) {\n  // Browser docs indicate the first parameter to crypto.subtle.digest to be a\n  // DOMString. This was initially implemented as an object and continues to be\n  // supported, so we favor the older form for backwards compatibility.\n  return Jose.crypto.subtle.digest({name: "SHA-256"}, Utils.arrayFromString(str)).then(function(hash) {\n    return Utils.Base64Url.encodeArray(hash);\n  });\n};\n\nUtils.isCryptoKey = function(rsa_key) {\n  // Some browsers don\'t expose the CryptoKey as an object, so we need to check\n  // the constructor\'s name.\n  if (rsa_key.constructor.name == \'CryptoKey\') {\n    return true;\n  }\n\n  // In the presence of minifiers, relying on class names can be problematic,\n  // so let\'s also allow objects that have an \'algorithm\' property.\n  if (rsa_key.hasOwnProperty(\'algorithm\')) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = Utils;\n\n\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Handles encryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent).\n * @param key_promise    Promise<CryptoKey>, either RSA or shared key\n */\nJoseJWE.Encrypter = function(cryptographer, key_promise) {\n  this.cryptographer = cryptographer;\n  this.key_promise = key_promise;\n  this.userHeaders = {};\n};\n\n/**\n * Adds a key/value pair which will be included in the header.\n *\n * The data lives in plaintext (an attacker can read the header) but is tamper\n * proof (an attacker cannot modify the header).\n *\n * Note: some headers have semantic implications. E.g. if you set the "zip"\n * header, you are responsible for properly compressing plain_text before\n * calling encrypt().\n *\n * @param k  String\n * @param v  String\n */\nJoseJWE.Encrypter.prototype.addHeader = function(k, v) {\n  this.userHeaders[k] = v;\n};\n\n/**\n *\n * Visa-custom\n * returns the header value\n * \n * @param k  String\n */\nJoseJWE.Encrypter.prototype.getHeader = function(k) {\n  return this.userHeaders[k];\n};\n\n/**\n * Performs encryption.\n *\n * @param plain_text  utf-8 string\n * @return Promise<String>\n */\nJoseJWE.Encrypter.prototype.encrypt = function(plain_text) {\n  /**\n   * Encrypts plain_text with CEK.\n   *\n   * @param cek_promise  Promise<CryptoKey>\n   * @param plain_text   string\n   * @return Promise<json>\n   */\n  var encryptPlainText = function(cek_promise, plain_text) {\n    // Create header\n    var headers = {};\n    for (var i in this.userHeaders) {\n      headers[i] = this.userHeaders[i];\n    }\n\n    headers.alg = this.cryptographer.getKeyEncryptionAlgorithm();\n    headers.enc = this.cryptographer.getContentEncryptionAlgorithm();\n    var jwe_protected_header = Utils.Base64Url.encode(JSON.stringify(headers));\n\n    // Create the IV\n    var iv = this.cryptographer.createIV();\n\n    // Create the AAD\n    var aad = Utils.arrayFromString(jwe_protected_header);\n    plain_text = Utils.arrayFromUtf8String(plain_text);\n\n    return this.cryptographer.encrypt(iv, aad, cek_promise, plain_text).then(function(r) {\n      r.header = jwe_protected_header;\n      r.iv = iv;\n      return r;\n    });\n  };\n\n  var cek_promise, encrypted_cek;\n\n  if (this.cryptographer.getKeyEncryptionAlgorithm() == "dir") {\n    // with direct encryption, this.key_promise provides the cek\n    // and encrypted_cek is empty\n    cek_promise = Promise.resolve(this.key_promise);\n    encrypted_cek = [];\n  } else {\n    // Create a CEK key\n    cek_promise = this.cryptographer.createCek();\n\n    // Key & Cek allows us to create the encrypted_cek\n    encrypted_cek = Promise.all([this.key_promise, cek_promise]).then(function (all) {\n      var key = all[0];\n      var cek = all[1];\n      return this.cryptographer.wrapCek(cek, key);\n    }.bind(this));\n  }\n\n  // Cek allows us to encrypy the plain text\n  var enc_promise = encryptPlainText.bind(this, cek_promise, plain_text)();\n\n  // Once we have all the promises, we can base64 encode all the pieces.\n  return Promise.all([encrypted_cek, enc_promise]).then(function(all) {\n    var encrypted_cek = all[0];\n    var data = all[1];\n    return data.header + "." +\n      Utils.Base64Url.encodeArray(encrypted_cek) + "." +\n      Utils.Base64Url.encodeArray(data.iv) + "." +\n      Utils.Base64Url.encodeArray(data.cipher) + "." +\n      Utils.Base64Url.encodeArray(data.tag);\n  });\n};\n\n/* eslint-disable */\n/**\n * Syntactic sugar for Visa VDCP use-case.\n * expects an RSA key as a JS data object with 2 required fields:\n * @param {!string} rsaKeyId (REQUIRED)\n * @param {!object} rsaKey (REQUIRED)\n *    Requires:\n *      - `n` attribute (modulus)\n *      - `e` attribute (publicExponent)\n * @param {?string} scheme (optional) default \'RSA-OAEP-256\'\n * @param {?API} cryptoProvider (optional) window.crypto, node-webcrypto-ossl, node-webcrypto-pkcs11 etc.\n */\nvar PANJWE = function(rsaKeyId, rsaKey, scheme, cryptoProvider) {\n  scheme = scheme || \'RSA-OAEP-256\';\n\n  if (cryptoProvider) {\n    Jose.setCrypto(cryptoProvider);\n  }\n\n  var cryptographer = new Jose.WebCryptographer();\n\n  // set values for scheme and content encryption algorithm. They will be added to header by JoseJWE.Encrypter.encrypt\n  cryptographer.setKeyEncryptionAlgorithm(scheme);\n  cryptographer.setContentEncryptionAlgorithm(\'A256GCM\');\n\n  var rsa_key = Jose.Utils.importRsaPublicKey(rsaKey, scheme);\n  var encrypter = new JoseJWE.Encrypter(cryptographer, rsa_key);\n  encrypter.addHeader(\'kid\', rsaKeyId);\n  encrypter.addHeader(\'typ\', \'JOSE\');\n  encrypter.addHeader(\'iat\', new Date().getTime());\n\n  this.encrypter = encrypter;\n\n  // for testing, testing bundle includes decrypter mixins\n  if (JoseJWE.Decrypter) {\n    var private_rsa_key = Jose.Utils.importRsaPrivateKey(rsaKey, scheme);\n    var decrypter = new JoseJWE.Decrypter(cryptographer, private_rsa_key);\n    this.decrypter = decrypter;\n\n    /**\n     * encrypts text\n     * @param {!string} encryptedText string to decrypt\n     * @returns {Promise}\n     */\n    this.decrypt = function(encryptedText) {\n      return this.decrypter.decrypt(encryptedText);\n    };\n  }\n\n  /**\n   * sanity check\n   * @returns {object}\n   */\n  this.sanityCheck = function() {\n    return Jose.caniuse();\n  };\n\n  /**\n   * encrypts text\n   * @param {!string} cipherText string to encrypt\n   * @returns {Promise}\n   */\n  this.encrypt = function(cipherText) {\n    return this.encrypter.encrypt(cipherText);\n  };\n};\n\nmodule.exports.PANJWE = PANJWE;\nexports.PANJWE = PANJWE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Y2VzIjpbIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2pvc2UvdmlzYS1lbmNyeXB0LmpzPzNhOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyotXG4gKiBDb3B5cmlnaHQgMjAxNCBTcXVhcmUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgSm9zZSA9IHt9O1xuXG4vKipcbiAqIEphdmFzY3JpcHQgT2JqZWN0IFNpZ25pbmcgYW5kIEVuY3J5cHRpb24gbGlicmFyeS5cbiAqXG4gKiBAYXV0aG9yIEFsb2sgTWVuZ2hyYWphbmkgPGFsb2tAc3F1YXJldXAuY29tPlxuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBKb3NlSldFIG9iamVjdC5cbiAqL1xudmFyIEpvc2VKV0UgPSB7fTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIEpvc2VKV1Mgb2JqZWN0LlxuICovXG52YXIgSm9zZUpXUyA9IHt9O1xuXG4vKipcbiAqIFNldCBjcnlwdG8gcHJvdmlkZXIgdG8gdXNlICh3aW5kb3cuY3J5cHRvLCBub2RlLXdlYmNyeXB0by1vc3NsLCBub2RlLXdlYmNyeXB0by1wa2NzMTEgZXRjLikuXG4gKi9cbmV4cG9ydHMuc2V0Q3J5cHRvID0gZnVuY3Rpb24gKGNwKSB7XG4gIEpvc2UuY3J5cHRvID0gY3A7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgdG8gdGhlIGdsb2JhbCBcImNyeXB0b1wiIHZhcmlhYmxlXG4gKi9cbmlmICh0eXBlb2YoY3J5cHRvKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5zZXRDcnlwdG8oY3J5cHRvKTtcbn1cblxuLyoqXG4gKiBVc2UgTm9kZSB2ZXJzaW9ucyBvZiBhdG9iLCBidG9hIGZ1bmN0aW9ucyBvdXRzaWRlIHRoZSBicm93c2VyXG4gKi9cbmlmICh0eXBlb2YgYXRvYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIGF0b2IgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xuICB9O1xufVxuXG5pZiAodHlwZW9mIGJ0b2EgIT09IFwiZnVuY3Rpb25cIikge1xuICBidG9hID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKHN0ciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gc3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHN0ci50b1N0cmluZygpLCAnYmluYXJ5Jyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB3ZSBoYXZlIGFsbCB0aGUgcmVxdWlyZWQgQVBJcy5cbiAqXG4gKiBJdCBtaWdodCBtYWtlIHNlbnNlIHRvIHRha2UgYSBDcnlwdG9ncmFwaGVyIGFuZCBkZWxlZ2F0ZSBzb21lIG9mIHRoZSBjaGVja3NcbiAqIHRvIHRoZSBjcnlwdG9ncmFwaGVyLiBJIGhvd2V2ZXIgd2FudGVkIHRvIGtlZXAgdGhpbmdzIHNpbXBsZSwgc28gSSBwdXQgYWxsXG4gKiB0aGUgY2hlY2tzIGhlcmUgZm9yIG5vdy5cbiAqXG4gKiBUaGlzIGxpc3QgaXMgZ2VuZXJhdGVkIG1hbnVhbGx5IGFuZCBuZWVkcyB0byBiZSBrZXB0IHVwLXRvLWRhdGUuXG4gKlxuICogQ2FzdWFsIHRlc3Rpbmcgc2hvd3MgdGhhdDpcbiAqIC0gdGhpbmdzIHdvcmsgaW4gQ2hyb21lIDQwLjAuMjIxNC4xMTVcbiAqIC0gdGhpbmdzIHdvcmsgaW4gRmlyZWZveCAzNS4wLjFcbiAqIC0gU2FmYXJpIDcuMS4zIGRvZXNuJ3Qgc3VwcG9ydCBKV0sga2V5cy5cbiAqIC0gSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCBzdXBwb3J0IFByb21pc2VzLlxuICpcbiAqIE5vdGU6IFdlIGRvbid0IGNoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHNwZWNpZmljIGNyeXB0byBvcGVyYXRpb25zLlxuICogICAgICAgSS5lLiBpdCdzIHBvc3NpYmxlIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiB0cnVlLCBidXQgZW5jcnlwdGlvbiBvclxuICogICAgICAgZGVjcnlwdGlvbiB0byBzdWJzZXF1ZW50bHkgZmFpbCBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYVxuICogICAgICAgZ2l2ZW4gZW5jcnlwdGlvbiwgZGVjcnlwdGlvbiwga2V5IHdyYXBwaW5nLCBrZXkgdW53cmFwcGluZyBvciBobWFjXG4gKiAgICAgICBvcGVyYXRpb24uXG4gKlxuICogQHJldHVybiBib29sXG4gKi9cbkpvc2UuY2FuaXVzZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IHRydWU7XG5cbiAgLy8gUHJvbWlzZXMvQSsgKGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vKVxuICByID0gciAmJiAodHlwZW9mIFByb21pc2UgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBQcm9taXNlLnJlamVjdCA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIFByb21pc2UucHJvdG90eXBlLnRoZW4gPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBQcm9taXNlLmFsbCA9PSBcImZ1bmN0aW9uXCIpO1xuXG4gIC8vIENyeXB0byAoaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLylcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0byA9PSBcIm9iamVjdFwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5zdWJ0bGUgPT0gXCJvYmplY3RcIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLmltcG9ydEtleSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5zdWJ0bGUud3JhcEtleSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS51bndyYXBLZXkgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5zdWJ0bGUuZW5jcnlwdCA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS5kZWNyeXB0ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLnNpZ24gPT0gXCJmdW5jdGlvblwiKTtcblxuICAvLyBBcnJheUJ1ZmZlciAoaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtYXJyYXlidWZmZXItY29uc3RydWN0b3IpXG4gIHIgPSByICYmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBVaW50OEFycmF5ID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgVWludDhBcnJheSA9PSBcIm9iamVjdFwiKTsgLy8gU2FmYXJpIHVzZXMgXCJvYmplY3RcIlxuICByID0gciAmJiAodHlwZW9mIFVpbnQzMkFycmF5ID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgVWludDMyQXJyYXkgPT0gXCJvYmplY3RcIik7IC8vIFNhZmFyaSB1c2VzIFwib2JqZWN0XCJcbiAgLy8gc2tpcHBpbmcgVWludDMyQXJyYXkucHJvdG90eXBlLmJ1ZmZlciBiZWNhdXNlIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS0ldHlwZWRhcnJheXByb3RvdHlwZSUtb2JqZWN0XG5cbiAgLy8gSlNPTiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEyLjMpXG4gIHIgPSByICYmICh0eXBlb2YgSlNPTiA9PSBcIm9iamVjdFwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKU09OLnBhcnNlID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiKTtcblxuICAvLyBCYXNlNjQgKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3dlYmFwcGFwaXMuaHRtbCNkb20td2luZG93YmFzZTY0LWF0b2IpXG4gIHIgPSByICYmICh0eXBlb2YgYXRvYiA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIGJ0b2EgPT0gXCJmdW5jdGlvblwiKTtcblxuICAvLyBza2lwcGluZyBBcnJheSBmdW5jdGlvbnMgKG1hcCwgam9pbiwgcHVzaCwgbGVuZ3RoLCBldGMuKVxuICAvLyBza2lwcGluZyBTdHJpbmcgZnVuY3Rpb25zIChzcGxpdCwgY2hhckNvZGVBdCwgZnJvbUNoYXJDb2RlLCByZXBsYWNlLCBldGMuKVxuICAvLyBza2lwcGluZyByZWdleHAudGVzdCBhbmQgcGFyc2VJbnRcblxuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogRmVlbCBmcmVlIHRvIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkpvc2UuYXNzZXJ0ID0gZnVuY3Rpb24oZXhwciwgbXNnKSB7XG4gIGlmICghZXhwcikge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59O1xuXG5leHBvcnRzLkpvc2UgPSBKb3NlO1xuZXhwb3J0cy5Kb3NlSldFID0gSm9zZUpXRTtcbmV4cG9ydHMuSm9zZUpXUyA9IEpvc2VKV1M7XG4vKi1cbiAqIENvcHlyaWdodCAyMDE0IFNxdWFyZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVGhlIFdlYkNyeXB0b2dyYXBoZXIgdXNlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9XZWJDcnlwdG9BUEkvIHRvIHBlcmZvcm1cbiAqIHZhcmlvdXMgY3J5cHRvIG9wZXJhdGlvbnMuIEluIHRoZW9yeSwgdGhpcyBzaG91bGQgaGVscCBidWlsZCB0aGUgbGlicmFyeSB3aXRoXG4gKiBkaWZmZXJlbnQgdW5kZXJseWluZyBjcnlwdG8gQVBJcy4gSSdtIGhvd2V2ZXIgdW5jbGVhciBpZiB3ZSdsbCBydW4gaW50byBjb2RlXG4gKiBkdXBsaWNhdGlvbiBvciBjYWxsYmFjayB2cyBQcm9taXNlIGJhc2VkIEFQSSBpc3N1ZXMuXG4gKi9cbnZhciBXZWJDcnlwdG9ncmFwaGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0S2V5RW5jcnlwdGlvbkFsZ29yaXRobShcIlJTQS1PQUVQXCIpO1xuICB0aGlzLnNldENvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtKFwiQTI1NkdDTVwiKTtcbiAgdGhpcy5zZXRDb250ZW50U2lnbkFsZ29yaXRobShcIlJTMjU2XCIpO1xufTtcblxuSm9zZS5XZWJDcnlwdG9ncmFwaGVyID0gV2ViQ3J5cHRvZ3JhcGhlcjtcblxuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQga2V5IGVuY3J5cHRpb24gYWxnb3JpdGhtXG4gKiBAcGFyYW0gYWxnICBzdHJpbmdcbiAqL1xuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUuc2V0S2V5RW5jcnlwdGlvbkFsZ29yaXRobSA9IGZ1bmN0aW9uKGFsZykge1xuICB0aGlzLmtleV9lbmNyeXB0aW9uID0gZ2V0Q3J5cHRvQ29uZmlnKGFsZyk7XG59O1xuXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5nZXRLZXlFbmNyeXB0aW9uQWxnb3JpdGhtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmtleV9lbmNyeXB0aW9uLmp3ZV9uYW1lO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgY29udGVudCBlbmNyeXB0aW9uIGFsZ29yaXRobVxuICogQHBhcmFtIGFsZyAgc3RyaW5nXG4gKi9cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLnNldENvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtID0gZnVuY3Rpb24oYWxnKSB7XG4gIHRoaXMuY29udGVudF9lbmNyeXB0aW9uID0gZ2V0Q3J5cHRvQ29uZmlnKGFsZyk7XG59O1xuXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5nZXRDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50X2VuY3J5cHRpb24uandlX25hbWU7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBjb250ZW50IHNpZ24gYWxnb3JpdGhtXG4gKiBAcGFyYW0gYWxnICBzdHJpbmdcbiAqL1xuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUuc2V0Q29udGVudFNpZ25BbGdvcml0aG0gPSBmdW5jdGlvbihhbGcpIHtcbiAgdGhpcy5jb250ZW50X3NpZ24gPSBnZXRTaWduQ29uZmlnKGFsZyk7XG59O1xuXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5nZXRDb250ZW50U2lnbkFsZ29yaXRobSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50X3NpZ24uandhX25hbWU7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBJVi5cbiAqIFRoaXMgZnVuY3Rpb24gbWFpbmx5IGV4aXN0cyBzbyB0aGF0IGl0IGNhbiBiZSBtb2NrZWQgZm9yIHRlc3RpbmcgcHVycG9zZS5cbiAqXG4gKiBAcmV0dXJuIFVpbnQ4QXJyYXkgd2l0aCByYW5kb20gYnl0ZXNcbiAqL1xuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUuY3JlYXRlSVYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl2ID0gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5KHRoaXMuY29udGVudF9lbmNyeXB0aW9uLml2X2J5dGVzKSk7XG4gIHJldHVybiBKb3NlLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoaXYpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmFuZG9tIGNvbnRlbnQgZW5jcnlwdGlvbiBrZXkuXG4gKiBUaGlzIGZ1bmN0aW9uIG1haW5seSBleGlzdHMgc28gdGhhdCBpdCBjYW4gYmUgbW9ja2VkIGZvciB0ZXN0aW5nIHB1cnBvc2UuXG4gKlxuICogQHJldHVybiBQcm9taXNlPENyeXB0b0tleT5cbiAqL1xuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUuY3JlYXRlQ2VrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWNrID0gZ2V0Q2VrV29ya2Fyb3VuZCh0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbik7XG4gIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoaGFjay5pZCwgdHJ1ZSwgaGFjay5lbmNfb3ApO1xufTtcblxuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUud3JhcENlayA9IGZ1bmN0aW9uKGNlaywga2V5KSB7XG4gIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUud3JhcEtleShcInJhd1wiLCBjZWssIGtleSwgdGhpcy5rZXlfZW5jcnlwdGlvbi5pZCk7XG59O1xuXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS51bndyYXBDZWsgPSBmdW5jdGlvbihjZWssIGtleSkge1xuICB2YXIgaGFjayA9IGdldENla1dvcmthcm91bmQodGhpcy5jb250ZW50X2VuY3J5cHRpb24pO1xuICB2YXIgZXh0cmFjdGFibGUgPSAodGhpcy5jb250ZW50X2VuY3J5cHRpb24uc3BlY2lmaWNfY2VrX2J5dGVzID4gMCk7XG4gIHZhciBrZXlfZW5jcnlwdGlvbiA9IHRoaXMua2V5X2VuY3J5cHRpb24uaWQ7XG5cbiAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS51bndyYXBLZXkoXCJyYXdcIiwgY2VrLCBrZXksIGtleV9lbmNyeXB0aW9uLCBoYWNrLmlkLCBleHRyYWN0YWJsZSwgaGFjay5kZWNfb3ApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsZ29yaXRobSBhbmQgb3BlcmF0aW9uIG5lZWRlZCB0byBjcmVhdGUgYSBDRUsuXG4gKlxuICogSW4gc29tZSBjYXNlcywgZS5nLiBBMTI4Q0JDLUhTMjU2LCB0aGUgQ0VLIGdldHMgc3BsaXQgaW50byB0d28ga2V5cy4gVGhlIFdlYlxuICogQ3J5cHRvIEFQSSBkb2VzIG5vdCBhbGxvdyB1cyB0byBnZW5lcmF0ZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGJ5dGVzIGFuZFxuICogdGhlbiBjcmVhdGUgYSBDcnlwdG9LZXkgd2l0aG91dCBhbnkgYXNzb2NpYXRlZCBhbGdvcml0aG0uIFdlIHRoZXJlZm9yZSBwaWdneVxuICogYmFjayBvbiBBRVMtQ0JTIGFuZCBITUFDIHdoaWNoIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgQ0VLcyBvZiBzaXplIDE2LCAzMiwgNjRcbiAqIGFuZCAxMjggYnl0ZXMuXG4gKi9cbnZhciBnZXRDZWtXb3JrYXJvdW5kID0gZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBsZW4gPSBhbGcuc3BlY2lmaWNfY2VrX2J5dGVzO1xuICBpZiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PSAxNikge1xuICAgICAgcmV0dXJuIHtpZDoge25hbWU6IFwiQUVTLUNCQ1wiLCBsZW5ndGg6IDEyOH0sIGVuY19vcDogW1wiZW5jcnlwdFwiXSwgZGVjX29wOiBbXCJkZWNyeXB0XCJdfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PSAzMikge1xuICAgICAgcmV0dXJuIHtpZDoge25hbWU6IFwiQUVTLUNCQ1wiLCBsZW5ndGg6IDI1Nn0sIGVuY19vcDogW1wiZW5jcnlwdFwiXSwgZGVjX29wOiBbXCJkZWNyeXB0XCJdfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PSA2NCkge1xuICAgICAgcmV0dXJuIHtpZDoge25hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fSwgZW5jX29wOiBbXCJzaWduXCJdLCBkZWNfb3A6IFtcInZlcmlmeVwiXX07XG4gICAgfSBlbHNlIGlmIChsZW4gPT0gMTI4KSB7XG4gICAgICByZXR1cm4ge2lkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0zODRcIn19LCBlbmNfb3A6IFtcInNpZ25cIl0sIGRlY19vcDogW1widmVyaWZ5XCJdfTtcbiAgICB9IGVsc2Uge1xuICAgICAgSm9zZS5hc3NlcnQoZmFsc2UsIFwiZ2V0Q2VrV29ya2Fyb3VuZDogaW52YWxpZCBsZW5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7aWQ6IGFsZy5pZCwgZW5jX29wOiBbXCJlbmNyeXB0XCJdLCBkZWNfb3A6IFtcImRlY3J5cHRcIl19O1xufTtcblxuLyoqXG4gKiBFbmNyeXB0cyBwbGFpbl90ZXh0IHdpdGggY2VrLlxuICpcbiAqIEBwYXJhbSBpdiAgICAgICAgICBVaW50OEFycmF5XG4gKiBAcGFyYW0gYWFkICAgICAgICAgVWludDhBcnJheVxuICogQHBhcmFtIGNla19wcm9taXNlIFByb21pc2U8Q3J5cHRvS2V5PlxuICogQHBhcmFtIHBsYWluX3RleHQgIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm4gUHJvbWlzZTxqc29uPlxuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaXYsIGFhZCwgY2VrX3Byb21pc2UsIHBsYWluX3RleHQpIHtcbiAgdmFyIGNvbmZpZyA9IHRoaXMuY29udGVudF9lbmNyeXB0aW9uO1xuICBpZiAoaXYubGVuZ3RoICE9IGNvbmZpZy5pdl9ieXRlcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChFcnJvcihcImludmFsaWQgSVYgbGVuZ3RoXCIpKTtcbiAgfVxuICBpZiAoY29uZmlnLmF1dGguYWVhZCkge1xuICAgIHZhciB0YWdfYnl0ZXMgPSBjb25maWcuYXV0aC50YWdfYnl0ZXM7XG5cbiAgICB2YXIgZW5jID0ge1xuICAgICAgbmFtZTogY29uZmlnLmlkLm5hbWUsXG4gICAgICBpdjogaXYsXG4gICAgICBhZGRpdGlvbmFsRGF0YTogYWFkLFxuICAgICAgdGFnTGVuZ3RoOiB0YWdfYnl0ZXMgKiA4XG4gICAgfTtcblxuICAgIHJldHVybiBjZWtfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNlaykge1xuICAgICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGVuYywgY2VrLCBwbGFpbl90ZXh0KS50aGVuKGZ1bmN0aW9uKGNpcGhlcl90ZXh0KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBjaXBoZXJfdGV4dC5ieXRlTGVuZ3RoIC0gdGFnX2J5dGVzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNpcGhlcjogY2lwaGVyX3RleHQuc2xpY2UoMCwgb2Zmc2V0KSxcbiAgICAgICAgICB0YWc6IGNpcGhlcl90ZXh0LnNsaWNlKG9mZnNldClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXlzID0gc3BsaXRLZXkoY29uZmlnLCBjZWtfcHJvbWlzZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgdmFyIG1hY19rZXlfcHJvbWlzZSA9IGtleXNbMF07XG4gICAgdmFyIGVuY19rZXlfcHJvbWlzZSA9IGtleXNbMV07XG5cbiAgICAvLyBFbmNyeXB0IHRoZSBwbGFpbiB0ZXh0XG4gICAgdmFyIGNpcGhlcl90ZXh0X3Byb21pc2UgPSBlbmNfa2V5X3Byb21pc2UudGhlbihmdW5jdGlvbihlbmNfa2V5KSB7XG4gICAgICB2YXIgZW5jID0ge1xuICAgICAgICBuYW1lOiBjb25maWcuaWQubmFtZSxcbiAgICAgICAgaXY6IGl2XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGVuYywgZW5jX2tleSwgcGxhaW5fdGV4dCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb21wdXRlIE1BQ1xuICAgIHZhciBtYWNfcHJvbWlzZSA9IGNpcGhlcl90ZXh0X3Byb21pc2UudGhlbihmdW5jdGlvbihjaXBoZXJfdGV4dCkge1xuICAgICAgcmV0dXJuIHRydW5jYXRlZE1hYyhcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYWNfa2V5X3Byb21pc2UsXG4gICAgICAgIGFhZCxcbiAgICAgICAgaXYsXG4gICAgICAgIGNpcGhlcl90ZXh0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbY2lwaGVyX3RleHRfcHJvbWlzZSwgbWFjX3Byb21pc2VdKS50aGVuKGZ1bmN0aW9uKGFsbCkge1xuICAgICAgdmFyIGNpcGhlcl90ZXh0ID0gYWxsWzBdO1xuICAgICAgdmFyIG1hYyA9IGFsbFsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcGhlcjogY2lwaGVyX3RleHQsXG4gICAgICAgIHRhZzogbWFjXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIERlY3J5cHRzIGNpcGhlcl90ZXh0IHdpdGggY2VrLiBWYWxpZGF0ZXMgdGhlIHRhZy5cbiAqXG4gKiBAcGFyYW0gY2VrX3Byb21pc2UgICAgUHJvbWlzZTxDcnlwdG9LZXk+XG4gKiBAcGFyYW0gYWFkIHByb3RlY3RlZCBoZWFkZXJcbiAqIEBwYXJhbSBpdiBJVlxuICogQHBhcmFtIGNpcGhlcl90ZXh0IHRleHQgdG8gYmUgZGVjcnlwdGVkXG4gKiBAcGFyYW0gdGFnIHRvIGJlIHZlcmlmaWVkXG4gKiBAcmV0dXJuIFByb21pc2U8c3RyaW5nPlxuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2VrX3Byb21pc2UsIGFhZCwgaXYsIGNpcGhlcl90ZXh0LCB0YWcpIHtcbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBVaW50OEFycmF5cyBpbiBjb25zdGFudCB0aW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIFByb21pc2U8dm9pZD5cbiAgICovXG4gIHZhciBjb21wYXJlID0gZnVuY3Rpb24oY29uZmlnLCBtYWNfa2V5X3Byb21pc2UsIGFycjEsIGFycjIpIHtcbiAgICBKb3NlLmFzc2VydChhcnIxIGluc3RhbmNlb2YgVWludDhBcnJheSwgXCJjb21wYXJlOiBpbnZhbGlkIGlucHV0XCIpO1xuICAgIEpvc2UuYXNzZXJ0KGFycjIgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBcImNvbXBhcmU6IGludmFsaWQgaW5wdXRcIik7XG5cbiAgICByZXR1cm4gbWFjX2tleV9wcm9taXNlLnRoZW4oZnVuY3Rpb24obWFjX2tleSkge1xuICAgICAgdmFyIGhhc2gxID0gSm9zZS5jcnlwdG8uc3VidGxlLnNpZ24oY29uZmlnLmF1dGguaWQsIG1hY19rZXksIGFycjEpO1xuICAgICAgdmFyIGhhc2gyID0gSm9zZS5jcnlwdG8uc3VidGxlLnNpZ24oY29uZmlnLmF1dGguaWQsIG1hY19rZXksIGFycjIpO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtoYXNoMSwgaGFzaDJdKS50aGVuKGZ1bmN0aW9uKGFsbCkge1xuICAgICAgICB2YXIgaGFzaDEgPSBuZXcgVWludDhBcnJheShhbGxbMF0pO1xuICAgICAgICB2YXIgaGFzaDIgPSBuZXcgVWludDhBcnJheShhbGxbMV0pO1xuICAgICAgICBpZiAoaGFzaDEubGVuZ3RoICE9IGhhc2gyLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXBhcmUgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFzaDFbaV0gIT0gaGFzaDJbaV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXBhcmUgZmFpbGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGl2Lmxlbmd0aCAhPSB0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbi5pdl9ieXRlcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChFcnJvcihcImRlY3J5cHRDaXBoZXJ0ZXh0OiBpbnZhbGlkIElWXCIpKTtcbiAgfVxuXG4gIHZhciBjb25maWcgPSB0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbjtcbiAgaWYgKGNvbmZpZy5hdXRoLmFlYWQpIHtcbiAgICB2YXIgZGVjID0ge1xuICAgICAgbmFtZTogY29uZmlnLmlkLm5hbWUsXG4gICAgICBpdjogaXYsXG4gICAgICBhZGRpdGlvbmFsRGF0YTogYWFkLFxuICAgICAgdGFnTGVuZ3RoOiBjb25maWcuYXV0aC50YWdfYnl0ZXMgKiA4XG4gICAgfTtcblxuICAgIHJldHVybiBjZWtfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNlaykge1xuICAgICAgdmFyIGJ1ZiA9IFV0aWxzLmFycmF5QnVmZmVyQ29uY2F0KGNpcGhlcl90ZXh0LCB0YWcpO1xuICAgICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KGRlYywgY2VrLCBidWYpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXlzID0gc3BsaXRLZXkoY29uZmlnLCBjZWtfcHJvbWlzZSwgW1wiZGVjcnlwdFwiXSk7XG4gICAgdmFyIG1hY19rZXlfcHJvbWlzZSA9IGtleXNbMF07XG4gICAgdmFyIGVuY19rZXlfcHJvbWlzZSA9IGtleXNbMV07XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgTUFDXG4gICAgdmFyIG1hY19wcm9taXNlID0gdHJ1bmNhdGVkTWFjKFxuICAgICAgY29uZmlnLFxuICAgICAgbWFjX2tleV9wcm9taXNlLFxuICAgICAgYWFkLFxuICAgICAgaXYsXG4gICAgICBjaXBoZXJfdGV4dCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2VuY19rZXlfcHJvbWlzZSwgbWFjX3Byb21pc2VdKS50aGVuKGZ1bmN0aW9uKGFsbCkge1xuICAgICAgdmFyIGVuY19rZXkgPSBhbGxbMF07XG4gICAgICB2YXIgbWFjID0gYWxsWzFdO1xuXG4gICAgICByZXR1cm4gY29tcGFyZShjb25maWcsIG1hY19rZXlfcHJvbWlzZSwgbmV3IFVpbnQ4QXJyYXkobWFjKSwgdGFnKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjID0ge1xuICAgICAgICAgIG5hbWU6IGNvbmZpZy5pZC5uYW1lLFxuICAgICAgICAgIGl2OiBpdlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmRlY3J5cHQoZGVjLCBlbmNfa2V5LCBjaXBoZXJfdGV4dCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKFwiZGVjcnlwdENpcGhlcnRleHQ6IE1BQyBmYWlsZWQuXCIpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNpZ25zIHBsYWluX3RleHQuXG4gKlxuICogQHBhcmFtIGFhZCAgICAgICAgIGpzb25cbiAqIEBwYXJhbSBwYXlsb2FkICAgICBTdHJpbmcgb3IganNvblxuICogQHBhcmFtIGtleV9wcm9taXNlIFByb21pc2U8Q3J5cHRvS2V5PlxuICogQHJldHVybiBQcm9taXNlPEFycmF5QnVmZmVyPlxuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24oYWFkLCBwYXlsb2FkLCBrZXlfcHJvbWlzZSkge1xuICB2YXIgY29uZmlnID0gdGhpcy5jb250ZW50X3NpZ247XG5cbiAgaWYgKGFhZC5hbGcpIHtcbiAgICBjb25maWcgPSBnZXRTaWduQ29uZmlnKGFhZC5hbGcpO1xuICB9XG5cbiAgLy8gRW5jcnlwdCB0aGUgcGxhaW4gdGV4dFxuICByZXR1cm4ga2V5X3Byb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLnNpZ24oY29uZmlnLmlkLCBrZXksIFV0aWxzLmFycmF5RnJvbVN0cmluZyhVdGlscy5CYXNlNjRVcmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGFhZCkpICsgJy4nICsgVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KHBheWxvYWQpKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgSldTLlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkICAgICBCYXNlNjRVcmwgZW5jb2RlZCBwYXlsb2FkXG4gKiBAcGFyYW0gYWFkICAgICAgICAgU3RyaW5nIEJhc2U2NFVybCBlbmNvZGVkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3RlY3RlZCBKV1MgaGVhZGVyXG4gKiBAcGFyYW0gc2lnbmF0dXJlICAgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBzaWduYXR1cmVcbiAqIEBwYXJhbSBrZXlfcHJvbWlzZSBQcm9taXNlPENyeXB0b0tleT5cbiAqIEBwYXJhbSBrZXlfaWQgICAgICB2YWx1ZSBvZiB0aGUga2lkIEpvc2VIZWFkZXIsIGl0J2xsIGJlIHBhc3NlZCBhcyBwYXJ0IG9mIHRoZSByZXN1bHQgdG8gdGhlIHJldHVybmVkIHByb21pc2VcbiAqIEByZXR1cm4gUHJvbWlzZTxqc29uPlxuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihhYWQsIHBheWxvYWQsIHNpZ25hdHVyZSwga2V5X3Byb21pc2UsIGtleV9pZCkge1xuICB2YXIgY29uZmlnID0gdGhpcy5jb250ZW50X3NpZ247XG5cbiAgcmV0dXJuIGtleV9wcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgY29uZmlnID0gZ2V0U2lnbkNvbmZpZyhnZXRKd2FOYW1lRm9yU2lnbktleShrZXkpKTtcbiAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLnZlcmlmeShjb25maWcuaWQsIGtleSwgc2lnbmF0dXJlLCBVdGlscy5hcnJheUZyb21TdHJpbmcoYWFkICsgXCIuXCIgKyBwYXlsb2FkKSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIHJldHVybiB7a2lkOiBrZXlfaWQsIHZlcmlmaWVkOiByZXN9O1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkpvc2UuV2ViQ3J5cHRvZ3JhcGhlci5rZXlJZCA9IGZ1bmN0aW9uKHJzYV9rZXkpIHtcbiAgcmV0dXJuIFV0aWxzLnNoYTI1Nihyc2Ffa2V5Lm4gKyBcIitcIiArIHJzYV9rZXkuZCk7XG59O1xuXG4vKipcbiAqIFNwbGl0cyBhIENFSyBpbnRvIHR3byBwaWVjZXM6IGEgTUFDIGtleSBhbmQgYW4gRU5DIGtleS5cbiAqXG4gKiBUaGlzIGNvZGUgaXMgc3RydWN0dXJlZCBhcm91bmQgdGhlIGZhY3QgdGhhdCB0aGUgY3J5cHRvIEFQSSBkb2VzIG5vdCBwcm92aWRlXG4gKiBhIHdheSB0byB2YWxpZGF0ZSB0cnVuY2F0ZWQgTUFDcy4gVGhlIE1BQyBrZXkgaXMgdGhlcmVmb3JlIGFsd2F5cyBpbXBvcnRlZCB0b1xuICogc2lnbiBkYXRhLlxuICpcbiAqIEBwYXJhbSBjb25maWcgKHVzZWQgZm9yIGtleSBsZW5ndGhzICYgYWxnb3JpdGhtcylcbiAqIEBwYXJhbSBjZWtfcHJvbWlzZSBQcm9taXNlPENyeXB0b0tleT4gIENFSyBrZXkgdG8gc3BsaXRcbiAqIEBwYXJhbSBwdXJwb3NlIEFycmF5PFN0cmluZz4gdXNhZ2VzIG9mIHRoZSBpbXBvcnRlZCBrZXlcbiAqIEByZXR1cm4gW1Byb21pc2U8bWFjIGtleT4sIFByb21pc2U8ZW5jIGtleT5dXG4gKi9cbnZhciBzcGxpdEtleSA9IGZ1bmN0aW9uKGNvbmZpZywgY2VrX3Byb21pc2UsIHB1cnBvc2UpIHtcbiAgLy8gV2UgbmVlZCB0byBzcGxpdCB0aGUgQ0VLIGtleSBpbnRvIGEgTUFDIGFuZCBFTkMga2V5c1xuICB2YXIgY2VrX2J5dGVzX3Byb21pc2UgPSBjZWtfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNlaykge1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwicmF3XCIsIGNlayk7XG4gIH0pO1xuICB2YXIgbWFjX2tleV9wcm9taXNlID0gY2VrX2J5dGVzX3Byb21pc2UudGhlbihmdW5jdGlvbihjZWtfYnl0ZXMpIHtcbiAgICBpZiAoY2VrX2J5dGVzLmJ5dGVMZW5ndGggKiA4ICE9IGNvbmZpZy5pZC5sZW5ndGggKyBjb25maWcuYXV0aC5rZXlfYnl0ZXMgKiA4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRXJyb3IoXCJlbmNyeXB0UGxhaW5UZXh0OiBpbmNvcnJlY3QgY2VrIGxlbmd0aFwiKSk7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IGNla19ieXRlcy5zbGljZSgwLCBjb25maWcuYXV0aC5rZXlfYnl0ZXMpO1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGJ5dGVzLCBjb25maWcuYXV0aC5pZCwgZmFsc2UsIFtcInNpZ25cIl0pO1xuICB9KTtcbiAgdmFyIGVuY19rZXlfcHJvbWlzZSA9IGNla19ieXRlc19wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2VrX2J5dGVzKSB7XG4gICAgaWYgKGNla19ieXRlcy5ieXRlTGVuZ3RoICogOCAhPSBjb25maWcuaWQubGVuZ3RoICsgY29uZmlnLmF1dGgua2V5X2J5dGVzICogOCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKFwiZW5jcnlwdFBsYWluVGV4dDogaW5jb3JyZWN0IGNlayBsZW5ndGhcIikpO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSBjZWtfYnl0ZXMuc2xpY2UoY29uZmlnLmF1dGgua2V5X2J5dGVzKTtcbiAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBieXRlcywgY29uZmlnLmlkLCBmYWxzZSwgcHVycG9zZSk7XG4gIH0pO1xuICByZXR1cm4gW21hY19rZXlfcHJvbWlzZSwgZW5jX2tleV9wcm9taXNlXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIEpvc2Ugd2ViIGFsZ29yaXRobXMgaW50byBkYXRhIHdoaWNoIGlzXG4gKiB1c2VmdWwgZm9yIHRoZSBXZWIgQ3J5cHRvIEFQSS5cbiAqXG4gKiBsZW5ndGggPSBpbiBiaXRzXG4gKiBieXRlcyA9IGluIGJ5dGVzXG4gKi9cbnZhciBnZXRDcnlwdG9Db25maWcgPSBmdW5jdGlvbihhbGcpIHtcbiAgc3dpdGNoIChhbGcpIHtcbiAgICAvLyBLZXkgZW5jcnlwdGlvblxuICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiUlNBLU9BRVBcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQS1PQUVQXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0xXCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiUlNBLU9BRVAtMjU2XCI6XG4gICAgICAvLyByZXR1cm4ge1xuICAgICAgLy8gICBqd2VfbmFtZTogXCJSU0EtT0FFUC0yNTZcIixcbiAgICAgIC8vICAgaWQ6IHtuYW1lOiBcIlJTQS1PQUVQLTI1NlwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gT1JJR0lOQUwgU1FVQVJFIEhFQURFUiBDT05GSUdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcIlJTQS1PQUVQLTI1NlwiLFxuICAgICAgICBpZDoge25hbWU6IFwiUlNBLU9BRVBcIiwgaGFzaDoge25hbWU6IFwiU0hBLTI1NlwifX1cbiAgICAgIH07XG4gICAgY2FzZSBcIkExMjhLV1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiQTEyOEtXXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJBRVMtS1dcIiwgbGVuZ3RoOiAxMjh9XG4gICAgICB9O1xuICAgIGNhc2UgXCJBMjU2S1dcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcIkEyNTZLV1wiLFxuICAgICAgICBpZDoge25hbWU6IFwiQUVTLUtXXCIsIGxlbmd0aDogMjU2fVxuICAgICAgfTtcbiAgICBjYXNlIFwiZGlyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJkaXJcIlxuICAgICAgfTtcblxuICAgIC8vIENvbnRlbnQgZW5jcnlwdGlvblxuICAgIGNhc2UgXCJBMTI4Q0JDLUhTMjU2XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJBMTI4Q0JDLUhTMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJBRVMtQ0JDXCIsIGxlbmd0aDogMTI4fSxcbiAgICAgICAgaXZfYnl0ZXM6IDE2LFxuICAgICAgICBzcGVjaWZpY19jZWtfYnl0ZXM6IDMyLFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAga2V5X2J5dGVzOiAxNixcbiAgICAgICAgICBpZDoge25hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fSxcbiAgICAgICAgICB0cnVuY2F0ZWRfYnl0ZXM6IDE2XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgY2FzZSBcIkEyNTZDQkMtSFM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcIkEyNTZDQkMtSFM1MTJcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkFFUy1DQkNcIiwgbGVuZ3RoOiAyNTZ9LFxuICAgICAgICBpdl9ieXRlczogMTYsXG4gICAgICAgIHNwZWNpZmljX2Nla19ieXRlczogNjQsXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBrZXlfYnl0ZXM6IDMyLFxuICAgICAgICAgIGlkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS01MTJcIn19LFxuICAgICAgICAgIHRydW5jYXRlZF9ieXRlczogMzJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwiQTEyOEdDTVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiQTEyOEdDTVwiLFxuICAgICAgICBpZDoge25hbWU6IFwiQUVTLUdDTVwiLCBsZW5ndGg6IDEyOH0sXG4gICAgICAgIGl2X2J5dGVzOiAxMixcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIGFlYWQ6IHRydWUsXG4gICAgICAgICAgdGFnX2J5dGVzOiAxNlxuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJBMjU2R0NNXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJBMjU2R0NNXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJBRVMtR0NNXCIsIGxlbmd0aDogMjU2fSxcbiAgICAgICAgaXZfYnl0ZXM6IDEyLFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgYWVhZDogdHJ1ZSxcbiAgICAgICAgICB0YWdfYnl0ZXM6IDE2XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYSB0cnVuY2F0ZWQgTUFDLlxuICpcbiAqIEBwYXJhbSBjb25maWcgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBtYWNfa2V5X3Byb21pc2UgICAgIFByb21pc2U8Q3J5cHRvS2V5PiAgbWFjIGtleVxuICogQHBhcmFtIGFhZCAgICAgICAgICAgICAgICAgVWludDhBcnJheVxuICogQHBhcmFtIGl2ICAgICAgICAgICAgICAgICAgVWludDhBcnJheVxuICogQHBhcmFtIGNpcGhlcl90ZXh0ICAgICAgICAgVWludDhBcnJheVxuICogQHJldHVybiBQcm9taXNlPGJ1ZmZlcj4gICAgdHJ1bmNhdGVkIE1BQ1xuICovXG52YXIgdHJ1bmNhdGVkTWFjID0gZnVuY3Rpb24oY29uZmlnLCBtYWNfa2V5X3Byb21pc2UsIGFhZCwgaXYsIGNpcGhlcl90ZXh0KSB7XG4gIHJldHVybiBtYWNfa2V5X3Byb21pc2UudGhlbihmdW5jdGlvbihtYWNfa2V5KSB7XG4gICAgdmFyIGFsID0gbmV3IFVpbnQ4QXJyYXkoVXRpbHMuYXJyYXlGcm9tSW50MzIoYWFkLmxlbmd0aCAqIDgpKTtcbiAgICB2YXIgYWxfZnVsbCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGFsX2Z1bGwuc2V0KGFsLCA0KTtcbiAgICB2YXIgYnVmID0gVXRpbHMuYXJyYXlCdWZmZXJDb25jYXQoYWFkLCBpdiwgY2lwaGVyX3RleHQsIGFsX2Z1bGwpO1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuc2lnbihjb25maWcuYXV0aC5pZCwgbWFjX2tleSwgYnVmKS50aGVuKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgY29uZmlnLmF1dGgudHJ1bmNhdGVkX2J5dGVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBKb3NlIHdlYiBhbGdvcml0aG1zIGludG8gZGF0YSB3aGljaCBpc1xuICogdXNlZnVsIGZvciB0aGUgV2ViIENyeXB0byBBUEkuXG4gKi9cbnZhciBnZXRTaWduQ29uZmlnID0gZnVuY3Rpb24oYWxnKSB7XG5cbiAgc3dpdGNoIChhbGcpIHtcbiAgICBjYXNlIFwiUlMyNTZcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlJTMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiUlMzODRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlJTMzg0XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMzg0XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiUlM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlJTNTEyXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtNTEyXCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiUFMyNTZcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlBTMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0EtUFNTXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn0sIHNhbHRMZW5ndGg6IDIwfVxuICAgICAgfTtcbiAgICBjYXNlIFwiUFMzODRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlBTMzg0XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0EtUFNTXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0zODRcIn0sIHNhbHRMZW5ndGg6IDIwfVxuICAgICAgfTtcbiAgICBjYXNlIFwiUFM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIlBTNTEyXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0EtUFNTXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS01MTJcIn0sIHNhbHRMZW5ndGg6IDIwfVxuICAgICAgfTtcbiAgICBjYXNlIFwiSFMyNTZcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIkhTMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJIUzM4NFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiSFMzODRcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkhNQUNcIiwgaGFzaDoge25hbWU6IFwiU0hBLTM4NFwifX1cbiAgICAgIH07XG4gICAgY2FzZSBcIkhTNTEyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2FfbmFtZTogXCJIUzUxMlwiLFxuICAgICAgICBpZDoge25hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7bmFtZTogXCJTSEEtNTEyXCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiRVMyNTZcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIkVTMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJFQ0RTQVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiRVMzODRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIkVTMzg0XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJFQ0RTQVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMzg0XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiRVM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIkVTNTEyXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJFQ0RTQVwiLCBoYXNoOiB7bmFtZTogXCJTSEEtNTEyXCJ9fVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEpXQSBuYW1lIGZvciBhIGdpdmVuIENyeXB0b0tleVxuICogQHBhcmFtIGtleSBDcnlwdG9LZXlcbiAqL1xudmFyIGdldEp3YU5hbWVGb3JTaWduS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG5cbiAgdmFyIHJ2ID0gXCJcIixcbiAgICBzaWduX2FsZ28gPSBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgaGFzaF9hbGdvID0ga2V5LmFsZ29yaXRobS5oYXNoLm5hbWU7XG5cbiAgaWYoc2lnbl9hbGdvID09IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIikge1xuICAgIHJ2ID0gXCJSXCI7XG4gIH0gZWxzZSBpZihzaWduX2FsZ28gPT0gXCJSU0EtUFNTXCIpIHtcbiAgICBydiA9IFwiUFwiO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ24vdmVyaWZ5IGFsZ29yaXRobSBcIiArIHNpZ25fYWxnbyk7XG4gIH1cblxuICBpZihoYXNoX2FsZ28uaW5kZXhPZihcIlNIQS1cIikgPT09IDApIHtcbiAgICBydiArPSBcIlNcIjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBoYXNoIGFsZ29yaXRobSBcIiArIHNpZ25fYWxnbyk7XG4gIH1cblxuICBydiArPSBoYXNoX2FsZ28uc3Vic3RyaW5nKDQpO1xuXG4gIHJldHVybiBydjtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBrZXkgdXNhZ2UgZnJvbSBhbGdvcml0aG0ncyBuYW1lXG4gKlxuICogQHBhcmFtIGFsZyBTdHJpbmcgYWxnb3JpdGhtIG5hbWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG52YXIgZ2V0S2V5VXNhZ2VCeUFsZyA9IGZ1bmN0aW9uKGFsZykge1xuXG4gIHN3aXRjaCAoYWxnKSB7XG4gICAgLy8gc2lnbmF0dXJlXG4gICAgY2FzZSBcIlJTMjU2XCI6XG4gICAgY2FzZSBcIlJTMzg0XCI6XG4gICAgY2FzZSBcIlJTNTEyXCI6XG4gICAgY2FzZSBcIlBTMjU2XCI6XG4gICAgY2FzZSBcIlBTMzg0XCI6XG4gICAgY2FzZSBcIlBTNTEyXCI6XG4gICAgY2FzZSBcIkhTMjU2XCI6XG4gICAgY2FzZSBcIkhTMzg0XCI6XG4gICAgY2FzZSBcIkhTNTEyXCI6XG4gICAgY2FzZSBcIkVTMjU2XCI6XG4gICAgY2FzZSBcIkVTMzg0XCI6XG4gICAgY2FzZSBcIkVTNTEyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IFwidmVyaWZ5XCIsXG4gICAgICAgIHByaXZhdGVLZXk6IFwic2lnblwiXG4gICAgICB9O1xuICAgIC8vIGtleSBlbmNyeXB0aW9uXG4gICAgY2FzZSBcIlJTQS1PQUVQXCI6XG4gICAgY2FzZSBcIlJTQS1PQUVQLTI1NlwiOlxuICAgIGNhc2UgXCJBMTI4S1dcIjpcbiAgICBjYXNlIFwiQTI1NktXXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IFwid3JhcEtleVwiLFxuICAgICAgICBwcml2YXRlS2V5OiBcInVud3JhcEtleVwiXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICB9XG59O1xuXG4vLyBWaXNhLXNwZWNpZmljXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkNyeXB0b2dyYXBoZXI7XG5cbi8qLVxuICogQ29weXJpZ2h0IDIwMTQgU3F1YXJlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuSm9zZS5VdGlscyA9IHt9O1xudmFyIFV0aWxzID0ge307XG5cbi8qKlxuICogQ29udmVydHMgdGhlIG91dHB1dCBmcm9tIGBvcGVuc3NsIHg1MDkgLXRleHRgIG9yIGBvcGVuc3NsIHJzYSAtdGV4dGAgaW50byBhXG4gKiBDcnlwdG9LZXkgd2hpY2ggY2FuIHRoZW4gYmUgdXNlZCB3aXRoIFJTQS1PQUVQLiBBbHNvIGFjY2VwdHMgKGFuZCB2YWxpZGF0ZXMpXG4gKiBKV0sga2V5cy5cbiAqXG4gKiBUT0RPOiB0aGlzIGNvZGUgcHJvYmFibHkgYmVsb25ncyBpbiB0aGUgd2ViY3J5cHRvZ3JhcGhlci5cbiAqXG4gKiBAcGFyYW0gcnNhX2tleSAgcHVibGljIFJTQSBrZXkgaW4ganNvbiBmb3JtYXQuIFBhcmFtZXRlcnMgY2FuIGJlIGJhc2U2NFxuICogICAgICAgICAgICAgICAgIGVuY29kZWQsIHN0cmluZ3Mgb3IgbnVtYmVyIChmb3IgJ2UnKS5cbiAqIEBwYXJhbSBhbGcgICAgICBTdHJpbmcsIG5hbWUgb2YgdGhlIGFsZ29yaXRobVxuICogQHJldHVybiBQcm9taXNlPENyeXB0b0tleT5cbiAqL1xuSm9zZS5VdGlscy5pbXBvcnRSc2FQdWJsaWNLZXkgPSBmdW5jdGlvbihyc2Ffa2V5LCBhbGcpIHtcbiAgdmFyIGp3aztcbiAgdmFyIGNvbmZpZztcbiAgdmFyIHVzYWdlID0gZ2V0S2V5VXNhZ2VCeUFsZyhhbGcpO1xuXG4gIGlmICh1c2FnZS5wdWJsaWNLZXkgPT0gXCJ3cmFwS2V5XCIpIHtcbiAgICBpZiAoIXJzYV9rZXkuYWxnKSB7XG4gICAgICByc2Ffa2V5LmFsZyA9IGFsZztcbiAgICB9XG4gICAgandrID0gVXRpbHMuY29udmVydFJzYUtleShyc2Ffa2V5LCBbXCJuXCIsIFwiZVwiXSk7XG4gICAgY29uZmlnID0gZ2V0Q3J5cHRvQ29uZmlnKGFsZyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJrID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiByc2Ffa2V5KSB7XG4gICAgICBpZiAocnNhX2tleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBya1tuYW1lXSA9IHJzYV9rZXlbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyay5hbGcgJiYgYWxnKSB7XG4gICAgICByay5hbGcgPSBhbGc7XG4gICAgfVxuICAgIGNvbmZpZyA9IGdldFNpZ25Db25maWcocmsuYWxnKTtcbiAgICBqd2sgPSBVdGlscy5jb252ZXJ0UnNhS2V5KHJrLCBbXCJuXCIsIFwiZVwiXSk7XG4gICAgandrLmV4dCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJqd2tcIiwgandrLCBjb25maWcuaWQsIGZhbHNlLCBbdXNhZ2UucHVibGljS2V5XSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBvdXRwdXQgZnJvbSBgb3BlbnNzbCB4NTA5IC10ZXh0YCBvciBgb3BlbnNzbCByc2EgLXRleHRgIGludG8gYVxuICogQ3J5cHRvS2V5IHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgd2l0aCBSU0EtT0FFUCBhbmQgUlNBLiBBbHNvIGFjY2VwdHMgKGFuZCB2YWxpZGF0ZXMpXG4gKiBKV0sga2V5cy5cbiAqXG4gKiBUT0RPOiB0aGlzIGNvZGUgcHJvYmFibHkgYmVsb25ncyBpbiB0aGUgd2ViY3J5cHRvZ3JhcGhlci5cbiAqXG4gKiBAcGFyYW0gcnNhX2tleSAgcHJpdmF0ZSBSU0Ega2V5IGluIGpzb24gZm9ybWF0LiBQYXJhbWV0ZXJzIGNhbiBiZSBiYXNlNjRcbiAqICAgICAgICAgICAgICAgICBlbmNvZGVkLCBzdHJpbmdzIG9yIG51bWJlciAoZm9yICdlJykuXG4gKiBAcGFyYW0gYWxnICAgICAgU3RyaW5nLCBuYW1lIG9mIHRoZSBhbGdvcml0aG1cbiAqIEByZXR1cm4gUHJvbWlzZTxDcnlwdG9LZXk+XG4gKi9cbkpvc2UuVXRpbHMuaW1wb3J0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYV9rZXksIGFsZykge1xuICB2YXIgandrO1xuICB2YXIgY29uZmlnO1xuICB2YXIgdXNhZ2UgPSBnZXRLZXlVc2FnZUJ5QWxnKGFsZyk7XG5cbiAgaWYgKHVzYWdlLnByaXZhdGVLZXkgPT0gXCJ1bndyYXBLZXlcIikge1xuICAgIGlmICghcnNhX2tleS5hbGcpIHtcbiAgICAgIHJzYV9rZXkuYWxnID0gYWxnO1xuICAgIH1cbiAgICBqd2sgPSBVdGlscy5jb252ZXJ0UnNhS2V5KHJzYV9rZXksIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdKTtcbiAgICBjb25maWcgPSBnZXRDcnlwdG9Db25maWcoYWxnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmsgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJzYV9rZXkpIHtcbiAgICAgIGlmIChyc2Ffa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJrW25hbWVdID0gcnNhX2tleVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnID0gZ2V0U2lnbkNvbmZpZyhhbGcpO1xuICAgIGlmICghcmsuYWxnICYmIGFsZykge1xuICAgICAgcmsuYWxnID0gYWxnO1xuICAgIH1cbiAgICBqd2sgPSBVdGlscy5jb252ZXJ0UnNhS2V5KHJrLCBbXCJuXCIsIFwiZVwiLCBcImRcIiwgXCJwXCIsIFwicVwiLCBcImRwXCIsIFwiZHFcIiwgXCJxaVwiXSk7XG4gICAgandrLmV4dCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJqd2tcIiwgandrLCBjb25maWcuaWQsIGZhbHNlLCBbdXNhZ2UucHJpdmF0ZUtleV0pO1xufTtcblxuLy8gUHJpdmF0ZSBmdW5jdGlvbnNcblxuVXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuICgodHlwZW9mKHN0cikgPT0gXCJzdHJpbmdcIikgfHwgKHN0ciBpbnN0YW5jZW9mIFN0cmluZykpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheWlzaCAoYW4gYXJyYXksIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkpXG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvciBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGFyciAgYXJyYXlpc2hcbiAqIEByZXR1cm4gYXJyYXkgb3IgVWludDhBcnJheVxuICovXG5VdGlscy5hcnJheWlzaCA9IGZ1bmN0aW9uKGFycikge1xuICBpZiAoYXJyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICBpZiAoYXJyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyKTtcbiAgfVxuICBKb3NlLmFzc2VydChmYWxzZSwgXCJhcnJheWlzaDogaW52YWxpZCBpbnB1dFwiKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIFJTQSBrZXkgY29udGFpbnMgYWxsIHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzLiBBbHNvIGNoZWNrcyB0aGVpclxuICogdHlwZXMuIENvbnZlcnRzIGhleCBlbmNvZGVkIHN0cmluZ3MgKG9yIG51bWJlcnMpIHRvIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gcnNhX2tleSAgICAgUlNBIGtleSBpbiBqc29uIGZvcm1hdC4gUGFyYW1ldGVycyBjYW4gYmUgYmFzZTY0IGVuY29kZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncyBvciBudW1iZXIgKGZvciAnZScpLlxuICogQHBhcmFtIHBhcmFtZXRlcnMgIGFycmF5PHN0cmluZz5cbiAqIEByZXR1cm4ganNvblxuICovXG5VdGlscy5jb252ZXJ0UnNhS2V5ID0gZnVuY3Rpb24ocnNhX2tleSwgcGFyYW1ldGVycykge1xuICB2YXIgciA9IHt9O1xuICB2YXIgYWxnO1xuXG4gIC8vIENoZWNrIHRoYXQgd2UgaGF2ZSBhbGwgdGhlIHBhcmFtZXRlcnNcbiAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgcGFyYW1ldGVycy5tYXAoZnVuY3Rpb24ocCl7aWYgKHR5cGVvZihyc2Ffa2V5W3BdKSA9PSBcInVuZGVmaW5lZFwiKSB7IG1pc3NpbmcucHVzaChwKTsgfX0pO1xuXG4gIGlmIChtaXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICBKb3NlLmFzc2VydChmYWxzZSwgXCJjb252ZXJ0UnNhS2V5OiBXYXMgZXhwZWN0aW5nIFwiICsgbWlzc2luZy5qb2luKCkpO1xuICB9XG5cbiAgLy8ga3R5IGlzIGVpdGhlciBtaXNzaW5nIG9yIGlzIHNldCB0byBcIlJTQVwiXG4gIGlmICh0eXBlb2YocnNhX2tleS5rdHkpICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBKb3NlLmFzc2VydChyc2Ffa2V5Lmt0eSA9PSBcIlJTQVwiLCBcImNvbnZlcnRSc2FLZXk6IGV4cGVjdGluZyByc2Ffa2V5WydrdHknXSB0byBiZSAnUlNBJ1wiKTtcbiAgfVxuICByLmt0eSA9IFwiUlNBXCI7XG5cbiAgdHJ5IHtcbiAgICBnZXRTaWduQ29uZmlnKHJzYV9rZXkuYWxnKTtcbiAgICBhbGcgPSByc2Ffa2V5LmFsZztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGdldENyeXB0b0NvbmZpZyhyc2Ffa2V5LmFsZyk7XG4gICAgICBhbGcgPSByc2Ffa2V5LmFsZztcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgSm9zZS5hc3NlcnQoYWxnLCBcImNvbnZlcnRSc2FLZXk6IGV4cGVjdGluZyByc2Ffa2V5WydhbGcnXSB0byBoYXZlIGEgdmFsaWQgdmFsdWVcIik7XG4gICAgfVxuICB9XG4gIHIuYWxnID0gYWxnO1xuXG4gIC8vIG5vdGU6IHdlIHB1bnQgb24gY2hlY2tpbmcga2V5X29wc1xuXG4gIHZhciBpbnRGcm9tSGV4ID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBwYXJzZUludChlLCAxNik7XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGFyYW1ldGVyc1tpXTtcbiAgICB2YXIgdiA9IHJzYV9rZXlbcF07XG4gICAgaWYgKHAgPT0gXCJlXCIpIHtcbiAgICAgIGlmICh0eXBlb2YodikgPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2ID0gVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KFV0aWxzLnN0cmlwTGVhZGluZ1plcm9zKFV0aWxzLmFycmF5RnJvbUludDMyKHYpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvXihbMC05YS1mQS1GXXsyfTopK1swLTlhLWZBLUZdezJ9JC8udGVzdCh2KSkge1xuICAgICAgdmFyIGFyciA9IHYuc3BsaXQoXCI6XCIpLm1hcChpbnRGcm9tSGV4KTtcbiAgICAgIHYgPSBVdGlscy5CYXNlNjRVcmwuZW5jb2RlQXJyYXkoVXRpbHMuc3RyaXBMZWFkaW5nWmVyb3MoYXJyKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YodikgIT0gXCJzdHJpbmdcIikge1xuICAgICAgSm9zZS5hc3NlcnQoZmFsc2UsIFwiY29udmVydFJzYUtleTogZXhwZWN0aW5nIHJzYV9rZXlbJ1wiICsgcCArIFwiJ10gdG8gYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHJbcF0gPSB2O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYXNjaWkgY29kZXMuXG4gKlxuICogQHBhcmFtIHN0ciAgYXNjaWkgc3RyaW5nXG4gKiBAcmV0dXJuIFVpbnQ4QXJyYXlcbiAqL1xuVXRpbHMuYXJyYXlGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIEpvc2UuYXNzZXJ0KFV0aWxzLmlzU3RyaW5nKHN0ciksIFwiYXJyYXlGcm9tU3RyaW5nOiBpbnZhbGlkIGlucHV0XCIpO1xuICB2YXIgYXJyID0gc3RyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB1dGYtOCBjb2Rlcy5cbiAqXG4qIEBwYXJhbSBzdHIgIHV0Zi04IHN0cmluZ1xuICogQHJldHVybiBVaW50OEFycmF5XG4gKi9cblV0aWxzLmFycmF5RnJvbVV0ZjhTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgSm9zZS5hc3NlcnQoVXRpbHMuaXNTdHJpbmcoc3RyKSwgXCJhcnJheUZyb21VdGY4U3RyaW5nOiBpbnZhbGlkIGlucHV0XCIpO1xuICAvLyBqYXZhc2NyaXB0IHJlcHJlc2VudHMgc3RyaW5ncyBhcyB1dGYtMTYuIEpvc2UgaW1wb3NlcyB0aGUgdXNlIG9mXG4gIC8vIHV0Zi04LCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgZnJvbSBvbmUgcmVwcmVzZW50YXRpb24gdG8gdGhlIG90aGVyLlxuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIHJldHVybiBVdGlscy5hcnJheUZyb21TdHJpbmcoc3RyKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgYXNjaWkgYnl0ZXMgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJyICBhcnJheWlzaFxuICogQHJldHVybiBhc2NpaSBzdHJpbmdcbiAqL1xuVXRpbHMuc3RyaW5nRnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIGFyciA9IFV0aWxzLmFycmF5aXNoKGFycik7XG4gIHZhciByID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycltpXSk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgYXNjaWkgYnl0ZXMgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJyICBBcnJheUJ1ZmZlclxuICogQHJldHVybiBhc2NpaSBzdHJpbmdcbiAqL1xuVXRpbHMudXRmOFN0cmluZ0Zyb21BcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICBKb3NlLmFzc2VydChhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJ1dGY4U3RyaW5nRnJvbUFycmF5OiBpbnZhbGlkIGlucHV0XCIpO1xuXG4gIC8vIGphdmFzY3JpcHQgcmVwcmVzZW50cyBzdHJpbmdzIGFzIHV0Zi0xNi4gSm9zZSBpbXBvc2VzIHRoZSB1c2Ugb2ZcbiAgLy8gdXRmLTgsIHNvIHdlIG5lZWQgdG8gY29udmVydCBmcm9tIG9uZSByZXByZXNlbnRhdGlvbiB0byB0aGUgb3RoZXIuXG4gIHZhciByID0gVXRpbHMuc3RyaW5nRnJvbUFycmF5KGFycik7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHIpKTtcbn07XG5cbi8qKlxuICogU3RyaXBzIGxlYWRpbmcgemVybyBpbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gYXJyICBhcnJheWlzaFxuICogQHJldHVybiBhcnJheVxuICovXG5VdGlscy5zdHJpcExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uKGFycikge1xuICBpZiAoYXJyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBhcnIgPSBuZXcgVWludDhBcnJheShhcnIpO1xuICB9XG4gIHZhciBpc19sZWFkaW5nX3plcm8gPSB0cnVlO1xuICB2YXIgciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc19sZWFkaW5nX3plcm8gJiYgYXJyW2ldID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaXNfbGVhZGluZ196ZXJvID0gZmFsc2U7XG4gICAgci5wdXNoKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIGludG8gYW4gYXJyYXkgb2YgNCBieXRlcyAoYmlnIGVuZGlhbikuXG4gKlxuICogQHBhcmFtIGkgIG51bWJlclxuICogQHJldHVybiBBcnJheUJ1ZmZlclxuICovXG5VdGlscy5hcnJheUZyb21JbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgSm9zZS5hc3NlcnQodHlwZW9mKGkpID09IFwibnVtYmVyXCIsIFwiYXJyYXlGcm9tSW50MzI6IGludmFsaWQgaW5wdXRcIik7XG4gIEpvc2UuYXNzZXJ0KGkgPT0gaSB8IDAsIFwiYXJyYXlGcm9tSW50MzI6IG91dCBvZiByYW5nZVwiKTtcblxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFtpXSkuYnVmZmVyKTtcbiAgdmFyIHIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICByW2pdID0gYnVmWzMgLSBqXTtcbiAgfVxuICByZXR1cm4gci5idWZmZXI7XG59O1xuXG4vKipcbiAqIENvbmNhdGVuYXRlcyBhcnJheWlzaGVzLlxuICpcbiAqIEBwYXJhbSBhcmd1bWVudHMgdHdvIG9yIG1vcmUgYXJyYXlpc2hlc1xuICogQHJldHVybiBVaW50OEFycmF5XG4gKi9cblV0aWxzLmFycmF5QnVmZmVyQ29uY2F0ID0gZnVuY3Rpb24oLyogLi4uICovKSB7XG4gIC8vIENvbXB1dGUgdG90YWwgc2l6ZVxuICB2YXIgYXJncyA9IFtdO1xuICB2YXIgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChVdGlscy5hcnJheWlzaChhcmd1bWVudHNbaV0pKTtcbiAgICB0b3RhbCArPSBhcmdzW2ldLmxlbmd0aDtcbiAgfVxuICB2YXIgciA9IG5ldyBVaW50OEFycmF5KHRvdGFsKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZ3NbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJbb2Zmc2V0KytdID0gYXJnc1tpXVtqXTtcbiAgICB9XG4gIH1cbiAgSm9zZS5hc3NlcnQob2Zmc2V0ID09IHRvdGFsLCBcImFycmF5QnVmZmVyQ29uY2F0OiB1bmV4cGVjdGVkIG9mZnNldFwiKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5VdGlscy5CYXNlNjRVcmwgPSB7fTtcblxuLyoqXG4gKiBCYXNlNjRVcmwgZW5jb2RlcyBhIHN0cmluZyAobm8gdHJhaWxpbmcgJz0nKVxuICpcbiAqIEBwYXJhbSBzdHIgIHN0cmluZ1xuICogQHJldHVybiBzdHJpbmdcbiAqL1xuVXRpbHMuQmFzZTY0VXJsLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICBKb3NlLmFzc2VydChVdGlscy5pc1N0cmluZyhzdHIpLCBcIkJhc2U2NFVybC5lbmNvZGU6IGludmFsaWQgaW5wdXRcIik7XG4gIHJldHVybiBidG9hKHN0cilcbiAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpXG4gICAgLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xufTtcblxuLyoqXG4gKiBCYXNlNjRVcmwgZW5jb2RlcyBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSBhcnIgYXJyYXkgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cblV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gVXRpbHMuQmFzZTY0VXJsLmVuY29kZShVdGlscy5zdHJpbmdGcm9tQXJyYXkoYXJyKSk7XG59O1xuXG4vKipcbiAqIEJhc2U2NFVybCBkZWNvZGVzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHN0ciAgc3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5VdGlscy5CYXNlNjRVcmwuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIEpvc2UuYXNzZXJ0KFV0aWxzLmlzU3RyaW5nKHN0ciksIFwiQmFzZTY0VXJsLmRlY29kZTogaW52YWxpZCBpbnB1dFwiKTtcbiAgLy8gYXRvYiBpcyBuaWNlIGFuZCBpZ25vcmVzIG1pc3NpbmcgJz0nXG4gIHJldHVybiBhdG9iKHN0ci5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSk7XG59O1xuXG5VdGlscy5CYXNlNjRVcmwuZGVjb2RlQXJyYXkgPSBmdW5jdGlvbihzdHIpIHtcbiAgSm9zZS5hc3NlcnQoVXRpbHMuaXNTdHJpbmcoc3RyKSwgXCJCYXNlNjRVcmwuZGVjb2RlQXJyYXk6IGludmFsaWQgaW5wdXRcIik7XG4gIHJldHVybiBVdGlscy5hcnJheUZyb21TdHJpbmcoVXRpbHMuQmFzZTY0VXJsLmRlY29kZShzdHIpKTtcbn07XG5cblV0aWxzLnNoYTI1NiA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBCcm93c2VyIGRvY3MgaW5kaWNhdGUgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBjcnlwdG8uc3VidGxlLmRpZ2VzdCB0byBiZSBhXG4gIC8vIERPTVN0cmluZy4gVGhpcyB3YXMgaW5pdGlhbGx5IGltcGxlbWVudGVkIGFzIGFuIG9iamVjdCBhbmQgY29udGludWVzIHRvIGJlXG4gIC8vIHN1cHBvcnRlZCwgc28gd2UgZmF2b3IgdGhlIG9sZGVyIGZvcm0gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmRpZ2VzdCh7bmFtZTogXCJTSEEtMjU2XCJ9LCBVdGlscy5hcnJheUZyb21TdHJpbmcoc3RyKSkudGhlbihmdW5jdGlvbihoYXNoKSB7XG4gICAgcmV0dXJuIFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShoYXNoKTtcbiAgfSk7XG59O1xuXG5VdGlscy5pc0NyeXB0b0tleSA9IGZ1bmN0aW9uKHJzYV9rZXkpIHtcbiAgLy8gU29tZSBicm93c2VycyBkb24ndCBleHBvc2UgdGhlIENyeXB0b0tleSBhcyBhbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZS5cbiAgaWYgKHJzYV9rZXkuY29uc3RydWN0b3IubmFtZSA9PSAnQ3J5cHRvS2V5Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW4gdGhlIHByZXNlbmNlIG9mIG1pbmlmaWVycywgcmVseWluZyBvbiBjbGFzcyBuYW1lcyBjYW4gYmUgcHJvYmxlbWF0aWMsXG4gIC8vIHNvIGxldCdzIGFsc28gYWxsb3cgb2JqZWN0cyB0aGF0IGhhdmUgYW4gJ2FsZ29yaXRobScgcHJvcGVydHkuXG4gIGlmIChyc2Ffa2V5Lmhhc093blByb3BlcnR5KCdhbGdvcml0aG0nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcblxuXG4vKi1cbiAqIENvcHlyaWdodCAyMDE0IFNxdWFyZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogSGFuZGxlcyBlbmNyeXB0aW9uLlxuICpcbiAqIEBwYXJhbSBjcnlwdG9ncmFwaGVyICBhbiBpbnN0YW5jZSBvZiBXZWJDcnlwdG9ncmFwaGVyIChvciBlcXVpdmFsZW50KS5cbiAqIEBwYXJhbSBrZXlfcHJvbWlzZSAgICBQcm9taXNlPENyeXB0b0tleT4sIGVpdGhlciBSU0Egb3Igc2hhcmVkIGtleVxuICovXG5Kb3NlSldFLkVuY3J5cHRlciA9IGZ1bmN0aW9uKGNyeXB0b2dyYXBoZXIsIGtleV9wcm9taXNlKSB7XG4gIHRoaXMuY3J5cHRvZ3JhcGhlciA9IGNyeXB0b2dyYXBoZXI7XG4gIHRoaXMua2V5X3Byb21pc2UgPSBrZXlfcHJvbWlzZTtcbiAgdGhpcy51c2VySGVhZGVycyA9IHt9O1xufTtcblxuLyoqXG4gKiBBZGRzIGEga2V5L3ZhbHVlIHBhaXIgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgaGVhZGVyLlxuICpcbiAqIFRoZSBkYXRhIGxpdmVzIGluIHBsYWludGV4dCAoYW4gYXR0YWNrZXIgY2FuIHJlYWQgdGhlIGhlYWRlcikgYnV0IGlzIHRhbXBlclxuICogcHJvb2YgKGFuIGF0dGFja2VyIGNhbm5vdCBtb2RpZnkgdGhlIGhlYWRlcikuXG4gKlxuICogTm90ZTogc29tZSBoZWFkZXJzIGhhdmUgc2VtYW50aWMgaW1wbGljYXRpb25zLiBFLmcuIGlmIHlvdSBzZXQgdGhlIFwiemlwXCJcbiAqIGhlYWRlciwgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgY29tcHJlc3NpbmcgcGxhaW5fdGV4dCBiZWZvcmVcbiAqIGNhbGxpbmcgZW5jcnlwdCgpLlxuICpcbiAqIEBwYXJhbSBrICBTdHJpbmdcbiAqIEBwYXJhbSB2ICBTdHJpbmdcbiAqL1xuSm9zZUpXRS5FbmNyeXB0ZXIucHJvdG90eXBlLmFkZEhlYWRlciA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgdGhpcy51c2VySGVhZGVyc1trXSA9IHY7XG59O1xuXG4vKipcbiAqXG4gKiBWaXNhLWN1c3RvbVxuICogcmV0dXJucyB0aGUgaGVhZGVyIHZhbHVlXG4gKiBcbiAqIEBwYXJhbSBrICBTdHJpbmdcbiAqL1xuSm9zZUpXRS5FbmNyeXB0ZXIucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuIHRoaXMudXNlckhlYWRlcnNba107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGVuY3J5cHRpb24uXG4gKlxuICogQHBhcmFtIHBsYWluX3RleHQgIHV0Zi04IHN0cmluZ1xuICogQHJldHVybiBQcm9taXNlPFN0cmluZz5cbiAqL1xuSm9zZUpXRS5FbmNyeXB0ZXIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbl90ZXh0KSB7XG4gIC8qKlxuICAgKiBFbmNyeXB0cyBwbGFpbl90ZXh0IHdpdGggQ0VLLlxuICAgKlxuICAgKiBAcGFyYW0gY2VrX3Byb21pc2UgIFByb21pc2U8Q3J5cHRvS2V5PlxuICAgKiBAcGFyYW0gcGxhaW5fdGV4dCAgIHN0cmluZ1xuICAgKiBAcmV0dXJuIFByb21pc2U8anNvbj5cbiAgICovXG4gIHZhciBlbmNyeXB0UGxhaW5UZXh0ID0gZnVuY3Rpb24oY2VrX3Byb21pc2UsIHBsYWluX3RleHQpIHtcbiAgICAvLyBDcmVhdGUgaGVhZGVyXG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMudXNlckhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnNbaV0gPSB0aGlzLnVzZXJIZWFkZXJzW2ldO1xuICAgIH1cblxuICAgIGhlYWRlcnMuYWxnID0gdGhpcy5jcnlwdG9ncmFwaGVyLmdldEtleUVuY3J5cHRpb25BbGdvcml0aG0oKTtcbiAgICBoZWFkZXJzLmVuYyA9IHRoaXMuY3J5cHRvZ3JhcGhlci5nZXRDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobSgpO1xuICAgIHZhciBqd2VfcHJvdGVjdGVkX2hlYWRlciA9IFV0aWxzLkJhc2U2NFVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBJVlxuICAgIHZhciBpdiA9IHRoaXMuY3J5cHRvZ3JhcGhlci5jcmVhdGVJVigpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBBQURcbiAgICB2YXIgYWFkID0gVXRpbHMuYXJyYXlGcm9tU3RyaW5nKGp3ZV9wcm90ZWN0ZWRfaGVhZGVyKTtcbiAgICBwbGFpbl90ZXh0ID0gVXRpbHMuYXJyYXlGcm9tVXRmOFN0cmluZyhwbGFpbl90ZXh0KTtcblxuICAgIHJldHVybiB0aGlzLmNyeXB0b2dyYXBoZXIuZW5jcnlwdChpdiwgYWFkLCBjZWtfcHJvbWlzZSwgcGxhaW5fdGV4dCkudGhlbihmdW5jdGlvbihyKSB7XG4gICAgICByLmhlYWRlciA9IGp3ZV9wcm90ZWN0ZWRfaGVhZGVyO1xuICAgICAgci5pdiA9IGl2O1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNla19wcm9taXNlLCBlbmNyeXB0ZWRfY2VrO1xuXG4gIGlmICh0aGlzLmNyeXB0b2dyYXBoZXIuZ2V0S2V5RW5jcnlwdGlvbkFsZ29yaXRobSgpID09IFwiZGlyXCIpIHtcbiAgICAvLyB3aXRoIGRpcmVjdCBlbmNyeXB0aW9uLCB0aGlzLmtleV9wcm9taXNlIHByb3ZpZGVzIHRoZSBjZWtcbiAgICAvLyBhbmQgZW5jcnlwdGVkX2NlayBpcyBlbXB0eVxuICAgIGNla19wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMua2V5X3Byb21pc2UpO1xuICAgIGVuY3J5cHRlZF9jZWsgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDcmVhdGUgYSBDRUsga2V5XG4gICAgY2VrX3Byb21pc2UgPSB0aGlzLmNyeXB0b2dyYXBoZXIuY3JlYXRlQ2VrKCk7XG5cbiAgICAvLyBLZXkgJiBDZWsgYWxsb3dzIHVzIHRvIGNyZWF0ZSB0aGUgZW5jcnlwdGVkX2Nla1xuICAgIGVuY3J5cHRlZF9jZWsgPSBQcm9taXNlLmFsbChbdGhpcy5rZXlfcHJvbWlzZSwgY2VrX3Byb21pc2VdKS50aGVuKGZ1bmN0aW9uIChhbGwpIHtcbiAgICAgIHZhciBrZXkgPSBhbGxbMF07XG4gICAgICB2YXIgY2VrID0gYWxsWzFdO1xuICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvZ3JhcGhlci53cmFwQ2VrKGNlaywga2V5KTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gQ2VrIGFsbG93cyB1cyB0byBlbmNyeXB5IHRoZSBwbGFpbiB0ZXh0XG4gIHZhciBlbmNfcHJvbWlzZSA9IGVuY3J5cHRQbGFpblRleHQuYmluZCh0aGlzLCBjZWtfcHJvbWlzZSwgcGxhaW5fdGV4dCkoKTtcblxuICAvLyBPbmNlIHdlIGhhdmUgYWxsIHRoZSBwcm9taXNlcywgd2UgY2FuIGJhc2U2NCBlbmNvZGUgYWxsIHRoZSBwaWVjZXMuXG4gIHJldHVybiBQcm9taXNlLmFsbChbZW5jcnlwdGVkX2NlaywgZW5jX3Byb21pc2VdKS50aGVuKGZ1bmN0aW9uKGFsbCkge1xuICAgIHZhciBlbmNyeXB0ZWRfY2VrID0gYWxsWzBdO1xuICAgIHZhciBkYXRhID0gYWxsWzFdO1xuICAgIHJldHVybiBkYXRhLmhlYWRlciArIFwiLlwiICtcbiAgICAgIFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShlbmNyeXB0ZWRfY2VrKSArIFwiLlwiICtcbiAgICAgIFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShkYXRhLml2KSArIFwiLlwiICtcbiAgICAgIFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShkYXRhLmNpcGhlcikgKyBcIi5cIiArXG4gICAgICBVdGlscy5CYXNlNjRVcmwuZW5jb2RlQXJyYXkoZGF0YS50YWcpO1xuICB9KTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgVmlzYSBWRENQIHVzZS1jYXNlLlxuICogZXhwZWN0cyBhbiBSU0Ega2V5IGFzIGEgSlMgZGF0YSBvYmplY3Qgd2l0aCAyIHJlcXVpcmVkIGZpZWxkczpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcnNhS2V5SWQgKFJFUVVJUkVEKVxuICogQHBhcmFtIHshb2JqZWN0fSByc2FLZXkgKFJFUVVJUkVEKVxuICogICAgUmVxdWlyZXM6XG4gKiAgICAgIC0gYG5gIGF0dHJpYnV0ZSAobW9kdWx1cylcbiAqICAgICAgLSBgZWAgYXR0cmlidXRlIChwdWJsaWNFeHBvbmVudClcbiAqIEBwYXJhbSB7P3N0cmluZ30gc2NoZW1lIChvcHRpb25hbCkgZGVmYXVsdCAnUlNBLU9BRVAtMjU2J1xuICogQHBhcmFtIHs/QVBJfSBjcnlwdG9Qcm92aWRlciAob3B0aW9uYWwpIHdpbmRvdy5jcnlwdG8sIG5vZGUtd2ViY3J5cHRvLW9zc2wsIG5vZGUtd2ViY3J5cHRvLXBrY3MxMSBldGMuXG4gKi9cbnZhciBQQU5KV0UgPSBmdW5jdGlvbihyc2FLZXlJZCwgcnNhS2V5LCBzY2hlbWUsIGNyeXB0b1Byb3ZpZGVyKSB7XG4gIHNjaGVtZSA9IHNjaGVtZSB8fCAnUlNBLU9BRVAtMjU2JztcblxuICBpZiAoY3J5cHRvUHJvdmlkZXIpIHtcbiAgICBKb3NlLnNldENyeXB0byhjcnlwdG9Qcm92aWRlcik7XG4gIH1cblxuICB2YXIgY3J5cHRvZ3JhcGhlciA9IG5ldyBKb3NlLldlYkNyeXB0b2dyYXBoZXIoKTtcblxuICAvLyBzZXQgdmFsdWVzIGZvciBzY2hlbWUgYW5kIGNvbnRlbnQgZW5jcnlwdGlvbiBhbGdvcml0aG0uIFRoZXkgd2lsbCBiZSBhZGRlZCB0byBoZWFkZXIgYnkgSm9zZUpXRS5FbmNyeXB0ZXIuZW5jcnlwdFxuICBjcnlwdG9ncmFwaGVyLnNldEtleUVuY3J5cHRpb25BbGdvcml0aG0oc2NoZW1lKTtcbiAgY3J5cHRvZ3JhcGhlci5zZXRDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobSgnQTI1NkdDTScpO1xuXG4gIHZhciByc2Ffa2V5ID0gSm9zZS5VdGlscy5pbXBvcnRSc2FQdWJsaWNLZXkocnNhS2V5LCBzY2hlbWUpO1xuICB2YXIgZW5jcnlwdGVyID0gbmV3IEpvc2VKV0UuRW5jcnlwdGVyKGNyeXB0b2dyYXBoZXIsIHJzYV9rZXkpO1xuICBlbmNyeXB0ZXIuYWRkSGVhZGVyKCdraWQnLCByc2FLZXlJZCk7XG4gIGVuY3J5cHRlci5hZGRIZWFkZXIoJ3R5cCcsICdKT1NFJyk7XG4gIGVuY3J5cHRlci5hZGRIZWFkZXIoJ2lhdCcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICB0aGlzLmVuY3J5cHRlciA9IGVuY3J5cHRlcjtcblxuICAvLyBmb3IgdGVzdGluZywgdGVzdGluZyBidW5kbGUgaW5jbHVkZXMgZGVjcnlwdGVyIG1peGluc1xuICBpZiAoSm9zZUpXRS5EZWNyeXB0ZXIpIHtcbiAgICB2YXIgcHJpdmF0ZV9yc2Ffa2V5ID0gSm9zZS5VdGlscy5pbXBvcnRSc2FQcml2YXRlS2V5KHJzYUtleSwgc2NoZW1lKTtcbiAgICB2YXIgZGVjcnlwdGVyID0gbmV3IEpvc2VKV0UuRGVjcnlwdGVyKGNyeXB0b2dyYXBoZXIsIHByaXZhdGVfcnNhX2tleSk7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBkZWNyeXB0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBlbmNyeXB0cyB0ZXh0XG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBlbmNyeXB0ZWRUZXh0IHN0cmluZyB0byBkZWNyeXB0XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdGhpcy5kZWNyeXB0ID0gZnVuY3Rpb24oZW5jcnlwdGVkVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkVGV4dCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzYW5pdHkgY2hlY2tcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHRoaXMuc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSm9zZS5jYW5pdXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGVuY3J5cHRzIHRleHRcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjaXBoZXJUZXh0IHN0cmluZyB0byBlbmNyeXB0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgdGhpcy5lbmNyeXB0ID0gZnVuY3Rpb24oY2lwaGVyVGV4dCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRlci5lbmNyeXB0KGNpcGhlclRleHQpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMuUEFOSldFID0gUEFOSldFO1xuZXhwb3J0cy5QQU5KV0UgPSBQQU5KV0U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},157:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n;// CONCATENATED MODULE: ./benchmark/js/helpers/utils.js\nconst cel = tag => document.createElement(tag);\nconst utils_gel = id => document.getElementById(id);\nconst gecn = cls => document.getElementsByClassName(cls);\nconst qs = cls => document.querySelector(cls);\nconst qsa = cls => document.querySelectorAll(cls);\n\n\nfunction extractHostname(url) {\n  var hostname;\n  if (url.indexOf(\"//\") > -1) {\n    hostname = url.split('/')[2];\n  }\n  else {\n    hostname = url.split('/')[0];\n  }\n  //find & remove port number\n  hostname = hostname.split(':')[0];\n  //find & remove \"?\"\n  hostname = hostname.split('?')[0];\n  return hostname;\n}\n\nconst catchErr = err => {\n  console.trace(`[ERROR CAUGHT]`, err);\n  const header = cel('div');\n  const pre = cel('pre');\n  const trace = cel('pre');\n  const ts = new Date().toLocaleString();\n  header.innerHTML = `[${ts}] error caught:`;\n  utils_gel('error_log').appendChild(header);\n  \n  if (err.stack) {\n    trace.innerHTML = err.stack;\n    utils_gel('error_log').appendChild(trace);\n  } else {\n    pre.classList.add('error');\n    pre.innerHTML = (typeof err === 'string') ? err : JSON.stringify(err, null, 2);\n    utils_gel('error_log').appendChild(pre);\n  }\n  return err;\n}\n\n\nfunction serializeObject(obj) {\n  if (!obj) {\n    return '';\n  }\n\n  var s = [];\n\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && obj[key].constructor === Array) {\n      obj[key].forEach(function (value) {\n        s.push(key + '=' + encodeURIComponent(value));\n      });\n    } else {\n      s.push(key + '=' + encodeURIComponent(obj[key]));\n    }\n  });\n\n  return s.join('&');\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/compliance-settings.js\n\n\nconst injectComplianceSettings = () => {\n  const terms = {\n    complianceType: \"TERMS_AND_CONDITIONS\",\n    uri: \"usa.visa.com/legal/checkout/terms-of-service.html\",\n  };\n  const privacy = {\n    complianceType: \"PRIVACY_POLICY\",\n    uri: \"usa.visa.com/legal/global-privacy-notice.html\",\n  };\n  const remember = {\n    complianceType: \"REMEMBER_ME\",\n    uri: \"visa.checkout.com/privacy\",\n  };\n\n  intentPayload.complianceSettings = {\n    complianceResources: [terms, privacy, remember]\n  };\n}\n\nconst removeComplianceSettings = () => {\n  delete intentPayload.complianceSettings;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/stubs/data.js\n\n\n\nlet initData;\nlet intentPayload;\n\nconst initDataRoot = {\n  srciTransactionId: \"replace me\",\n  // srciDpaId: \"DPAID\",\n  srcInitiatorId: \"[A-Fa-f0-9|A-Fa-f0-9]{8}\\\\-([A-Fa-f0-9|A-Fa-f0-9]{4}\\\\-){3}[A-Fa-f0-9|A-Fa-f0-9]{12}\",\n  dpaData: {\n    // srcDpaId: \"SRCDPAID\",\n    dpaPresentationName: \"Disney Online\",\n    dpaUri: \"http://www.disneyonline.com\"\n  },\n  dpaTransactionOptions: {\n    dpaLocale: \"US\",\n    dpaAcceptedBillingCountries: [\"US\",\"CA\"],\n    dpaAcceptedShippingCountries: [\"US\",\"CA\"],\n    dpaBillingPreference: \"FULL\",\n    dpaShippingPreference: \"FULL\",\n    consumerNameRequested: true,\n    consumerEmailAddressRequested: true,\n    consumerPhoneNumberRequested: true,\n    paymentOptions: {\n      dpaDynamicDataTtlMinutes: 2,\n      dynamicDataType: \"DYNAMIC_CARD_SECURITY_CODE\",\n      dpaPanRequested: false\n    },\n    reviewAction: \"continue\",\n    transactionType: \"PURCHASE\",\n    orderType: \"REAUTHORIZATION\",\n    payloadTypeIndicator: \"SUMMARY\",\n    transactionAmount: {\n      transactionAmount: \"99.95\",\n      transactionCurrencyCode: \"USD\"\n    },\n    merchantOrderId: \"28b1b61b-bbec-4637-b78f-33babc3b5187\",\n    merchantCategoryCode: \"3000\",\n    merchantCountryCode: \"US\",\n    threeDsPreference: \"NONE\",\n    threeDsInputData: {\n      requestorId: \"requestorId\",\n      acquirerId: \"acquirerId\",\n      acquirerMid: \"acquirerMid\"\n    },\n    customInputData:{\n      checkoutOrchestrator: \"merchant\",//\"TESTING\", // 'merchant' is integrated exp\n      dpaIntegrationType: \"PSP\"\n    }\n  }\n};\n\nconst userInfo = {\n  identityProvider: \"SRC\",\n  identityValue: \"senthilr@mailinator.com\",\n  type: \"EMAIL\"\n};\n\nconst intentPayloadRoot = {\n  srcCorrelationId: \"\",\n  srciTransactionId: \"\",\n  srcDigitalCardId: \"\",\n  encryptedCard: \"\",\n  idToken: \"\",\n  windowRef: \"\",\n  consumer:{\n    consumerIdentity: {\n      identityProvider: \"SRC\", \n      identityType: \"EMAIL_ADDRESS\",\n      identityValue: \"ashok.vbox28@mailinator.com\"\n    },\n    mobileNumber: {\n      phoneNumber: \"4153334444\",\n      countryCode: \"1\"\n    },\n    emailAddress: \"ashok.vbox28@mailinator.com\",\n    nationalIdentifier: \"USA\",\n    countryCode: \"US\",\n    languageCode: \"EN\",\n    firstName: \"PSP\",\n    lastName: \"Tester\",\n    fullName: \"Psp Tester\"\n  },\n  dpaTransactionOptions: {\n    dpaLocale: \"US\",\n    dpaAcceptedBillingCountries: [\"US\",\"CA\"],\n    dpaAcceptedShippingCountries: [\"US\",\"CA\"],\n    dpaBillingPreference: \"ALL\",\n    dpaShippingPreference: \"ALL\",\n    consumerNameRequested: true,\n    consumerEmailAddressRequested: true,\n    consumerPhoneNumberRequested: true,\n    paymentOptions: {\n      dpaDynamicDataTtlMinutes: 2,\n      dynamicDataType: \"TAVV\",\n      dpaPanRequested: false\n    },\n    reviewAction: \"continue\",\n    checkoutDescription: \"Sample checkout\",\n    transactionType: \"PURCHASE\",\n    orderType: \"REAUTHORIZATION\",\n    payloadTypeIndicator: \"SUMMARY\",\n    transactionAmount: {\n      transactionAmount: \"99.95\",\n      transactionCurrencyCode: \"USD\"\n    },\n    merchantOrderId: \"ABC12345\",\n    merchantCategoryCode: \"merchantCategoryCode\",\n    merchantCountryCode: \"US\",\n    threeDsInputData: {\n      requestorId: \"requestorId\",\n      acquirerId: \"acquirerId\",\n      acquirerMid: \"acquirerMid\"\n    },\n    customInputData:{\n      dpaIntegrationType:\"PSP\"\n    }\n  },\n  payloadTypeIndicatorCheckout: \"SUMMARY\",\n  recipientIdCheckout: \"\",\n  payloadTypeIndicatorPayload: \"SUMMARY\",\n  recipientIdPayload: \"\",\n  assuranceData: {\n    verificationData:[{\n      verificationType: \"CARDHOLDER\",\n      verificationEntity: \"01\",\n      verificationMethod: \"01\",\n      verificationresponses: \"01\",\n      verificationResults: \"01\",\n      verificationTimestamp: \"1646416550\"\n    }]\n  },\n  srciActionCode: \"NEW_USER\" \n};\n\nlet srcProfiles = [];\n\nconst benchmark = {\n  init: 0,\n  isRecognized: 0,\n  identityLookup: 0,\n  initiateIdentityValidation: 0,\n  UIUX_to_OTP: 0,\n  completeIdentityValidation: 0,\n  getSrcProfile: 0,\n  UIUX_to_cardList: 0,\n  checkout: 0,\n  addCard: 0,\n  enrollUser: 0,\n  unbind: 0,\n};\n\nconst benchmarkState = {\n  sdkUrl: '',\n};\n\nconst resetFlow = () => {\n  console.info('RESET')\n  initData = Object.assign({}, initDataRoot);\n  intentPayload = Object.assign({}, intentPayloadRoot);\n  srcProfiles = [];\n};\n\n\nconst getIntentPayload = () => {\n  if (!intentPayload) {\n    intentPayload = Object.assign({}, intentPayloadRoot);\n  }\n\n  if (utils_gel('compliance_toggle').checked) {\n    injectComplianceSettings();\n  } else {\n    removeComplianceSettings();\n  }\n\n  return intentPayload;\n};\n\nconst setIntentPayload = payload => {\n  intentPayload = payload;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/email.js\n\n\n\n// To autofill the email in idlookup field\nfunction emailSetter(email) {\n  if (email) {\n    const em = utils_gel('emailInput');\n    em.value = email;\n\n    autoIdLookupEmailAddress(email);\n    autoFillEmailAddressInCheckoutApirequest(email);\n  }\n}\n\nfunction setHistoricalEmails() {\n  let emailHistorical = localStorage.getItem('email_historical');\n\n  if (emailHistorical) {\n    const history = utils_gel('email_historical');\n    emailHistorical = JSON.parse(emailHistorical);\n\n    // remove existing node\n    qsa('#email_historical option').forEach(node => {\n      node.parentNode.removeChild(node);\n    });\n\n    for (let i=0; i<emailHistorical.length; i++) {\n      let option = cel('option');\n      option.value = emailHistorical[i];\n      option.className = 'historical_email_option';\n      option.appendChild(document.createTextNode(emailHistorical[i]));\n\n      history.appendChild(option);\n    }\n  }\n}\n\n// update email in idLookup payload\nfunction autoIdLookupEmailAddress(email) {\n  let emailHistorical;\n\n  if (userInfo) {\n    userInfo.identityValue = email;\n    localStorage.setItem('email', email);\n\n    emailHistorical = localStorage.getItem('email_historical');\n\n    if (!emailHistorical) {\n      emailHistorical = [];\n    } else {\n      emailHistorical = JSON.parse(emailHistorical);\n    }\n\n    if (emailHistorical.indexOf(email) < 0) {\n      emailHistorical.push(email);\n      localStorage.setItem('email_historical', JSON.stringify(emailHistorical));\n      setHistoricalEmails();\n    }\n  }\n}\n\n// To autofill the email in checkout field\nfunction autoFillEmailAddressInCheckoutApirequest(email) {\n  const intentPayload = getIntentPayload();\n  \n  if (intentPayload) {\n    intentPayload.consumer.emailAddress = emailInput.value;\n    intentPayload.consumer.consumerIdentity.identityValue = emailInput.value;\n    intentPayload.consumer.mobileNumber.phoneNumber = '4153334444';\n  }\n}\n\n\nconst setEmailErrorMessage = (msg) => {\n  gel('email_error_message').innerHTML = msg;\n}\n\n// bootstrap\nutils_gel('emailInput').onblur = function populateEmail() {\n  const email = this.value;\n  emailSetter(email);\n}\nutils_gel('emailInput').onfocus = () => {\n  utils_gel('email_error_message').innerHTML = '';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/generate-sdk-list.js\n\n\nconst envs = {\n  // \"--- Pick\": \"\",\n  QaPerf_DockerEE: \"https://src-qaperfb.k8s-np-cls1-p.trusted.visa.com\",\n  QAWKSPCE: \"https://b2cp-vco-qab.oce-np-sm-ddp-p-en.trusted.visa.com\",\n  DEVWKSPCE: \"https://b2cp-rf1-272-skirova.k8s-np-cls1-p.trusted.visa.com\",\n  Qa_OpenShift: 'https://b2cp-vco-qa.k8s-np-cls1-p.trusted.visa.com',\n  // Qa_DockerEE: 'https://b2cp-vco-qab.oce-np-sm-ddp-p-en.trusted.visa.com',\n  // QaPerf: \"https://perf.qa.secure.checkout.visa.com\",\n\n  SandBox: \"https://sandbox.secure.checkout.visa.com\",\n  // CERT: \"https://cert.secure.checkout.visa.com\",\n  // CERT1: \"https://cert1.secure.checkout.visa.com\",\n  // ICL: \"https://demo.icl.visa.com\",\n  // QAINT: \"https://int.qa.secure.checkout.visa.com\",\n  // Vbox444_ExternalSrci: \"https://vbox444.secure.checkout.visa.com\",\n  // Vbox444_PSP: \"https://vbox444.secure.checkout.visa.com\",\n  // Vbox444_Adyen: \"https://vbox444.secure.checkout.visa.com\",\n  // vboxOpenShift_chris: \"https://b2cp-tion-23-mnojima.k8s-np-cls1-p.trusted.visa.com\",\n  // Vbox28: \"https://vbox28.secure.checkout.visa.com\",\n  // Vbox441: \"https://vbox441.secure.checkout.visa.com\",\n  // Vbox442: \"https://vbox442.secure.checkout.visa.com\",\n  // Vbox442_Adyen: \"https://vbox442.secure.checkout.visa.com\",\n  // Vbox444_3DS: \"https://vbox444.secure.checkout.visa.com\",\n  // Vbox444_Container: \"https://src-qab.k8s-np-cls1-p.trusted.visa.com\",\n  // Vbox444_Container_DockerEE: \"https://b2cp-vco-qab.k8s-np-cls1-p.trusted.visa.com\",\n  // Vbox671: \"https://vbox671.secure.checkout.visa.com\",\n};\n\n\nconst buildSdkPicker = () => {\n  // const sdkSelector = gel('sdk_picker_v1');\n  // const sdkSelector_v2 = gel('sdk_picker_v2');\n  const sdkSelector_v2_integrated = utils_gel('sdk_picker_v3');\n  const storedSdk = localStorage.getItem('sdk');\n  \n  for (let k in envs) {\n    // const option = cel('option');\n    // option.setAttribute('value', `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visaSdk.js`);\n    // option.innerHTML = `${k} SDKv1`;\n    // option.selected = storedSdk === `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visaSdk.js`;\n  \n    // const option_v2 = cel('option');\n    // option_v2.setAttribute('value', `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visa-sdk.js`)\n    // option_v2.innerHTML = `${k} SDKv2`;\n    // option_v2.selected = storedSdk === `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visa-sdk.js`;\n\n    const option_v3 = cel('option');\n    option_v3.setAttribute('value', `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visa-sdk.js?v2`)\n    option_v3.innerHTML = `${k} SDKv2 INTEGRATED`;\n    option_v3.selected = storedSdk === `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visa-sdk.js?v2`;\n  \n    // sdkSelector.appendChild(option);\n    // sdkSelector_v2.appendChild(option_v2);\n    sdkSelector_v2_integrated.appendChild(option_v3);\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/can-use-test-cards-api.js\nconst canUseTestCardApi = () => {\n  switch (window.location.hostname) {\n    // case 'localhost':\n    case 'cnojima.github.io':\n      return false;\n  }\n\n  return true;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/components/card-bin-selector/index.js\n\n\n\nconst bins = {\n  '-- 400552 (non-tokenizable?)': '400552',\n  '-- 420767 (tokenizable)': '420767',\n  '-- 414718 (tokenizable)': '414718'\n};\n\nconst handleBinSelection = e => {\n  localStorage.setItem('binRange', e.target.value);\n}\n\nconst initBinSelector = () => {\n  const binRange = localStorage.getItem('binRange');\n  const select = utils_gel('bin_range');\n\n  for (let k in bins) {\n    const option = document.createElement('option');\n    option.value = bins[k];\n    option.label = k;\n\n    if (binRange === bins[k]) {\n      option.selected = true;\n    }\n\n    select.appendChild(option);\n  }\n\n  select.addEventListener('change', handleBinSelection);\n\n  if (canUseTestCardApi()) {\n    utils_gel('bin_selector').style.display = 'block';\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/stubs/environment-keys.js\nconst environmentKeys = {\n  'QaPerf': {\n    srcInitiatorId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    panEncryptionId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'QaPerf_DockerEE': {\n    srcInitiatorId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    panEncryptionId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'DEVWKSPCE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'QAWKSPCE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  'Vbox444_Container': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  'Vbox444_ExternalSrci': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_Adyen': {\n    srcInitiatorId: '8YPW4SHDFX5VLZ8MLHDB218WlvAwM4z2Pg1r_DpZY8lNaibec',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_PSP': {\n    srcInitiatorId: 'TC03UO784YYUIR3BANUG11WE2pQEWgr5PpuIVbUZFB_oZLOco',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_3DS': {\n    srcInitiatorId: '8YPW4SHDFX5VLZ8MLHDB218WlvAwM4z2Pg1r_DpZY8lNaibec',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: 'ab1a4e6f-956c-a793-721f-133336dc270'\n  },\n  'QAINT': {\n    srcInitiatorId: 'D257GCAOR3JGPTGACON811hN5odBtBaW0Z18OnXh3bhwFuH18',\n    panEncryptionId: 'D257GCAOR3JGPTGACON811hN5odBtBaW0Z18OnXh3bhwFuH18',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT': {\n    srcInitiatorId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    panEncryptionId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT1': {\n    srcInitiatorId: 'B8VF3G544MK90PMQAG3I11nR-eWQmj3uhfs9dQXPEdjbmrpfo',\n    panEncryptionId: 'L9A8ACW4DCTK83U2T4SB11NhQpVkp7mAh9NtnN5ms0wYu7wo0',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'SandBox': {\n    srcInitiatorId: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM',\n    panEncryptionId: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM',\n    srciDpaId: 'matestdpa2',\n    srcDpaId: ''\n  },\n  'Vbox444_Container_DockerEE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Qa_OpenShift': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  'Qa_DockerEE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-keys.ts\n\nvar getFromLocalStorage = function (key) {\n    var values = localStorage.getItem(key);\n    if (values) {\n        return JSON.parse(values);\n    }\n    return {};\n};\nvar getMerchantApiKeys = function () {\n    return getFromLocalStorage('merchantApiKeys');\n};\nvar getEnvironmentKeys = function () {\n    return getFromLocalStorage('environmentKeys');\n};\nvar getEncryptionKeys = function () {\n    return getFromLocalStorage('keys');\n};\nvar getEnvironment = function (key) {\n    var envKeys = (environmentKeys) ? environmentKeys : getEnvironmentKeys();\n    var genericKey = key.replace(/SDKv[0-9].*$/i, '').trim();\n    if (envKeys[genericKey]) {\n        return envKeys[genericKey];\n    }\n    return null;\n};\nvar getMerchantApiKey = function (key) {\n    var env = getEnvironment(key);\n    if (env)\n        return env.srcInitiatorId;\n    return null;\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/async/init.js\n\n\n\n\nasync function init(adapter, key, startTime) {\n  console.log('[INIT] start');\n  const apikey = getMerchantApiKey(key);\n  if (apikey) {\n    initData.apikey = apikey;\n  }\n\n  console.log('[INIT_DATA]', initData);\n\n  await adapter.init(initData).then((response) => {\n    const endTime = Date.now();\n    benchmark.init = endTime - startTime;\n    console.log(`[init] ttaken: ${(benchmark.init)}ms`, response);\n\n    if (!Object.keys(response).length) {\n      utils_gel('init_complete').checked = true;\n      utils_gel('init_complete_timing').innerHTML = `${(benchmark.init)}ms`;\n    } else if (response.error) {\n      throw new Error(JSON.stringify(response, null, 2));\n    } else {\n      console.error('init failed, check console');\n    }\n\n    return response;\n  }).catch(catchErr);\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/is-recognized.js\n\n\n\n\nasync function isRecognized(adapter) {\n  console.log('[RECOGNIZE] start');\n  const startTime = Date.now();\n\n  let token;\n  const response = await adapter.isRecognized().catch(catchErr);\n  const endTime = Date.now();\n\n  benchmark.isRecognized = endTime - startTime;\n\n  utils_gel('is_recognized_complete').checked = true;\n  utils_gel('is_recognized_complete_timing').innerHTML = `${benchmark.isRecognized}ms`;\n\n  if (response.idTokens) {\n    token = response.idTokens[0];\n  } else if (response.recognized === false) {\n    utils_gel('is_recognized_complete_timing').innerHTML = `${benchmark.isRecognized}ms (unrecognized)`;\n  } else if (response.error) {\n    throw new Error(JSON.stringify(response, null, 2));\n  }\n\n  console.log(`[recognized] ttaken: ${(benchmark.isRecognized)}ms`);\n  return token;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-root-domain.js\n/*\n  cannot import util from visa-sdk; copied util over for now\n*/\n\n\n// This dummy URL is updated by a deploy script based on the environment. E.g.\n// when deploying to production, CI replaces dev.www.v.me with\n// secure.checkout.visa.com, but when deploying to cert, it will be\n// cert.secure.checkout.visa.com.\nconst STATIC_ROOT_DOMAIN = 'https://dev.www.v.me';\n\nconst sdkScriptRegex =\n  /^https:\\/\\/[\\w-\\.]+\\.?\\.visa\\.com\\/checkout\\-widget\\/resources\\/js\\/src-i-adapter\\/visa[\\-sS]{1,2}dk\\.js/;\n\nfunction getSDKScriptEl() {\n  const scripts = document.querySelectorAll('script');\n\n  for (const script of scripts) {\n    if (script.src.match(sdkScriptRegex)) {\n      return script;\n    }\n  }\n\n  return null;\n}\n\nconst assetsMap = {\n  '//assets.secure.checkout.visa.com': '//secure.checkout.visa.com',\n  '//cert-assets.secure.checkout.visa.com': '//cert.secure.checkout.visa.com',\n  '//sandbox-assets.secure.checkout.visa.com': '//sandbox.secure.checkout.visa.com'\n};\n\nfunction mapAssetsUrl(url) {\n  const assetDomains = Object.keys(assetsMap);\n\n  for (const assetDomain of assetDomains) {\n    if (url.indexOf(assetDomain) !== -1) {\n      return url.replace(assetDomain, assetsMap[assetDomain]);\n    }\n  }\n\n  return url;\n}\n\n// Root domain is updated by a deploy script based on the environment. E.g.\n// when deploying to production, CI replaces dev.www.v.me with\n// secure.checkout.visa.com, but when deploying to cert, CI uses\n// cert.secure.checkout.visa.com.\nconst dummyUrlHash = 'aHR0cHM6Ly9kZXYud3d3LnYubWU'; // btoa('https://dev.www.v.me')\nconst wasDummyUrlReplaced = STATIC_ROOT_DOMAIN !== window.atob(dummyUrlHash);\n\nfunction getRootDomain() {\n  if (wasDummyUrlReplaced) {\n    return STATIC_ROOT_DOMAIN;\n  }\n\n  // In container deployments, the dummy url may not have been replaced. In this\n  // case we need to determine the environment url from the visaSdk.js script tag.\n\n  const sdkScriptEl = getSDKScriptEl();\n\n  if (sdkScriptEl) {\n    return mapAssetsUrl(sdkScriptEl.src.split('/', 3).join('/'));\n  }\n\n  // Default to the prod URL for any abnormal integration.\n  return 'https://secure.checkout.visa.com';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/load-sdk.js\n\n\n\nconst loadSdk = (sdkUrl, callback) => {\n  const loadStart = Date.now();\n  let sdkMount = getSDKScriptEl();\n  let tag;\n\n  if (sdkMount) {\n    console.info('>>>> removing <script /> tag from prior load');\n    sdkMount.parentNode.removeChild(sdkMount);\n  }\n\n  tag = document.createElement(\"script\");\n  tag.src = sdkUrl;\n  tag.type = 'text/javascript';\n  tag.async = false;\n  tag.onload = () => {\n    callback(loadStart).catch(err => {\n      utils_gel('error_log').innerHTML = err;\n    });\n  }\n\n  const head = document.getElementsByTagName(\"head\")[0];\n  (head || document.body).appendChild(tag);\n}\n\n/* harmony default export */ const load_sdk = (loadSdk);\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/update-benchmarks.js\n\n\n\nlet startTime;\n\nconst setStartTime = () => startTime = Date.now();\n\nconst updateBenchmarks = () => utils_gel('benchmark_data').value = JSON.stringify(benchmark, null, 2);\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/uuid.js\n\n\n\n// Method to generate random UUID\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n// To autofill UUID on every page refresh\nfunction autoFillUUID(key) {\n  const intentPayload = getIntentPayload();\n  const srciTransactionId = uuidv4();\n  const env = getEnvironment(key);\n  initData.srciTransactionId = srciTransactionId;\n  intentPayload.srciTransactionId = srciTransactionId;\n\n  const bad = ['srcDpaId', 'panEncryptionId'];\n  for (let k in env) {\n    if (bad.indexOf(k) === -1)\n      initData[k] = env[k];\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/reset-ui.js\n\n\n\nconst targets = [\n  'init_complete', 'is_recognized_complete', 'auth_complete', 'get_src_profile_complete', 'checkout_complete', 'unbind_complete'\n];\n\nconst resetUi = () => {\n  targets.forEach(id => {\n    utils_gel(id).checked = false;\n    utils_gel(`${id}_timing`).innerHTML = '';\n  });\n\n  Array(qsa('.messaging')).forEach(el => {\n    el.innerHTML = '';\n  });\n\n  utils_gel('auth_breakdown').innerHTML = '';\n  utils_gel('error_log').innerHTML = '';\n  utils_gel('benchmark_data').value = '';\n  utils_gel('otp_entry').style.display = 'none';\n\n  for (let k in benchmark) {\n    benchmark[k] = 0;\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/fetch.js\nconst genId = () => Math.random().toString(36).substring(7);\nconst systemCorrelationId = `1_1492561111_766_48_${genId()}_CHECKOUT-WIDGET`;\nconst systemSessionId = `vme_qa_001${genId()}`;\n\nvar fetchReq = function (options) {\n  const {\n    url,\n    body,\n    method,\n    headers\n  } = options;\n  headers['X-CORRELATION-ID'] = systemCorrelationId;\n  headers['dfpSessionId'] = systemSessionId;\n  headers['X-THMID'] = systemSessionId;\n\n  const contentType = headers['Content-Type'];\n  let finalBody = {};\n\n  if (contentType && contentType.includes('x-www-form-urlencoded')) {\n    finalBody = fetch_serializeObject(body);\n  } else {\n    finalBody = JSON.stringify(body);\n  }\n  return fetch(\n      url,\n      Object.assign({}, {\n        body: finalBody,\n        credentials: 'same-origin',\n        headers: headers,\n        method\n      })\n    )\n    .then(res => handleJsonResponse(res))\n    .then(data => data)\n    .catch(error => {return error});\n};\n\nfunction fetch_uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nfunction handleJsonResponse(res) {\n  const headers = {};\n  res.headers.forEach(function (v, k) {\n    headers[k] = v;\n  });\n  // console.log('headers - ' + JSON.stringify(headers));\n  return (\n    res\n    .json()\n    .then(function (data) {\n      console.log('data', data);\n      return {\n        data: data,\n        headers: headers\n      }\n    })\n    .catch(function () {\n      return {\n        headers: headers\n      }\n    }))\n};\n\n\nfunction fetch_serializeObject(obj) {\n  if (!obj) {\n    return '';\n  }\n\n  var s = [];\n\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && obj[key].constructor === Array) {\n      obj[key].forEach(function (value) {\n        s.push(key + '=' + encodeURIComponent(value));\n      });\n    } else {\n      s.push(key + '=' + encodeURIComponent(obj[key]));\n    }\n  });\n\n  return s.join('&');\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-otp.js\n\n\n\n\nlet isQAPerf = false;\nconst useProxy = true;\n\nasync function getOTP(email) {\n  console.info('@getOTP - attempting to retrieve OTP code via API');\n\n  isQAPerf = localStorage.getItem('sdk').indexOf('qaperf') > -1;\n\n  if (isQAPerf) {\n    const res = await fetch(`/id?email=${email}`).then(handleJsonResponse);\n\n    if (res.data.uuid) {\n      // sha256 hash of UUID + email\n      // no transpile of node code, leverage simple API\n      const hash = await fetch(`/sha?s=${res.data.uuid}${email.toLowerCase()}`).then(handleJsonResponse);\n      // base64 encode shasum\n      try {\n        const encrypted = btoa(hash.data.sha256);\n        const otpBody = await fetch(`/otp?encrypted=${encrypted}`).then(handleJsonResponse);\n// console.log('otp', otpBody);Q\n\n        if (otpBody.data.otpValue) {\n          console.log(`got OTP value [${otpBody.data.otpValue}]`);\n          return otpBody.data.otpValue;\n        }\n      } catch (err) {\n        throw new Error(err);\n      }\n      throw new Error(`OTP fetch failed`);\n    }\n  } else {\n    let token;\n    const proxy = `${window.location.protocol}//${window.location.hostname}:${window.location.port}/proxy`;\n    const url = 'https://vbox671.secure.checkout.visa.com/srcsdktester/generateOtp';\n  \n    const environment = extractHostname(benchmarkState.sdkUrl);\n    // console.log(\"Environment:\", environment);\n  \n    // Make indirect call to get OTP\n    const options = {\n      method: 'GET',\n      url: useProxy ? `${proxy}?url=${url}` : url,\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json; charset=UTF-8',\n        'envn': environment,\n        'email': email,\n      }\n    };\n\n    const result = await fetchReq(options).catch(err => {\n      console.error('getOTP error:', err);\n    });\n    if (result.data.otpValue) {\n      return result.data.otpValue;\n    } else {\n      console.warn(`could not autoget OTP code from [${url}]`);\n    }\n  }\n\n  return null;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/can-use-otp-api.js\n\nconst canUseOtpApi = () => {\n  const hostname = window.location.hostname;\n\n  switch(true) {\n    case (hostname.indexOf('github') > -1):\n    case (hostname.indexOf('heroku') > -1):\n    case (localStorage.getItem('sdk').indexOf('qaperf') > -1):\n    // case (hostname.indexOf('localhost') > -1):\n      return false;\n  }\n\n  return true;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/checkout.js\n\n\n\n\nasync function checkout(adapter) {\n  const intentPayload = getIntentPayload();\n  console.log('[CHECKOUT] start');\n  const email = utils_gel('emailInput').value;\n  autoFillEmailAddressInCheckoutApirequest(email);\n\n  console.log('-- intent payload', intentPayload);\n  const startTime = Date.now();\n  const response = await adapter.checkout(intentPayload);\n  const endTime = Date.now();\n\n  benchmark.checkout = endTime - startTime;\n\n  console.log(`[checkout] ttaken: ${(benchmark.checkout)}ms`);\n  \n  if (response.error || response['reason']) {\n    throw new Error(JSON.stringify(response, null, 2));\n  } else {\n    utils_gel('checkout_complete').checked = true;\n    utils_gel('checkout_complete_timing').innerHTML = `${(benchmark.checkout)}ms`;\n  }\n  return response;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/get-src-profile.js\n\n\n\n\nasync function getSrcProfile(adapter, authToken) {\n  console.log('[GET_SRC_PROFILE] start');\n  const intentPayload = getIntentPayload();\n\n  const startTime = Date.now();\n  const response = await adapter.getSrcProfile(authToken);\n  const endTime = Date.now();\n  benchmark.getSrcProfile = endTime - startTime;\n  console.log(`[getSrcProfile] ttaken: ${(benchmark.getSrcProfile)}ms`);\n\n  if (response.error) {\n    throw new Error(JSON.stringify(response, null, 2));\n  } else if (response['reason']) {\n    console.warn('Unable to get card list: %o', response);\n    throw new Error(JSON.stringify(response, null, 2));\n  } else {\n    utils_gel('get_src_profile_complete').checked = true;\n    utils_gel('get_src_profile_complete_timing').innerHTML = `${(benchmark.getSrcProfile)}ms`;\n  }\n\n  response.profiles.forEach(profile => srcProfiles.push(profile));\n\n  // set first card\n  try {\n    intentPayload.srcDigitalCardId = srcProfiles[0].maskedCards[0].srcDigitalCardId;\n  } catch (ex) {\n    console.warn('SRC Profile contained no cards');\n    // throw new Error('profile masked card missing srcDigitalCardId', JSON.stringify(srcProfiles, null, 2));\n  }\n  intentPayload.idToken = srcProfiles[0].idToken;\n  intentPayload.srcCorrelationId = response.srcCorrelationId;\n  intentPayload.profiles = srcProfiles;\n\n  console.log(response)\n  return response;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/unbind.js\n\n\n\n\nconst unbind = async (adapter, token) => {\n  if (token) {\n    console.log('[UNBIND]');\n    const start = Date.now();\n    const response = await adapter.unbindAppInstance({});\n    const end = Date.now();\n\n    benchmark.unbind = end - start;\n\n    if (response.error) {\n      throw new Error(JSON.stringify(response, null, 2));\n    } else {\n      utils_gel('unbind_complete').checked = true;\n      utils_gel('unbind_complete_timing').innerHTML = `${benchmark.unbind}ms`;\n\n      console.log('Unbind result received from Visa SRC System');\n//      console.log('Response Data', JSON.stringify(response));\n    }\n    updateBenchmarks();\n    return response;\n  }\n\n  return;\n}\n\n// EXTERNAL MODULE: ./benchmark/js/jose/visa-encrypt.js\nvar visa_encrypt = __webpack_require__(1);\n;// CONCATENATED MODULE: ./benchmark/js/stubs/pan-encryption-keys.js\nconst keys = {\n  sandbox: {\n    // kid: \"1bdab3cc\",\n    kid: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM', // APIkey/srcInitiatorId\n    publicKey: {\n      e: 65537,\n      n: \"00:b1:93:c8:ba:c0:df:ef:24:27:9e:10:64:53:d9:ae:d7:85:4e:3b:70:ab:ba:2d:db:ee:b0:1f:d8:a6:1e:a1:b5:11:99:70:35:ed:bd:49:5f:d8:e0:d0:27:7e:be:0a:66:bb:24:eb:c4:15:12:73:ee:1b:d3:e5:0f:81:2c:06:16:a3:d6:52:9c:74:f0:4c:6a:af:03:c3:3a:f1:68:8c:1a:2e:db:09:72:ab:c6:dc:cb:45:2c:f8:17:de:0b:34:84:e6:53:15:75:25:d3:5d:75:dc:36:ab:be:a9:bd:b6:8c:20:82:24:02:e9:c6:c0:2b:b1:ba:0c:39:7b:0b:79:d8:77:33:85:cd:43:95:c6:02:d4:5f:ed:bf:be:b9:36:39:0e:bf:4a:2d:8c:94:bd:92:80:9d:8d:38:30:a2:4f:10:ee:78:62:22:05:33:90:d3:02:13:4e:9a:cd:3c:f6:37:4c:77:1f:94:44:82:89:8c:f5:36:f9:1a:47:1b:5b:bc:2c:21:b4:db:c4:53:22:93:ec:35:b4:5a:9e:e4:b9:4c:06:3f:ce:5c:43:81:bd:61:28:9d:fa:61:b6:44:34:72:e0:f4:f5:d3:06:17:4e:32:55:3d:d0:34:cb:95:f7:1b:2d:36:be:0f:b0:e0:96:30:1a:58:2b:af:cc:b3:da:1b\"\n    }\n  },\n  qa_perf: {\n    kid: 'L6MLA3P263NC8AFUJGW411x9qo7NVCUjL92sElZ3vdIlsSny0',\n    publicKey: {\n      e: 65537,\n      n: '00:c6:ec:2a:f7:4e:96:d0:89:0d:3a:50:cf:bb:80:50:54:4f:86:05:9c:52:5d:f7:c5:83:10:3a:7e:13:39:d8:db:ac:81:dd:06:50:f8:3f:a3:e6:8b:1f:1c:67:7e:10:db:87:f7:12:22:da:c3:38:17:70:9e:db:0d:1c:4a:cd:fb:b2:cb:1d:9d:67:48:4e:91:f6:68:8a:e9:c3:f7:8c:4f:58:a8:06:2c:a5:33:f8:8a:c3:9d:c8:83:22:2a:ce:89:77:6e:1c:bb:8e:d1:39:b9:6d:0c:3e:7a:3a:4e:53:0b:bb:02:20:e7:2d:09:24:10:ea:f0:95:1e:00:94:fc:82:28:98:18:2f:5a:e9:83:bf:44:cb:13:6f:c3:b3:bb:9b:95:fd:c4:8f:66:81:2b:13:5c:5e:9d:16:05:ef:99:63:4a:c1:2b:99:08:c2:c5:dc:2e:ba:5c:2a:73:e7:7f:00:32:b5:95:aa:36:c5:36:ae:74:a1:3a:61:71:eb:0c:cf:76:31:4a:ed:66:dd:a6:b1:c9:f6:92:b8:b9:2b:ee:25:0e:91:14:c9:3d:16:9b:9c:ac:1a:d1:0c:a2:d1:b7:93:71:d3:dd:f4:a6:98:a2:b4:02:17:e4:3c:c4:28:5c:bf:e9:de:8d:1e:9c:20:b1:4c:b6:a3:71:29:f9:2f:7e:4d'\n    }\n  },\n  production: {\n    kid: \"JHA10LAKEFG0T7CIBS1O14Chn6lq3cdOxq-Wwqa62ZUwKvnm4\",\n    publicKey: {\n      e: 65537,\n      n: \"00:90:fb:a3:c1:52:63:7a:f2:3f:a1:e6:70:66:80:36:5a:3b:7d:e0:31:5c:32:f4:42:69:bf:22:46:21:06:ac:67:ca:5a:d3:42:c1:06:24:ca:5c:ae:46:80:7a:d7:97:18:9b:60:55:6e:fa:0a:1f:c6:32:bf:46:82:dd:dc:1a:87:a5:26:39:d2:6c:ce:62:f4:a5:5f:dc:6f:1f:ed:5f:35:a0:62:0d:ec:60:db:29:d2:c0:71:50:57:10:d4:0e:83:55:bc:8e:c7:12:5b:9a:7c:25:1c:61:39:7e:4b:b3:26:bf:aa:aa:e9:77:46:cc:2c:08:6f:af:3e:b8:7f:fb:ed:bf:45:28:a9:6b:d9:55:af:d8:2f:7c:8e:00:6c:50:01:2d:3a:8a:7a:da:34:ad:63:db:20:12:9d:85:c1:90:ec:93:0f:c7:3a:bc:db:7f:4a:3d:46:5f:4b:23:6e:78:07:1d:2f:ec:87:00:38:b7:2f:65:52:cd:d1:7b:b5:2e:ec:8b:7b:9e:fc:81:68:5c:3a:5b:82:0b:05:c6:f1:2d:ef:d5:25:04:33:81:b1:a8:1c:fe:6b:3d:fd:9b:18:94:96:8a:09:3f:19:8f:08:5a:90:ca:3f:f9:97:5c:f7:b9:ae:75:58:f5:8f:3d:bf:2f:99:78:97:fc:e2:6c:5e:6b:8b\"\n    }\n  },\n  development: {\n    kid: \"IPW4W1DX5D4N5E8LMAC6115la44Nu9zYob_bgrg5EUMksbgT4\",\n    publicKey: {\n      e: 65537,\n      n: \"00:ba:7e:ed:8a:98:e9:99:fb:bb:0d:d8:bf:b3:89:4c:13:74:93:67:0c:02:c9:e8:32:8d:42:2c:5a:fd:ac:cb:67:0e:c9:4b:2e:73:65:7a:1a:d2:45:6c:b8:28:d7:06:ac:1d:8b:0d:1b:88:96:22:35:c1:6f:5f:95:c7:09:0a:d5:fd:92:be:65:fc:36:14:ed:4a:60:5f:f3:bc:b9:20:a5:7e:cb:9c:35:c4:ef:09:26:78:3c:19:3e:d2:a2:9b:dd:b4:15:63:b2:a6:49:21:94:15:e4:37:d4:1e:e0:d9:f1:79:e7:01:a7:56:83:3b:37:59:be:9e:57:e8:9c:a8:84:2b:49:dd:5d:3d:04:37:fd:09:5f:59:93:20:f6:01:d2:d2:1a:57:1d:aa:6f:58:5c:ec:e2:df:77:ae:02:bf:9e:f3:bb:4e:e9:90:60:99:64:08:a4:84:71:c0:19:f0:ee:64:39:89:6d:bc:34:bf:03:f0:2e:69:8a:78:6d:20:9a:15:8f:64:b6:ee:5d:1a:4d:5b:2c:c9:87:a1:41:ee:92:f3:b4:56:24:35:73:53:e1:8c:4b:91:d6:f1:9f:31:6d:c8:a5:50:12:bf:d8:c1:a3:61:7f:4f:a5:6a:5b:98:91:94:68:bf:8f:49:5f:d5:e3:62:a1:a5:cc:98:7d:91:bb\"\n    }\n  },\n  cert: {\n    \"kid\": \"bb917d98\",\n    \"name\": \"qa-cbp-rsa-enc-csr-1\",\n    \"publicKey\": {\n      \"e\": 65537,\n      \"n\": \"00:ba:7e:ed:8a:98:e9:99:fb:bb:0d:d8:bf:b3:89:4c:13:74:93:67:0c:02:c9:e8:32:8d:42:2c:5a:fd:ac:cb:67:0e:c9:4b:2e:73:65:7a:1a:d2:45:6c:b8:28:d7:06:ac:1d:8b:0d:1b:88:96:22:35:c1:6f:5f:95:c7:09:0a:d5:fd:92:be:65:fc:36:14:ed:4a:60:5f:f3:bc:b9:20:a5:7e:cb:9c:35:c4:ef:09:26:78:3c:19:3e:d2:a2:9b:dd:b4:15:63:b2:a6:49:21:94:15:e4:37:d4:1e:e0:d9:f1:79:e7:01:a7:56:83:3b:37:59:be:9e:57:e8:9c:a8:84:2b:49:dd:5d:3d:04:37:fd:09:5f:59:93:20:f6:01:d2:d2:1a:57:1d:aa:6f:58:5c:ec:e2:df:77:ae:02:bf:9e:f3:bb:4e:e9:90:60:99:64:08:a4:84:71:c0:19:f0:ee:64:39:89:6d:bc:34:bf:03:f0:2e:69:8a:78:6d:20:9a:15:8f:64:b6:ee:5d:1a:4d:5b:2c:c9:87:a1:41:ee:92:f3:b4:56:24:35:73:53:e1:8c:4b:91:d6:f1:9f:31:6d:c8:a5:50:12:bf:d8:c1:a3:61:7f:4f:a5:6a:5b:98:91:94:68:bf:8f:49:5f:d5:e3:62:a1:a5:cc:98:7d:91:bb\"\n    }\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/encrypt-card.js\n\n\n\n\n\n// external, scrubbed sites\nif (!keys) {\n  keys = getEncryptionKeys();\n}\n\nconst getRsaKeyFromDomain = () => {\n  const domain = getRootDomain();\n  console.log(`-- detected ${domain} from visa sdk url`);\n\n  switch (true) {\n    case 'https://secure.checkout.visa.com':\n      return keys.production;\n    case domain.indexOf('qaperf') > -1:\n      return keys.qa_perf;\n    case domain.indexOf('cert.') > -1:\n      console.log('using cert enc keys');\n      return keys.cert;\n    case domain.indexOf('sandbox.') > -1:\n      console.log('using sbx enc keys');\n      return keys.sandbox;\n    default:\n      return keys.cert;\n  }\n}\n\nconst PANJWE_visa = async (s) => {\n  const { publicKey, kid } = getRsaKeyFromDomain();\n  console.info(`[PANJWE] kid: ${kid}`);\n  console.info('[PANJWE] publicKey: ', publicKey);\n  const crypt = new visa_encrypt.PANJWE(kid, publicKey);\n  return crypt.encrypt(s);\n}\n\n/* harmony default export */ const encrypt_card = (async (cardDataObject) => await PANJWE_visa(JSON.stringify(cardDataObject)));\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-visa-card.js\n\n\n\n\n\nconst handleCardData = async cardData => {\n  const ret = { cardData: null, encryptedCard: null };\n  const d = cardData.pan || cardData.data?.pan || cardData.data;\n  const expDateArray = d.ExpirationDate.split('/');\n  const vcoCard = {\n    card : {\n      cardSecurityCode: d.Cvv2Value,\n      cardholderFullName: d.CardholderName || \"SRC SDK\",\n      panExpirationMonth: parseInt(expDateArray[0]),\n      panExpirationYear: parseInt('20' + expDateArray[1]),\n      primaryAccountNumber: d.PrimaryAccountNumber,\n      cardholderFirstName: \"TestTool\",\n      cardholderLastName: \"SampleData\",\n      paymentAccountReference: \"\",\n\n      billingAddress: {\n        addressId: \"\",\n        name: \"\",\n        line1: d.AddressStreet,\n        line2: d.AddressStreet2,\n        line3: d.AddressStreet3,\n        city: d.City,\n        state: d.State,\n        countryCode: d.Country,\n        zip: d.AddressPostalCode,\n        createTime: \"\",\n        lastUsedTime: \"\",\n      }\n    }\n  };\n\n  console.log('object to encrypt: ', vcoCard);\n  ret.encryptedCard = await encrypt_card(vcoCard);\n  console.log(ret);\n  return ret;\n}\n\n/* harmony default export */ const get_visa_card = (async () => {\n  const binRange = utils_gel('bin_range').value;\n  const cardData = await fetch(`/cards?bin=${binRange}`).then(handleJsonResponse);\n  return await handleCardData(cardData);\n});\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-visa-card-manual.js\n\n\n\nconst encryptManualCardEntry = async () => {\n  const s = utils_gel('pan_json').value;\n  let pan;\n\n  try {\n    pan = JSON.parse(s);\n    return await handleCardData(pan);\n  } catch (e) {\n    catchErr('manual PAN JSON parse failed.');\n    return { encryptedCard: null }\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/after-auth.js\n\n\n\n\n\n\n\n\n\n\nasync function afterAuthNewUser(adapter, label) {\n  const intentPayload = getIntentPayload();\n  console.log('56789876567', intentPayload)\n  console.info(`[ADD_CARD] ${label || 'new user + enroll'}`);\n\n  if (canUseTestCardApi()) {\n    intentPayload.encryptedCard = (await get_visa_card()).encryptedCard;\n  } else {\n    intentPayload.encryptedCard = (await encryptManualCardEntry()).encryptedCard;\n  }\n  // console.log('intent payload after getVisaCard: ', intentPayload);\n\n  if (intentPayload.srcDigitalCardId) {\n    console.info('card already assigned, undefining intentPayload.srcDigitalCardId')\n    intentPayload.srcDigitalCardId = undefined;\n  }\n\n  console.info(`[CHECKOUT] ${label || 'new user + enroll'}`);\n  const checkoutSuccess = await checkout(adapter).catch(catchErr);\n\n  if (!checkoutSuccess || checkoutSuccess.error) {\n    console.error(`checkout error detected: `, checkoutSuccess);\n    throw new Error(JSON.stringify(checkoutSuccess));\n  } else {\n    updateBenchmarks();\n  }\n\n  if (checkoutSuccess && checkoutSuccess.unbindAppInstance) {\n    await unbind(adapter, checkoutSuccess).catch(catchErr);\n  }\n}\n\n\nasync function afterAuthReturning(adapter, token) {\n  console.info('[CARD_LIST]');\n  // getSrcProfile\n  const srcProfiles = await getSrcProfile(adapter, token).catch(catchErr);\n  updateBenchmarks();\n\n  console.log(\"------\", srcProfiles);\n\n  if (srcProfiles.error) {\n    // throw new Error(srcProfiles.error);\n    console.warn(srcProfiles.error);\n  }\n\n  const preferAddCard = utils_gel('add_card_flow').checked;\n\n  // checkout\n  if (\n    false === preferAddCard &&\n    srcProfiles &&\n    !srcProfiles.error &&\n    srcProfiles.profiles[0].maskedCards.length > 0\n  ) {\n    console.info('[CHECKOUT] returning user');\n    const checkoutSuccess = await checkout(adapter).catch(catchErr);\n\n    if (!checkoutSuccess || checkoutSuccess.error) {\n      console.error(`checkout error detected: `, checkoutSuccess);\n      throw new Error(JSON.stringify(checkoutSuccess));\n    } else {\n      updateBenchmarks();\n    }\n\n    if (checkoutSuccess && checkoutSuccess.unbindAppInstance) {\n      await unbind(adapter, checkoutSuccess).catch(catchErr);\n    }\n  } else {\n    afterAuthNewUser(adapter, 'returning user add card');\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/auth-flow.js\n\n\n\n\n\n\n\nlet auth_flow_isQAPerf;\n\nwindow.otp_listener = false;\n\n\n\nasync function submitOtp(otpCode) {\n  console.info('---- submitOtp');\n  const completeIdentityValidationStart = Date.now();\n  const res = await completeIdentityValidation(window.c2p_adapter, {\n    validationData: otpCode\n  }).catch(catchErr);\n  benchmark.completeIdentityValidation = Date.now() - completeIdentityValidationStart;\n\n  utils_gel('auth_complete').checked = true;\n  utils_gel('auth_complete_timing').innerHTML = `${(benchmark.identityLookup + benchmark.initiateIdentityValidation + benchmark.completeIdentityValidation) / 1000}s`;\n  utils_gel('auth_breakdown').innerHTML = `[ identityLookup: ${benchmark.identityLookup}ms ]<br/>[ initiateIdentityValidation: ${benchmark.initiateIdentityValidation}ms ]<br/>[ completeIdentityValidation: ${benchmark.completeIdentityValidation}ms ]`;\n\n  console.log(`/probe`, res);\n  return res;\n}\n\nasync function completeIdentityValidation(adapter, code) {\n  console.log(\"@completeIdentityValidation - Validation Data => \", code);\n  const response = await adapter.completeIdentityValidation(code).catch(catchErr);\n  console.log(`---- completeIdentityValidation - response`, response);\n\n  if (response.error) {\n    return null;\n  } else if (response['reason']) {\n    console.log('Unable to verify OTP: %o', response);\n  } else {\n    console.log('Response from Verify OTP: %o', response);\n  }\n  return response;\n}\n\nasync function initiateIdentityValidation(adapter) {\n  console.log('@initiateIdentityValidation');\n  return await adapter.initiateIdentityValidation().then((response) => {\n    console.log(`response from initiateIdentyValidation`, response);\n    if (response['reason']) {\n      console.warn('Unable to initialize Identity validation, error: %o', response);\n      return false;\n    }\n    return response;\n  }).catch(catchErr);\n}\n\n\n\nasync function authFlow(afterAuth, updateBenchmarks) {\n  console.log('[AUTH_FLOW] start');\n  let otpCode;\n  const email = localStorage.getItem('email');\n\n  // idLookup\n  const identityLookupStart = Date.now();\n\n  console.log('-- starting async identityLookup');\n  const res = await window.c2p_adapter.identityLookup({\n    identityProvider: \"SRC\",\n    identityValue: email,\n    type: \"EMAIL\"\n  }).catch(catchErr);\n  console.log('-- identityLookup return', res);\n\n  benchmark.identityLookup = Date.now() - identityLookupStart;\n  updateBenchmarks();\n\n  if (res.error) {\n    throw new Error(JSON.stringify(res, null, 2));\n  } else if (res.consumerPresent || res.accessToken) {\n    // reissueance\n    console.log('--- reissuance');\n    const initiateIdentityValidationStart = Date.now();\n    const res = await initiateIdentityValidation(window.c2p_adapter).catch(catchErr);\n    benchmark.initiateIdentityValidation = Date.now() - initiateIdentityValidationStart;\n    benchmark.UIUX_to_OTP = Date.now() - startTime;\n    updateBenchmarks();\n\n    if (res.error) {\n      throw new Error(JSON.stringify(res, null, 2));\n    } else if (res !== false) {\n      if (canUseOtpApi() === false) {\n        if (window.otp_listener === false) {\n          console.log('instantiating manual OTP form')\n          window.otp_listener = true;\n\n          async function handler(e) {\n            const otp = utils_gel('otp_value').value;\n            console.log(`OTP submitted [${otp}]`);\n\n            if (otp) {\n              const res = await submitOtp(otp).catch(catchErr);\n              updateBenchmarks();\n\n              if (res) {\n                await afterAuth(window.c2p_adapter, res?.idToken).catch(catchErr);\n                // return res;\n              }\n            } else {\n              catchErr('No OTP value detected.')\n            }\n          };\n\n          const globalHandler = async e => {\n            if (e.srcElement.id === 'otp_submit') {\n              await handler(e);\n            }\n          }\n\n          // show OTP field + button\n          window._manual_otp = true;\n          utils_gel('otp_entry').style.display = 'block';\n          document.addEventListener('click', globalHandler);\n        }\n        return;\n      } else {\n        console.log('--- automatic OTP shown');\n        otpCode = await getOTP(email);\n\n        // manually enter for sandbox+\n        if (!otpCode) {\n          console.log('--- prompt OTP shown');\n          otpCode = await prompt('Enter OTP');\n        }\n        return submitOtp(otpCode);\n      }\n    }\n  }\n\n  console.info('[AUTH_FLOW] consumer not present');\n  return res;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/returning.js\n\n\n\n\n\nconst returningFlow = async (accessToken) => {\n  await afterAuthReturning(window.c2p_adapter, accessToken);\n\n  utils_gel('critical_apis').innerHTML = `Critical API timings: ${(benchmark.init + benchmark.isRecognized + benchmark.getSrcProfile) / 1000}s`;\n  utils_gel('checkout_apis').innerHTML = `Checkout API timings: ${(benchmark.checkout + benchmark.unbind) / 1000}s`;\n  updateBenchmarks();\n\n  utils_gel('done').innerHTML = 'done';\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/start.js\n\n\n\n// import { sleep } from '../helpers/sleep.js';\n\n\n\n\n\n\n\n\n\nconst validateFlow = () => {\n  // manual, don't use helpers here\n  const flowType = qs('input[name=\"flow_selector\"]:checked');\n\n  if (flowType) {\n    return [flowType];\n  }\n\n  catchErr('Select a Flow to start.');\n\n  return [null, null];\n};\n\nconst startFlow = function() {\n  setStartTime();\n  const loadStart = Date.now();\n  resetUi();\n  resetFlow();\n\n  const [flowType] = validateFlow();\n\n  if (flowType) {\n    const sdkUrl = this.value;\n    const key = this.options[this.selectedIndex].innerHTML.trim();\n\n    // update initData from env config\n    autoFillUUID(key);\n\n    if (sdkUrl) {\n      benchmarkState.sdkUrl = sdkUrl;\n      // run(val, userType === 'new_user_flow' ? returningFlow : newUserFlow);\n\n      load_sdk(sdkUrl, async () => {\n        const key = localStorage.getItem('sdk');\n        let accessToken;\n        let consumerPresent;\n\n        // Default selection: Visa is the SRC-i\n        const vcoAdapter = window.vAdapters.VisaSRCI;\n        const adapter = new vcoAdapter();\n\n        window.c2p_adapter = adapter;\n\n        // init\n        await init(adapter, key, loadStart).catch(catchErr);\n        updateBenchmarks();\n\n        // isRecognized\n        accessToken = await isRecognized(adapter).catch(catchErr);\n        updateBenchmarks();\n\n        // identity/auth flow\n        if (!accessToken) {\n          console.info(`recognize 204 - no access token`);\n          consumerPresent = await authFlow(afterAuthReturning, updateBenchmarks).catch(catchErr);\n          updateBenchmarks();\n\n          if (consumerPresent) {\n            // recognized return obj\n            if (consumerPresent.consumerPresent === false) {\n              await afterAuthNewUser(adapter);\n            } else if (consumerPresent.idToken) {\n              await afterAuthReturning(adapter, consumerPresent.idToken);\n            } else {\n              await afterAuthReturning(adapter);\n            }\n          } else {\n            throw new Error('authFlow failure detected');\n          }\n        } else {\n          console.log('[ReturningRecognized] got accessToken', accessToken);\n          returningFlow(accessToken);\n        }\n      });\n    }\n  }\n};\n\n/* harmony default export */ const start = (startFlow);\n\n;// CONCATENATED MODULE: ./benchmark/js/components/sdk-selector/index.js\n\n\n\nconst bindSdkGo = () => {\n  utils_gel('go_v3').onclick = () => {\n    start.call(utils_gel('sdk_picker_v3'));\n  };\n}\n\nconst handleSdkSelection = e => {\n  if (e.target.classList.contains('sdk-picker')) {\n    localStorage.setItem('sdk', e.target.value);\n  }\n};\n\nconst bindSdkSelection = () => {\n  document.addEventListener('change', handleSdkSelection);\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/components/toggle/index.js\n\n\n\nconst toggleHandler = async e => {\n  if (e.target.className.indexOf('toggle-header') > -1) {\n    e.target.parentNode.classList.toggle(\"open\");\n    e.stopPropagation();\n  }\n}\n\nif (!canUseTestCardApi()) {\n  utils_gel('pan_entry').style.display = 'block';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/generate-email-address.js\n\n\n// export default () => `${uuidv4()}@mailinator.com`;\n/* harmony default export */ const generate_email_address = (() => `c2p_${Date.now()}@mailinator.com`);\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/bind-compliance.js\n\n\n\nconst bindComplianceToggle = () => {\n  utils_gel('compliance_toggle').addEventListener('change', e => {\n    if (e.target.checked) {\n      injectComplianceSettings();\n      localStorage.setItem('setCompliance', 'on');\n    } else {\n      removeComplianceSettings();\n      localStorage.setItem('setCompliance', 'off');\n    }\n  });\n\n  if (localStorage.getItem('setCompliance') === 'on') {\n    utils_gel('compliance_toggle').checked = true;\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/event-handlers.js\n\n\n\n\n\n\n\n\n\n\nlet automateTimeout;\nlet automateClickTimeout;\nlet timerInterval;\n\ndocument.body.addEventListener('click', e => {\n  try {\n    toggleHandler(e);\n  } catch (e) {\n    catchErr(e);\n  }\n});\n\nconst handleBubbledEvents = async e => {\n  switch (e.target.id) {\n    case 'add_card_flow':\n    case 'returning_flow':\n      localStorage.setItem('flow_selector', e.target.value);\n      break;\n\n    case 'automate':\n      let timerValue = 30000;\n      if (e.target.checked === true) {\n        localStorage.setItem('automate', 'true');\n        automateClickTimeout = setTimeout(() => {\n          utils_gel('go_v3').click();\n        }, 1000);\n        automateTimeout = setTimeout(() => {\n          window.location.reload();\n        }, timerValue);\n        let displayTimer = timerValue / 1000;\n        timerInterval = setInterval(() => {\n          displayTimer -= 1;\n          utils_gel('timer').innerHTML = `${displayTimer}s until refresh`;\n        }, 1000);\n        document.body.className = 'disable-ui';\n      } else {\n        localStorage.setItem('automate', 'false');\n        clearTimeout(automateClickTimeout);\n        clearTimeout(automateTimeout);\n        clearInterval(timerInterval);\n        utils_gel('timer').innerHTML = ``;\n        document.body.className = '';\n      }\n      break;\n  }\n}\n\n\n\n\nconst handleConfigArea = () => {\n  utils_gel('config').innerHTML = JSON.stringify(initData, null, 2);\n};\n\nconst attachEventHandlers = () => {\n  const lsEmail = localStorage.getItem('email');\n  const automate = localStorage.getItem('automate');\n  const userType = localStorage.getItem('user_flow_selector');\n  const flowType = localStorage.getItem('flow_selector');\n  \n  bindComplianceToggle();\n  bindSdkGo();\n  bindSdkSelection();\n\n  initBinSelector();\n\n\n  // multiselect\n  document.addEventListener('click', e => {\n    if (e.target.tagName === 'OPTION' && e.target.className === 'historical_email_option') {\n      e.target.value && emailSetter(e.target.value);\n    }\n  });\n  \n  // dropdown\n  document.addEventListener('change', e => {\n    if (e.target.tagName === 'SELECT' && e.target.id === 'email_historical') {\n      e.target.value && emailSetter(e.target.value);\n    }\n  });\n\n  // new user\n  utils_gel('new_user').addEventListener('click', () => {\n    const newEmail = generate_email_address();\n    localStorage.setItem('email', newEmail);\n    utils_gel('emailInput').value = newEmail;\n  });\n\n  document.addEventListener('change', e => {\n    handleBubbledEvents(e);\n  });\n\n  if (lsEmail) {\n    emailSetter(lsEmail);\n  }\n\n  if (automate === 'true') {\n    // console.log('automate is true');\n    const cb = utils_gel('automate');\n    cb && (cb.checked = true);\n    const evt = new Event('change', {\n      bubbles: true\n    });\n    cb.dispatchEvent(evt);\n  }\n\n  handleConfigArea();\n\n  if (userType) {\n    qs(`input[value=\"${userType}\"]`) && (qs(`input[value=\"${userType}\"]`).checked = true);\n  }\n  if (flowType) {\n    qs(`input[value=\"${flowType}\"]`) && (qs(`input[value=\"${flowType}\"]`).checked = true);\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/index.ts\n\n\n\nattachEventHandlers();\nbuildSdkPicker();\nsetHistoricalEmails();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksRUFBRSxpQkFBaUIsU0FBUyxTQUFTLEVBQUUsaUJBQWlCLFNBQVM7QUFDckU7QUFDQTtBQUNBLElBQUksRUFBRSxpQkFBaUIsU0FBUyxTQUFTLEVBQUUsaUJBQWlCLFNBQVM7QUFDckU7QUFDQTs7O0FDNUh5RDtBQUNFO0FBQ0Q7QUFDMUQsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvdXRpbHMuanM/M2FiNiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvY29tcGxpYW5jZS1zZXR0aW5ncy5qcz8xOGIyIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvc3R1YnMvZGF0YS5qcz8zMTZjIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9lbWFpbC5qcz9kYjBlIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvdWkvZ2VuZXJhdGUtc2RrLWxpc3QuanM/ZDBmYSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvY2FuLXVzZS10ZXN0LWNhcmRzLWFwaS5qcz83Yjc5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvY29tcG9uZW50cy9jYXJkLWJpbi1zZWxlY3Rvci9pbmRleC5qcz80N2I0Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvc3R1YnMvZW52aXJvbm1lbnQta2V5cy5qcz84NDVhIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9nZXQta2V5cy50cz8xZWM5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvaW5pdC5qcz9jZDJhIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvaXMtcmVjb2duaXplZC5qcz9mMTM3Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9nZXQtcm9vdC1kb21haW4uanM/NGU4NiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2FzeW5jL2xvYWQtc2RrLmpzPzExYmMiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL3VwZGF0ZS1iZW5jaG1hcmtzLmpzPzIyZjUiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL3V1aWQuanM/MjEwMyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL3VpL3Jlc2V0LXVpLmpzP2E0MmUiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2ZldGNoLmpzP2YyNjciLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2dldC1vdHAuanM/Y2E4OSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvY2FuLXVzZS1vdHAtYXBpLmpzPzRjYTYiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9hc3luYy9jaGVja291dC5qcz9jYWFjIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvZ2V0LXNyYy1wcm9maWxlLmpzP2IzMDciLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9hc3luYy91bmJpbmQuanM/OWNmNSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL3N0dWJzL3Bhbi1lbmNyeXB0aW9uLWtleXMuanM/NGI1NiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvZW5jcnlwdC1jYXJkLmpzPzI1ODQiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2dldC12aXNhLWNhcmQuanM/OGE5MyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvZ2V0LXZpc2EtY2FyZC1tYW51YWwuanM/ZTlhMiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2Zsb3dzL2FmdGVyLWF1dGguanM/NTQzYyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2Zsb3dzL2F1dGgtZmxvdy5qcz8yMDRmIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvZmxvd3MvcmV0dXJuaW5nLmpzPzQyNWIiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9mbG93cy9zdGFydC5qcz8zMWExIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvY29tcG9uZW50cy9zZGstc2VsZWN0b3IvaW5kZXguanM/NzQzMSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2NvbXBvbmVudHMvdG9nZ2xlL2luZGV4LmpzPzZkNTciLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2dlbmVyYXRlLWVtYWlsLWFkZHJlc3MuanM/MWVkMiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL3VpL2JpbmQtY29tcGxpYW5jZS5qcz80OTc5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvdWkvZXZlbnQtaGFuZGxlcnMuanM/NjBiYSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2luZGV4LnRzPzhhYTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNlbCA9IHRhZyA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5leHBvcnQgY29uc3QgZ2VsID0gaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuZXhwb3J0IGNvbnN0IGdlY24gPSBjbHMgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbHMpO1xuZXhwb3J0IGNvbnN0IHFzID0gY2xzID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2xzKTtcbmV4cG9ydCBjb25zdCBxc2EgPSBjbHMgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjbHMpO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SG9zdG5hbWUodXJsKSB7XG4gIHZhciBob3N0bmFtZTtcbiAgaWYgKHVybC5pbmRleE9mKFwiLy9cIikgPiAtMSkge1xuICAgIGhvc3RuYW1lID0gdXJsLnNwbGl0KCcvJylbMl07XG4gIH1cbiAgZWxzZSB7XG4gICAgaG9zdG5hbWUgPSB1cmwuc3BsaXQoJy8nKVswXTtcbiAgfVxuICAvL2ZpbmQgJiByZW1vdmUgcG9ydCBudW1iZXJcbiAgaG9zdG5hbWUgPSBob3N0bmFtZS5zcGxpdCgnOicpWzBdO1xuICAvL2ZpbmQgJiByZW1vdmUgXCI/XCJcbiAgaG9zdG5hbWUgPSBob3N0bmFtZS5zcGxpdCgnPycpWzBdO1xuICByZXR1cm4gaG9zdG5hbWU7XG59XG5cbmV4cG9ydCBjb25zdCBjYXRjaEVyciA9IGVyciA9PiB7XG4gIGNvbnNvbGUudHJhY2UoYFtFUlJPUiBDQVVHSFRdYCwgZXJyKTtcbiAgY29uc3QgaGVhZGVyID0gY2VsKCdkaXYnKTtcbiAgY29uc3QgcHJlID0gY2VsKCdwcmUnKTtcbiAgY29uc3QgdHJhY2UgPSBjZWwoJ3ByZScpO1xuICBjb25zdCB0cyA9IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgaGVhZGVyLmlubmVySFRNTCA9IGBbJHt0c31dIGVycm9yIGNhdWdodDpgO1xuICBnZWwoJ2Vycm9yX2xvZycpLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gIFxuICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgdHJhY2UuaW5uZXJIVE1MID0gZXJyLnN0YWNrO1xuICAgIGdlbCgnZXJyb3JfbG9nJykuYXBwZW5kQ2hpbGQodHJhY2UpO1xuICB9IGVsc2Uge1xuICAgIHByZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuICAgIHByZS5pbm5lckhUTUwgPSAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpID8gZXJyIDogSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKTtcbiAgICBnZWwoJ2Vycm9yX2xvZycpLmFwcGVuZENoaWxkKHByZSk7XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBzID0gW107XG5cbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAob2JqW2tleV0gJiYgb2JqW2tleV0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICBvYmpba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHMuam9pbignJicpO1xufTtcbiIsImltcG9ydCB7IGludGVudFBheWxvYWQgfSBmcm9tICcuLi9zdHVicy9kYXRhLmpzJztcblxuZXhwb3J0IGNvbnN0IGluamVjdENvbXBsaWFuY2VTZXR0aW5ncyA9ICgpID0+IHtcbiAgY29uc3QgdGVybXMgPSB7XG4gICAgY29tcGxpYW5jZVR5cGU6IFwiVEVSTVNfQU5EX0NPTkRJVElPTlNcIixcbiAgICB1cmk6IFwidXNhLnZpc2EuY29tL2xlZ2FsL2NoZWNrb3V0L3Rlcm1zLW9mLXNlcnZpY2UuaHRtbFwiLFxuICB9O1xuICBjb25zdCBwcml2YWN5ID0ge1xuICAgIGNvbXBsaWFuY2VUeXBlOiBcIlBSSVZBQ1lfUE9MSUNZXCIsXG4gICAgdXJpOiBcInVzYS52aXNhLmNvbS9sZWdhbC9nbG9iYWwtcHJpdmFjeS1ub3RpY2UuaHRtbFwiLFxuICB9O1xuICBjb25zdCByZW1lbWJlciA9IHtcbiAgICBjb21wbGlhbmNlVHlwZTogXCJSRU1FTUJFUl9NRVwiLFxuICAgIHVyaTogXCJ2aXNhLmNoZWNrb3V0LmNvbS9wcml2YWN5XCIsXG4gIH07XG5cbiAgaW50ZW50UGF5bG9hZC5jb21wbGlhbmNlU2V0dGluZ3MgPSB7XG4gICAgY29tcGxpYW5jZVJlc291cmNlczogW3Rlcm1zLCBwcml2YWN5LCByZW1lbWJlcl1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncyA9ICgpID0+IHtcbiAgZGVsZXRlIGludGVudFBheWxvYWQuY29tcGxpYW5jZVNldHRpbmdzO1xufVxuIiwiaW1wb3J0IHsgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzLCByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MgfSBmcm9tICcuLi9oZWxwZXJzL2NvbXBsaWFuY2Utc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vaGVscGVycy91dGlscyc7XG5cbmV4cG9ydCBsZXQgaW5pdERhdGE7XG5leHBvcnQgbGV0IGludGVudFBheWxvYWQ7XG5cbmV4cG9ydCBjb25zdCBpbml0RGF0YVJvb3QgPSB7XG4gIHNyY2lUcmFuc2FjdGlvbklkOiBcInJlcGxhY2UgbWVcIixcbiAgLy8gc3JjaURwYUlkOiBcIkRQQUlEXCIsXG4gIHNyY0luaXRpYXRvcklkOiBcIltBLUZhLWYwLTl8QS1GYS1mMC05XXs4fVxcXFwtKFtBLUZhLWYwLTl8QS1GYS1mMC05XXs0fVxcXFwtKXszfVtBLUZhLWYwLTl8QS1GYS1mMC05XXsxMn1cIixcbiAgZHBhRGF0YToge1xuICAgIC8vIHNyY0RwYUlkOiBcIlNSQ0RQQUlEXCIsXG4gICAgZHBhUHJlc2VudGF0aW9uTmFtZTogXCJEaXNuZXkgT25saW5lXCIsXG4gICAgZHBhVXJpOiBcImh0dHA6Ly93d3cuZGlzbmV5b25saW5lLmNvbVwiXG4gIH0sXG4gIGRwYVRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIGRwYUxvY2FsZTogXCJVU1wiLFxuICAgIGRwYUFjY2VwdGVkQmlsbGluZ0NvdW50cmllczogW1wiVVNcIixcIkNBXCJdLFxuICAgIGRwYUFjY2VwdGVkU2hpcHBpbmdDb3VudHJpZXM6IFtcIlVTXCIsXCJDQVwiXSxcbiAgICBkcGFCaWxsaW5nUHJlZmVyZW5jZTogXCJGVUxMXCIsXG4gICAgZHBhU2hpcHBpbmdQcmVmZXJlbmNlOiBcIkZVTExcIixcbiAgICBjb25zdW1lck5hbWVSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJFbWFpbEFkZHJlc3NSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJQaG9uZU51bWJlclJlcXVlc3RlZDogdHJ1ZSxcbiAgICBwYXltZW50T3B0aW9uczoge1xuICAgICAgZHBhRHluYW1pY0RhdGFUdGxNaW51dGVzOiAyLFxuICAgICAgZHluYW1pY0RhdGFUeXBlOiBcIkRZTkFNSUNfQ0FSRF9TRUNVUklUWV9DT0RFXCIsXG4gICAgICBkcGFQYW5SZXF1ZXN0ZWQ6IGZhbHNlXG4gICAgfSxcbiAgICByZXZpZXdBY3Rpb246IFwiY29udGludWVcIixcbiAgICB0cmFuc2FjdGlvblR5cGU6IFwiUFVSQ0hBU0VcIixcbiAgICBvcmRlclR5cGU6IFwiUkVBVVRIT1JJWkFUSU9OXCIsXG4gICAgcGF5bG9hZFR5cGVJbmRpY2F0b3I6IFwiU1VNTUFSWVwiLFxuICAgIHRyYW5zYWN0aW9uQW1vdW50OiB7XG4gICAgICB0cmFuc2FjdGlvbkFtb3VudDogXCI5OS45NVwiLFxuICAgICAgdHJhbnNhY3Rpb25DdXJyZW5jeUNvZGU6IFwiVVNEXCJcbiAgICB9LFxuICAgIG1lcmNoYW50T3JkZXJJZDogXCIyOGIxYjYxYi1iYmVjLTQ2MzctYjc4Zi0zM2JhYmMzYjUxODdcIixcbiAgICBtZXJjaGFudENhdGVnb3J5Q29kZTogXCIzMDAwXCIsXG4gICAgbWVyY2hhbnRDb3VudHJ5Q29kZTogXCJVU1wiLFxuICAgIHRocmVlRHNQcmVmZXJlbmNlOiBcIk5PTkVcIixcbiAgICB0aHJlZURzSW5wdXREYXRhOiB7XG4gICAgICByZXF1ZXN0b3JJZDogXCJyZXF1ZXN0b3JJZFwiLFxuICAgICAgYWNxdWlyZXJJZDogXCJhY3F1aXJlcklkXCIsXG4gICAgICBhY3F1aXJlck1pZDogXCJhY3F1aXJlck1pZFwiXG4gICAgfSxcbiAgICBjdXN0b21JbnB1dERhdGE6e1xuICAgICAgY2hlY2tvdXRPcmNoZXN0cmF0b3I6IFwibWVyY2hhbnRcIiwvL1wiVEVTVElOR1wiLCAvLyAnbWVyY2hhbnQnIGlzIGludGVncmF0ZWQgZXhwXG4gICAgICBkcGFJbnRlZ3JhdGlvblR5cGU6IFwiUFNQXCJcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1c2VySW5mbyA9IHtcbiAgaWRlbnRpdHlQcm92aWRlcjogXCJTUkNcIixcbiAgaWRlbnRpdHlWYWx1ZTogXCJzZW50aGlsckBtYWlsaW5hdG9yLmNvbVwiLFxuICB0eXBlOiBcIkVNQUlMXCJcbn07XG5cbmV4cG9ydCBjb25zdCBpbnRlbnRQYXlsb2FkUm9vdCA9IHtcbiAgc3JjQ29ycmVsYXRpb25JZDogXCJcIixcbiAgc3JjaVRyYW5zYWN0aW9uSWQ6IFwiXCIsXG4gIHNyY0RpZ2l0YWxDYXJkSWQ6IFwiXCIsXG4gIGVuY3J5cHRlZENhcmQ6IFwiXCIsXG4gIGlkVG9rZW46IFwiXCIsXG4gIHdpbmRvd1JlZjogXCJcIixcbiAgY29uc3VtZXI6e1xuICAgIGNvbnN1bWVySWRlbnRpdHk6IHtcbiAgICAgIGlkZW50aXR5UHJvdmlkZXI6IFwiU1JDXCIsIFxuICAgICAgaWRlbnRpdHlUeXBlOiBcIkVNQUlMX0FERFJFU1NcIixcbiAgICAgIGlkZW50aXR5VmFsdWU6IFwiYXNob2sudmJveDI4QG1haWxpbmF0b3IuY29tXCJcbiAgICB9LFxuICAgIG1vYmlsZU51bWJlcjoge1xuICAgICAgcGhvbmVOdW1iZXI6IFwiNDE1MzMzNDQ0NFwiLFxuICAgICAgY291bnRyeUNvZGU6IFwiMVwiXG4gICAgfSxcbiAgICBlbWFpbEFkZHJlc3M6IFwiYXNob2sudmJveDI4QG1haWxpbmF0b3IuY29tXCIsXG4gICAgbmF0aW9uYWxJZGVudGlmaWVyOiBcIlVTQVwiLFxuICAgIGNvdW50cnlDb2RlOiBcIlVTXCIsXG4gICAgbGFuZ3VhZ2VDb2RlOiBcIkVOXCIsXG4gICAgZmlyc3ROYW1lOiBcIlBTUFwiLFxuICAgIGxhc3ROYW1lOiBcIlRlc3RlclwiLFxuICAgIGZ1bGxOYW1lOiBcIlBzcCBUZXN0ZXJcIlxuICB9LFxuICBkcGFUcmFuc2FjdGlvbk9wdGlvbnM6IHtcbiAgICBkcGFMb2NhbGU6IFwiVVNcIixcbiAgICBkcGFBY2NlcHRlZEJpbGxpbmdDb3VudHJpZXM6IFtcIlVTXCIsXCJDQVwiXSxcbiAgICBkcGFBY2NlcHRlZFNoaXBwaW5nQ291bnRyaWVzOiBbXCJVU1wiLFwiQ0FcIl0sXG4gICAgZHBhQmlsbGluZ1ByZWZlcmVuY2U6IFwiQUxMXCIsXG4gICAgZHBhU2hpcHBpbmdQcmVmZXJlbmNlOiBcIkFMTFwiLFxuICAgIGNvbnN1bWVyTmFtZVJlcXVlc3RlZDogdHJ1ZSxcbiAgICBjb25zdW1lckVtYWlsQWRkcmVzc1JlcXVlc3RlZDogdHJ1ZSxcbiAgICBjb25zdW1lclBob25lTnVtYmVyUmVxdWVzdGVkOiB0cnVlLFxuICAgIHBheW1lbnRPcHRpb25zOiB7XG4gICAgICBkcGFEeW5hbWljRGF0YVR0bE1pbnV0ZXM6IDIsXG4gICAgICBkeW5hbWljRGF0YVR5cGU6IFwiVEFWVlwiLFxuICAgICAgZHBhUGFuUmVxdWVzdGVkOiBmYWxzZVxuICAgIH0sXG4gICAgcmV2aWV3QWN0aW9uOiBcImNvbnRpbnVlXCIsXG4gICAgY2hlY2tvdXREZXNjcmlwdGlvbjogXCJTYW1wbGUgY2hlY2tvdXRcIixcbiAgICB0cmFuc2FjdGlvblR5cGU6IFwiUFVSQ0hBU0VcIixcbiAgICBvcmRlclR5cGU6IFwiUkVBVVRIT1JJWkFUSU9OXCIsXG4gICAgcGF5bG9hZFR5cGVJbmRpY2F0b3I6IFwiU1VNTUFSWVwiLFxuICAgIHRyYW5zYWN0aW9uQW1vdW50OiB7XG4gICAgICB0cmFuc2FjdGlvbkFtb3VudDogXCI5OS45NVwiLFxuICAgICAgdHJhbnNhY3Rpb25DdXJyZW5jeUNvZGU6IFwiVVNEXCJcbiAgICB9LFxuICAgIG1lcmNoYW50T3JkZXJJZDogXCJBQkMxMjM0NVwiLFxuICAgIG1lcmNoYW50Q2F0ZWdvcnlDb2RlOiBcIm1lcmNoYW50Q2F0ZWdvcnlDb2RlXCIsXG4gICAgbWVyY2hhbnRDb3VudHJ5Q29kZTogXCJVU1wiLFxuICAgIHRocmVlRHNJbnB1dERhdGE6IHtcbiAgICAgIHJlcXVlc3RvcklkOiBcInJlcXVlc3RvcklkXCIsXG4gICAgICBhY3F1aXJlcklkOiBcImFjcXVpcmVySWRcIixcbiAgICAgIGFjcXVpcmVyTWlkOiBcImFjcXVpcmVyTWlkXCJcbiAgICB9LFxuICAgIGN1c3RvbUlucHV0RGF0YTp7XG4gICAgICBkcGFJbnRlZ3JhdGlvblR5cGU6XCJQU1BcIlxuICAgIH1cbiAgfSxcbiAgcGF5bG9hZFR5cGVJbmRpY2F0b3JDaGVja291dDogXCJTVU1NQVJZXCIsXG4gIHJlY2lwaWVudElkQ2hlY2tvdXQ6IFwiXCIsXG4gIHBheWxvYWRUeXBlSW5kaWNhdG9yUGF5bG9hZDogXCJTVU1NQVJZXCIsXG4gIHJlY2lwaWVudElkUGF5bG9hZDogXCJcIixcbiAgYXNzdXJhbmNlRGF0YToge1xuICAgIHZlcmlmaWNhdGlvbkRhdGE6W3tcbiAgICAgIHZlcmlmaWNhdGlvblR5cGU6IFwiQ0FSREhPTERFUlwiLFxuICAgICAgdmVyaWZpY2F0aW9uRW50aXR5OiBcIjAxXCIsXG4gICAgICB2ZXJpZmljYXRpb25NZXRob2Q6IFwiMDFcIixcbiAgICAgIHZlcmlmaWNhdGlvbnJlc3BvbnNlczogXCIwMVwiLFxuICAgICAgdmVyaWZpY2F0aW9uUmVzdWx0czogXCIwMVwiLFxuICAgICAgdmVyaWZpY2F0aW9uVGltZXN0YW1wOiBcIjE2NDY0MTY1NTBcIlxuICAgIH1dXG4gIH0sXG4gIHNyY2lBY3Rpb25Db2RlOiBcIk5FV19VU0VSXCIgXG59O1xuXG5leHBvcnQgbGV0IHNyY1Byb2ZpbGVzID0gW107XG5cbmV4cG9ydCBjb25zdCBiZW5jaG1hcmsgPSB7XG4gIGluaXQ6IDAsXG4gIGlzUmVjb2duaXplZDogMCxcbiAgaWRlbnRpdHlMb29rdXA6IDAsXG4gIGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uOiAwLFxuICBVSVVYX3RvX09UUDogMCxcbiAgY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb246IDAsXG4gIGdldFNyY1Byb2ZpbGU6IDAsXG4gIFVJVVhfdG9fY2FyZExpc3Q6IDAsXG4gIGNoZWNrb3V0OiAwLFxuICBhZGRDYXJkOiAwLFxuICBlbnJvbGxVc2VyOiAwLFxuICB1bmJpbmQ6IDAsXG59O1xuXG5leHBvcnQgY29uc3QgYmVuY2htYXJrU3RhdGUgPSB7XG4gIHNka1VybDogJycsXG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRGbG93ID0gKCkgPT4ge1xuICBjb25zb2xlLmluZm8oJ1JFU0VUJylcbiAgaW5pdERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0RGF0YVJvb3QpO1xuICBpbnRlbnRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZW50UGF5bG9hZFJvb3QpO1xuICBzcmNQcm9maWxlcyA9IFtdO1xufTtcblxuXG5leHBvcnQgY29uc3QgZ2V0SW50ZW50UGF5bG9hZCA9ICgpID0+IHtcbiAgaWYgKCFpbnRlbnRQYXlsb2FkKSB7XG4gICAgaW50ZW50UGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIGludGVudFBheWxvYWRSb290KTtcbiAgfVxuXG4gIGlmIChnZWwoJ2NvbXBsaWFuY2VfdG9nZ2xlJykuY2hlY2tlZCkge1xuICAgIGluamVjdENvbXBsaWFuY2VTZXR0aW5ncygpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncygpO1xuICB9XG5cbiAgcmV0dXJuIGludGVudFBheWxvYWQ7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW50ZW50UGF5bG9hZCA9IHBheWxvYWQgPT4ge1xuICBpbnRlbnRQYXlsb2FkID0gcGF5bG9hZDtcbn1cbiIsImltcG9ydCB7IGNlbCwgZ2VsLCBxc2EgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJJbmZvLCBnZXRJbnRlbnRQYXlsb2FkIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5cbi8vIFRvIGF1dG9maWxsIHRoZSBlbWFpbCBpbiBpZGxvb2t1cCBmaWVsZFxuZXhwb3J0IGZ1bmN0aW9uIGVtYWlsU2V0dGVyKGVtYWlsKSB7XG4gIGlmIChlbWFpbCkge1xuICAgIGNvbnN0IGVtID0gZ2VsKCdlbWFpbElucHV0Jyk7XG4gICAgZW0udmFsdWUgPSBlbWFpbDtcblxuICAgIGF1dG9JZExvb2t1cEVtYWlsQWRkcmVzcyhlbWFpbCk7XG4gICAgYXV0b0ZpbGxFbWFpbEFkZHJlc3NJbkNoZWNrb3V0QXBpcmVxdWVzdChlbWFpbCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEhpc3RvcmljYWxFbWFpbHMoKSB7XG4gIGxldCBlbWFpbEhpc3RvcmljYWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZW1haWxfaGlzdG9yaWNhbCcpO1xuXG4gIGlmIChlbWFpbEhpc3RvcmljYWwpIHtcbiAgICBjb25zdCBoaXN0b3J5ID0gZ2VsKCdlbWFpbF9oaXN0b3JpY2FsJyk7XG4gICAgZW1haWxIaXN0b3JpY2FsID0gSlNPTi5wYXJzZShlbWFpbEhpc3RvcmljYWwpO1xuXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIG5vZGVcbiAgICBxc2EoJyNlbWFpbF9oaXN0b3JpY2FsIG9wdGlvbicpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8ZW1haWxIaXN0b3JpY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3B0aW9uID0gY2VsKCdvcHRpb24nKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGVtYWlsSGlzdG9yaWNhbFtpXTtcbiAgICAgIG9wdGlvbi5jbGFzc05hbWUgPSAnaGlzdG9yaWNhbF9lbWFpbF9vcHRpb24nO1xuICAgICAgb3B0aW9uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVtYWlsSGlzdG9yaWNhbFtpXSkpO1xuXG4gICAgICBoaXN0b3J5LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfVxuICB9XG59XG5cbi8vIHVwZGF0ZSBlbWFpbCBpbiBpZExvb2t1cCBwYXlsb2FkXG5mdW5jdGlvbiBhdXRvSWRMb29rdXBFbWFpbEFkZHJlc3MoZW1haWwpIHtcbiAgbGV0IGVtYWlsSGlzdG9yaWNhbDtcblxuICBpZiAodXNlckluZm8pIHtcbiAgICB1c2VySW5mby5pZGVudGl0eVZhbHVlID0gZW1haWw7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtYWlsJywgZW1haWwpO1xuXG4gICAgZW1haWxIaXN0b3JpY2FsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtYWlsX2hpc3RvcmljYWwnKTtcblxuICAgIGlmICghZW1haWxIaXN0b3JpY2FsKSB7XG4gICAgICBlbWFpbEhpc3RvcmljYWwgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1haWxIaXN0b3JpY2FsID0gSlNPTi5wYXJzZShlbWFpbEhpc3RvcmljYWwpO1xuICAgIH1cblxuICAgIGlmIChlbWFpbEhpc3RvcmljYWwuaW5kZXhPZihlbWFpbCkgPCAwKSB7XG4gICAgICBlbWFpbEhpc3RvcmljYWwucHVzaChlbWFpbCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZW1haWxfaGlzdG9yaWNhbCcsIEpTT04uc3RyaW5naWZ5KGVtYWlsSGlzdG9yaWNhbCkpO1xuICAgICAgc2V0SGlzdG9yaWNhbEVtYWlscygpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUbyBhdXRvZmlsbCB0aGUgZW1haWwgaW4gY2hlY2tvdXQgZmllbGRcbmV4cG9ydCBmdW5jdGlvbiBhdXRvRmlsbEVtYWlsQWRkcmVzc0luQ2hlY2tvdXRBcGlyZXF1ZXN0KGVtYWlsKSB7XG4gIGNvbnN0IGludGVudFBheWxvYWQgPSBnZXRJbnRlbnRQYXlsb2FkKCk7XG4gIFxuICBpZiAoaW50ZW50UGF5bG9hZCkge1xuICAgIGludGVudFBheWxvYWQuY29uc3VtZXIuZW1haWxBZGRyZXNzID0gZW1haWxJbnB1dC52YWx1ZTtcbiAgICBpbnRlbnRQYXlsb2FkLmNvbnN1bWVyLmNvbnN1bWVySWRlbnRpdHkuaWRlbnRpdHlWYWx1ZSA9IGVtYWlsSW5wdXQudmFsdWU7XG4gICAgaW50ZW50UGF5bG9hZC5jb25zdW1lci5tb2JpbGVOdW1iZXIucGhvbmVOdW1iZXIgPSAnNDE1MzMzNDQ0NCc7XG4gIH1cbn1cblxuXG5leHBvcnQgY29uc3Qgc2V0RW1haWxFcnJvck1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gIGdlbCgnZW1haWxfZXJyb3JfbWVzc2FnZScpLmlubmVySFRNTCA9IG1zZztcbn1cblxuLy8gYm9vdHN0cmFwXG5nZWwoJ2VtYWlsSW5wdXQnKS5vbmJsdXIgPSBmdW5jdGlvbiBwb3B1bGF0ZUVtYWlsKCkge1xuICBjb25zdCBlbWFpbCA9IHRoaXMudmFsdWU7XG4gIGVtYWlsU2V0dGVyKGVtYWlsKTtcbn1cbmdlbCgnZW1haWxJbnB1dCcpLm9uZm9jdXMgPSAoKSA9PiB7XG4gIGdlbCgnZW1haWxfZXJyb3JfbWVzc2FnZScpLmlubmVySFRNTCA9ICcnO1xufVxuIiwiaW1wb3J0IHsgY2VsLCBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcblxuY29uc3QgZW52cyA9IHtcbiAgLy8gXCItLS0gUGlja1wiOiBcIlwiLFxuICBRYVBlcmZfRG9ja2VyRUU6IFwiaHR0cHM6Ly9zcmMtcWFwZXJmYi5rOHMtbnAtY2xzMS1wLnRydXN0ZWQudmlzYS5jb21cIixcbiAgUUFXS1NQQ0U6IFwiaHR0cHM6Ly9iMmNwLXZjby1xYWIub2NlLW5wLXNtLWRkcC1wLWVuLnRydXN0ZWQudmlzYS5jb21cIixcbiAgREVWV0tTUENFOiBcImh0dHBzOi8vYjJjcC1yZjEtMjcyLXNraXJvdmEuazhzLW5wLWNsczEtcC50cnVzdGVkLnZpc2EuY29tXCIsXG4gIFFhX09wZW5TaGlmdDogJ2h0dHBzOi8vYjJjcC12Y28tcWEuazhzLW5wLWNsczEtcC50cnVzdGVkLnZpc2EuY29tJyxcbiAgLy8gUWFfRG9ja2VyRUU6ICdodHRwczovL2IyY3AtdmNvLXFhYi5vY2UtbnAtc20tZGRwLXAtZW4udHJ1c3RlZC52aXNhLmNvbScsXG4gIC8vIFFhUGVyZjogXCJodHRwczovL3BlcmYucWEuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tXCIsXG5cbiAgU2FuZEJveDogXCJodHRwczovL3NhbmRib3guc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tXCIsXG4gIC8vIENFUlQ6IFwiaHR0cHM6Ly9jZXJ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyBDRVJUMTogXCJodHRwczovL2NlcnQxLnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyBJQ0w6IFwiaHR0cHM6Ly9kZW1vLmljbC52aXNhLmNvbVwiLFxuICAvLyBRQUlOVDogXCJodHRwczovL2ludC5xYS5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gVmJveDQ0NF9FeHRlcm5hbFNyY2k6IFwiaHR0cHM6Ly92Ym94NDQ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyBWYm94NDQ0X1BTUDogXCJodHRwczovL3Zib3g0NDQuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tXCIsXG4gIC8vIFZib3g0NDRfQWR5ZW46IFwiaHR0cHM6Ly92Ym94NDQ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyB2Ym94T3BlblNoaWZ0X2NocmlzOiBcImh0dHBzOi8vYjJjcC10aW9uLTIzLW1ub2ppbWEuazhzLW5wLWNsczEtcC50cnVzdGVkLnZpc2EuY29tXCIsXG4gIC8vIFZib3gyODogXCJodHRwczovL3Zib3gyOC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gVmJveDQ0MTogXCJodHRwczovL3Zib3g0NDEuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tXCIsXG4gIC8vIFZib3g0NDI6IFwiaHR0cHM6Ly92Ym94NDQyLnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyBWYm94NDQyX0FkeWVuOiBcImh0dHBzOi8vdmJveDQ0Mi5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gVmJveDQ0NF8zRFM6IFwiaHR0cHM6Ly92Ym94NDQ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbVwiLFxuICAvLyBWYm94NDQ0X0NvbnRhaW5lcjogXCJodHRwczovL3NyYy1xYWIuazhzLW5wLWNsczEtcC50cnVzdGVkLnZpc2EuY29tXCIsXG4gIC8vIFZib3g0NDRfQ29udGFpbmVyX0RvY2tlckVFOiBcImh0dHBzOi8vYjJjcC12Y28tcWFiLms4cy1ucC1jbHMxLXAudHJ1c3RlZC52aXNhLmNvbVwiLFxuICAvLyBWYm94NjcxOiBcImh0dHBzOi8vdmJveDY3MS5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbn07XG5cblxuZXhwb3J0IGNvbnN0IGJ1aWxkU2RrUGlja2VyID0gKCkgPT4ge1xuICAvLyBjb25zdCBzZGtTZWxlY3RvciA9IGdlbCgnc2RrX3BpY2tlcl92MScpO1xuICAvLyBjb25zdCBzZGtTZWxlY3Rvcl92MiA9IGdlbCgnc2RrX3BpY2tlcl92MicpO1xuICBjb25zdCBzZGtTZWxlY3Rvcl92Ml9pbnRlZ3JhdGVkID0gZ2VsKCdzZGtfcGlja2VyX3YzJyk7XG4gIGNvbnN0IHN0b3JlZFNkayA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZGsnKTtcbiAgXG4gIGZvciAobGV0IGsgaW4gZW52cykge1xuICAgIC8vIGNvbnN0IG9wdGlvbiA9IGNlbCgnb3B0aW9uJyk7XG4gICAgLy8gb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBgJHtlbnZzW2tdfS9jaGVja291dC13aWRnZXQvcmVzb3VyY2VzL2pzL3NyYy1pLWFkYXB0ZXIvdmlzYVNkay5qc2ApO1xuICAgIC8vIG9wdGlvbi5pbm5lckhUTUwgPSBgJHtrfSBTREt2MWA7XG4gICAgLy8gb3B0aW9uLnNlbGVjdGVkID0gc3RvcmVkU2RrID09PSBgJHtlbnZzW2tdfS9jaGVja291dC13aWRnZXQvcmVzb3VyY2VzL2pzL3NyYy1pLWFkYXB0ZXIvdmlzYVNkay5qc2A7XG4gIFxuICAgIC8vIGNvbnN0IG9wdGlvbl92MiA9IGNlbCgnb3B0aW9uJyk7XG4gICAgLy8gb3B0aW9uX3YyLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBgJHtlbnZzW2tdfS9jaGVja291dC13aWRnZXQvcmVzb3VyY2VzL2pzL3NyYy1pLWFkYXB0ZXIvdmlzYS1zZGsuanNgKVxuICAgIC8vIG9wdGlvbl92Mi5pbm5lckhUTUwgPSBgJHtrfSBTREt2MmA7XG4gICAgLy8gb3B0aW9uX3YyLnNlbGVjdGVkID0gc3RvcmVkU2RrID09PSBgJHtlbnZzW2tdfS9jaGVja291dC13aWRnZXQvcmVzb3VyY2VzL2pzL3NyYy1pLWFkYXB0ZXIvdmlzYS1zZGsuanNgO1xuXG4gICAgY29uc3Qgb3B0aW9uX3YzID0gY2VsKCdvcHRpb24nKTtcbiAgICBvcHRpb25fdjMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGAke2VudnNba119L2NoZWNrb3V0LXdpZGdldC9yZXNvdXJjZXMvanMvc3JjLWktYWRhcHRlci92aXNhLXNkay5qcz92MmApXG4gICAgb3B0aW9uX3YzLmlubmVySFRNTCA9IGAke2t9IFNES3YyIElOVEVHUkFURURgO1xuICAgIG9wdGlvbl92My5zZWxlY3RlZCA9IHN0b3JlZFNkayA9PT0gYCR7ZW52c1trXX0vY2hlY2tvdXQtd2lkZ2V0L3Jlc291cmNlcy9qcy9zcmMtaS1hZGFwdGVyL3Zpc2Etc2RrLmpzP3YyYDtcbiAgXG4gICAgLy8gc2RrU2VsZWN0b3IuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAvLyBzZGtTZWxlY3Rvcl92Mi5hcHBlbmRDaGlsZChvcHRpb25fdjIpO1xuICAgIHNka1NlbGVjdG9yX3YyX2ludGVncmF0ZWQuYXBwZW5kQ2hpbGQob3B0aW9uX3YzKTtcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IGNhblVzZVRlc3RDYXJkQXBpID0gKCkgPT4ge1xuICBzd2l0Y2ggKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkge1xuICAgIC8vIGNhc2UgJ2xvY2FsaG9zdCc6XG4gICAgY2FzZSAnY25vamltYS5naXRodWIuaW8nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzJztcbmltcG9ydCB7IGNhblVzZVRlc3RDYXJkQXBpIH0gZnJvbSAnLi4vLi4vaGVscGVycy9jYW4tdXNlLXRlc3QtY2FyZHMtYXBpJztcblxuY29uc3QgYmlucyA9IHtcbiAgJy0tIDQwMDU1MiAobm9uLXRva2VuaXphYmxlPyknOiAnNDAwNTUyJyxcbiAgJy0tIDQyMDc2NyAodG9rZW5pemFibGUpJzogJzQyMDc2NycsXG4gICctLSA0MTQ3MTggKHRva2VuaXphYmxlKSc6ICc0MTQ3MTgnXG59O1xuXG5leHBvcnQgY29uc3QgaGFuZGxlQmluU2VsZWN0aW9uID0gZSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdiaW5SYW5nZScsIGUudGFyZ2V0LnZhbHVlKTtcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRCaW5TZWxlY3RvciA9ICgpID0+IHtcbiAgY29uc3QgYmluUmFuZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYmluUmFuZ2UnKTtcbiAgY29uc3Qgc2VsZWN0ID0gZ2VsKCdiaW5fcmFuZ2UnKTtcblxuICBmb3IgKGxldCBrIGluIGJpbnMpIHtcbiAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHRpb24udmFsdWUgPSBiaW5zW2tdO1xuICAgIG9wdGlvbi5sYWJlbCA9IGs7XG5cbiAgICBpZiAoYmluUmFuZ2UgPT09IGJpbnNba10pIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH1cblxuICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlQmluU2VsZWN0aW9uKTtcblxuICBpZiAoY2FuVXNlVGVzdENhcmRBcGkoKSkge1xuICAgIGdlbCgnYmluX3NlbGVjdG9yJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH1cbn07XG4iLCJleHBvcnQgY29uc3QgZW52aXJvbm1lbnRLZXlzID0ge1xuICAnUWFQZXJmJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnN0hLRk9TVjlHNTJGUE80VkdCOTIxMWxPMVkzRTVPUF9UdWZNUW15Q2pXSkt5MU42NCcsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnN0hLRk9TVjlHNTJGUE80VkdCOTIxMWxPMVkzRTVPUF9UdWZNUW15Q2pXSkt5MU42NCcsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnUWFQZXJmX0RvY2tlckVFJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnN0hLRk9TVjlHNTJGUE80VkdCOTIxMWxPMVkzRTVPUF9UdWZNUW15Q2pXSkt5MU42NCcsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnN0hLRk9TVjlHNTJGUE80VkdCOTIxMWxPMVkzRTVPUF9UdWZNUW15Q2pXSkt5MU42NCcsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnREVWV0tTUENFJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnUUFXS1NQQ0UnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICczRVk3MjJRVFVQWkNZNVg1QTNJWTIxT0x5NHRlMFpUTzlLQjNQSk1XOXVnZFEzWkFRJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdKNUMwOVhCWkE2Rzg5MUs0RkdHNjExTmlaVmlPM2w5MDVHUHFBMDg4RENFQktrbFprJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcwNzc1MDU5NS1mY2MxLTBkMmUtNzM4OC0xMWM1NzY5ZTAyMDEnXG4gIH0sXG4gICdWYm94NDQ0X0NvbnRhaW5lcic6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJzA3NzUwNTk1LWZjYzEtMGQyZS03Mzg4LTExYzU3NjllMDIwMSdcbiAgfSxcbiAgJ1Zib3g0NDRfRXh0ZXJuYWxTcmNpJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0NF9BZHllbic6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzhZUFc0U0hERlg1VkxaOE1MSERCMjE4V2x2QXdNNHoyUGcxcl9EcFpZOGxOYWliZWMnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3g0NDRfUFNQJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnVEMwM1VPNzg0WVlVSVIzQkFOVUcxMVdFMnBRRVdncjVQcHVJVmJVWkZCX29aTE9jbycsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0NF8zRFMnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICc4WVBXNFNIREZYNVZMWjhNTEhEQjIxOFdsdkF3TTR6MlBnMXJfRHBaWThsTmFpYmVjJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdKNUMwOVhCWkE2Rzg5MUs0RkdHNjExTmlaVmlPM2w5MDVHUHFBMDg4RENFQktrbFprJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICdhYjFhNGU2Zi05NTZjLWE3OTMtNzIxZi0xMzMzMzZkYzI3MCdcbiAgfSxcbiAgJ1FBSU5UJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnRDI1N0dDQU9SM0pHUFRHQUNPTjgxMWhONW9kQnRCYVcwWjE4T25YaDNiaHdGdUgxOCcsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnRDI1N0dDQU9SM0pHUFRHQUNPTjgxMWhONW9kQnRCYVcwWjE4T25YaDNiaHdGdUgxOCcsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnQ0VSVCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNXUVJHVVNZNkNFU0pTMktRU1c4MTFKWHg5UDFKTHMyRHJiT0txVTlFWGJmanJlVW8nLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJzNXUVJHVVNZNkNFU0pTMktRU1c4MTFKWHg5UDFKTHMyRHJiT0txVTlFWGJmanJlVW8nLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ0NFUlQxJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnQjhWRjNHNTQ0TUs5MFBNUUFHM0kxMW5SLWVXUW1qM3VoZnM5ZFFYUEVkamJtcnBmbycsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnTDlBOEFDVzREQ1RLODNVMlQ0U0IxMU5oUXBWa3A3bUFoOU50bk41bXMwd1l1N3dvMCcsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnU2FuZEJveCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJ1Y2WVBMMERGSjJWNTZISUg2UTNGMTMzZmJaV3lBeUlIaldWU2VjeDZLTUY2aVRIR00nLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ1Y2WVBMMERGSjJWNTZISUg2UTNGMTMzZmJaV3lBeUlIaldWU2VjeDZLTUY2aVRIR00nLFxuICAgIHNyY2lEcGFJZDogJ21hdGVzdGRwYTInLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0NF9Db250YWluZXJfRG9ja2VyRUUnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICczRVk3MjJRVFVQWkNZNVg1QTNJWTIxT0x5NHRlMFpUTzlLQjNQSk1XOXVnZFEzWkFRJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdKNUMwOVhCWkE2Rzg5MUs0RkdHNjExTmlaVmlPM2w5MDVHUHFBMDg4RENFQktrbFprJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdRYV9PcGVuU2hpZnQnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICczRVk3MjJRVFVQWkNZNVg1QTNJWTIxT0x5NHRlMFpUTzlLQjNQSk1XOXVnZFEzWkFRJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdKNUMwOVhCWkE2Rzg5MUs0RkdHNjExTmlaVmlPM2w5MDVHUHFBMDg4RENFQktrbFprJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcwNzc1MDU5NS1mY2MxLTBkMmUtNzM4OC0xMWM1NzY5ZTAyMDEnXG4gIH0sXG4gICdRYV9Eb2NrZXJFRSc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJzA3NzUwNTk1LWZjYzEtMGQyZS03Mzg4LTExYzU3NjllMDIwMSdcbiAgfVxufTtcbiIsImltcG9ydCB7IGVudmlyb25tZW50S2V5cyB9IGZyb20gJy4uL3N0dWJzL2Vudmlyb25tZW50LWtleXMuanMnO1xudmFyIGdldEZyb21Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuZXhwb3J0IHZhciBnZXRNZXJjaGFudEFwaUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEZyb21Mb2NhbFN0b3JhZ2UoJ21lcmNoYW50QXBpS2V5cycpO1xufTtcbmV4cG9ydCB2YXIgZ2V0RW52aXJvbm1lbnRLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRGcm9tTG9jYWxTdG9yYWdlKCdlbnZpcm9ubWVudEtleXMnKTtcbn07XG5leHBvcnQgdmFyIGdldEVuY3J5cHRpb25LZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRGcm9tTG9jYWxTdG9yYWdlKCdrZXlzJyk7XG59O1xuZXhwb3J0IHZhciBnZXRFbnZpcm9ubWVudCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW52S2V5cyA9IChlbnZpcm9ubWVudEtleXMpID8gZW52aXJvbm1lbnRLZXlzIDogZ2V0RW52aXJvbm1lbnRLZXlzKCk7XG4gICAgdmFyIGdlbmVyaWNLZXkgPSBrZXkucmVwbGFjZSgvU0RLdlswLTldLiokL2ksICcnKS50cmltKCk7XG4gICAgaWYgKGVudktleXNbZ2VuZXJpY0tleV0pIHtcbiAgICAgICAgcmV0dXJuIGVudktleXNbZ2VuZXJpY0tleV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmV4cG9ydCB2YXIgZ2V0TWVyY2hhbnRBcGlLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudiA9IGdldEVudmlyb25tZW50KGtleSk7XG4gICAgaWYgKGVudilcbiAgICAgICAgcmV0dXJuIGVudi5zcmNJbml0aWF0b3JJZDtcbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCJpbXBvcnQgeyBjYXRjaEVyciwgZ2VsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJlbmNobWFyaywgaW5pdERhdGEgfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuaW1wb3J0IHsgZ2V0TWVyY2hhbnRBcGlLZXkgfSBmcm9tICcuLi9oZWxwZXJzL2dldC1rZXlzLnRzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXQoYWRhcHRlciwga2V5LCBzdGFydFRpbWUpIHtcbiAgY29uc29sZS5sb2coJ1tJTklUXSBzdGFydCcpO1xuICBjb25zdCBhcGlrZXkgPSBnZXRNZXJjaGFudEFwaUtleShrZXkpO1xuICBpZiAoYXBpa2V5KSB7XG4gICAgaW5pdERhdGEuYXBpa2V5ID0gYXBpa2V5O1xuICB9XG5cbiAgY29uc29sZS5sb2coJ1tJTklUX0RBVEFdJywgaW5pdERhdGEpO1xuXG4gIGF3YWl0IGFkYXB0ZXIuaW5pdChpbml0RGF0YSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBiZW5jaG1hcmsuaW5pdCA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgY29uc29sZS5sb2coYFtpbml0XSB0dGFrZW46ICR7KGJlbmNobWFyay5pbml0KX1tc2AsIHJlc3BvbnNlKTtcblxuICAgIGlmICghT2JqZWN0LmtleXMocmVzcG9uc2UpLmxlbmd0aCkge1xuICAgICAgZ2VsKCdpbml0X2NvbXBsZXRlJykuY2hlY2tlZCA9IHRydWU7XG4gICAgICBnZWwoJ2luaXRfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7KGJlbmNobWFyay5pbml0KX1tc2A7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLCBudWxsLCAyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2luaXQgZmFpbGVkLCBjaGVjayBjb25zb2xlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9KS5jYXRjaChjYXRjaEVycik7XG59XG4iLCJcbmltcG9ydCB7IGNhdGNoRXJyLCBnZWwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlscy5qc1wiO1xuaW1wb3J0IHsgYmVuY2htYXJrIH0gZnJvbSBcIi4uL3N0dWJzL2RhdGEuanNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzUmVjb2duaXplZChhZGFwdGVyKSB7XG4gIGNvbnNvbGUubG9nKCdbUkVDT0dOSVpFXSBzdGFydCcpO1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIGxldCB0b2tlbjtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmlzUmVjb2duaXplZCgpLmNhdGNoKGNhdGNoRXJyKTtcbiAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG5cbiAgYmVuY2htYXJrLmlzUmVjb2duaXplZCA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgZ2VsKCdpc19yZWNvZ25pemVkX2NvbXBsZXRlJykuY2hlY2tlZCA9IHRydWU7XG4gIGdlbCgnaXNfcmVjb2duaXplZF9jb21wbGV0ZV90aW1pbmcnKS5pbm5lckhUTUwgPSBgJHtiZW5jaG1hcmsuaXNSZWNvZ25pemVkfW1zYDtcblxuICBpZiAocmVzcG9uc2UuaWRUb2tlbnMpIHtcbiAgICB0b2tlbiA9IHJlc3BvbnNlLmlkVG9rZW5zWzBdO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLnJlY29nbml6ZWQgPT09IGZhbHNlKSB7XG4gICAgZ2VsKCdpc19yZWNvZ25pemVkX2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAke2JlbmNobWFyay5pc1JlY29nbml6ZWR9bXMgKHVucmVjb2duaXplZClgO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLCBudWxsLCAyKSk7XG4gIH1cblxuICBjb25zb2xlLmxvZyhgW3JlY29nbml6ZWRdIHR0YWtlbjogJHsoYmVuY2htYXJrLmlzUmVjb2duaXplZCl9bXNgKTtcbiAgcmV0dXJuIHRva2VuO1xufVxuIiwiLypcbiAgY2Fubm90IGltcG9ydCB1dGlsIGZyb20gdmlzYS1zZGs7IGNvcGllZCB1dGlsIG92ZXIgZm9yIG5vd1xuKi9cblxuXG4vLyBUaGlzIGR1bW15IFVSTCBpcyB1cGRhdGVkIGJ5IGEgZGVwbG95IHNjcmlwdCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuIEUuZy5cbi8vIHdoZW4gZGVwbG95aW5nIHRvIHByb2R1Y3Rpb24sIENJIHJlcGxhY2VzIGRldi53d3cudi5tZSB3aXRoXG4vLyBzZWN1cmUuY2hlY2tvdXQudmlzYS5jb20sIGJ1dCB3aGVuIGRlcGxveWluZyB0byBjZXJ0LCBpdCB3aWxsIGJlXG4vLyBjZXJ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbS5cbmV4cG9ydCBjb25zdCBTVEFUSUNfUk9PVF9ET01BSU4gPSAnaHR0cHM6Ly9kZXYud3d3LnYubWUnO1xuXG5jb25zdCBzZGtTY3JpcHRSZWdleCA9XG4gIC9eaHR0cHM6XFwvXFwvW1xcdy1cXC5dK1xcLj9cXC52aXNhXFwuY29tXFwvY2hlY2tvdXRcXC13aWRnZXRcXC9yZXNvdXJjZXNcXC9qc1xcL3NyYy1pLWFkYXB0ZXJcXC92aXNhW1xcLXNTXXsxLDJ9ZGtcXC5qcy87XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTREtTY3JpcHRFbCgpIHtcbiAgY29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpO1xuXG4gIGZvciAoY29uc3Qgc2NyaXB0IG9mIHNjcmlwdHMpIHtcbiAgICBpZiAoc2NyaXB0LnNyYy5tYXRjaChzZGtTY3JpcHRSZWdleCkpIHtcbiAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGFzc2V0c01hcCA9IHtcbiAgJy8vYXNzZXRzLnNlY3VyZS5jaGVja291dC52aXNhLmNvbSc6ICcvL3NlY3VyZS5jaGVja291dC52aXNhLmNvbScsXG4gICcvL2NlcnQtYXNzZXRzLnNlY3VyZS5jaGVja291dC52aXNhLmNvbSc6ICcvL2NlcnQuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tJyxcbiAgJy8vc2FuZGJveC1hc3NldHMuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tJzogJy8vc2FuZGJveC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nXG59O1xuXG5mdW5jdGlvbiBtYXBBc3NldHNVcmwodXJsKSB7XG4gIGNvbnN0IGFzc2V0RG9tYWlucyA9IE9iamVjdC5rZXlzKGFzc2V0c01hcCk7XG5cbiAgZm9yIChjb25zdCBhc3NldERvbWFpbiBvZiBhc3NldERvbWFpbnMpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoYXNzZXREb21haW4pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKGFzc2V0RG9tYWluLCBhc3NldHNNYXBbYXNzZXREb21haW5dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG4vLyBSb290IGRvbWFpbiBpcyB1cGRhdGVkIGJ5IGEgZGVwbG95IHNjcmlwdCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuIEUuZy5cbi8vIHdoZW4gZGVwbG95aW5nIHRvIHByb2R1Y3Rpb24sIENJIHJlcGxhY2VzIGRldi53d3cudi5tZSB3aXRoXG4vLyBzZWN1cmUuY2hlY2tvdXQudmlzYS5jb20sIGJ1dCB3aGVuIGRlcGxveWluZyB0byBjZXJ0LCBDSSB1c2VzXG4vLyBjZXJ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbS5cbmNvbnN0IGR1bW15VXJsSGFzaCA9ICdhSFIwY0hNNkx5OWtaWFl1ZDNkM0xuWXViV1UnOyAvLyBidG9hKCdodHRwczovL2Rldi53d3cudi5tZScpXG5jb25zdCB3YXNEdW1teVVybFJlcGxhY2VkID0gU1RBVElDX1JPT1RfRE9NQUlOICE9PSB3aW5kb3cuYXRvYihkdW1teVVybEhhc2gpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSb290RG9tYWluKCkge1xuICBpZiAod2FzRHVtbXlVcmxSZXBsYWNlZCkge1xuICAgIHJldHVybiBTVEFUSUNfUk9PVF9ET01BSU47XG4gIH1cblxuICAvLyBJbiBjb250YWluZXIgZGVwbG95bWVudHMsIHRoZSBkdW1teSB1cmwgbWF5IG5vdCBoYXZlIGJlZW4gcmVwbGFjZWQuIEluIHRoaXNcbiAgLy8gY2FzZSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgZW52aXJvbm1lbnQgdXJsIGZyb20gdGhlIHZpc2FTZGsuanMgc2NyaXB0IHRhZy5cblxuICBjb25zdCBzZGtTY3JpcHRFbCA9IGdldFNES1NjcmlwdEVsKCk7XG5cbiAgaWYgKHNka1NjcmlwdEVsKSB7XG4gICAgcmV0dXJuIG1hcEFzc2V0c1VybChzZGtTY3JpcHRFbC5zcmMuc3BsaXQoJy8nLCAzKS5qb2luKCcvJykpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byB0aGUgcHJvZCBVUkwgZm9yIGFueSBhYm5vcm1hbCBpbnRlZ3JhdGlvbi5cbiAgcmV0dXJuICdodHRwczovL3NlY3VyZS5jaGVja291dC52aXNhLmNvbSc7XG59XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldFNES1NjcmlwdEVsIH0gZnJvbSAnLi4vaGVscGVycy9nZXQtcm9vdC1kb21haW4uanMnO1xuXG5jb25zdCBsb2FkU2RrID0gKHNka1VybCwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgbG9hZFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbGV0IHNka01vdW50ID0gZ2V0U0RLU2NyaXB0RWwoKTtcbiAgbGV0IHRhZztcblxuICBpZiAoc2RrTW91bnQpIHtcbiAgICBjb25zb2xlLmluZm8oJz4+Pj4gcmVtb3ZpbmcgPHNjcmlwdCAvPiB0YWcgZnJvbSBwcmlvciBsb2FkJyk7XG4gICAgc2RrTW91bnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZGtNb3VudCk7XG4gIH1cblxuICB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICB0YWcuc3JjID0gc2RrVXJsO1xuICB0YWcudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICB0YWcuYXN5bmMgPSBmYWxzZTtcbiAgdGFnLm9ubG9hZCA9ICgpID0+IHtcbiAgICBjYWxsYmFjayhsb2FkU3RhcnQpLmNhdGNoKGVyciA9PiB7XG4gICAgICBnZWwoJ2Vycm9yX2xvZycpLmlubmVySFRNTCA9IGVycjtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gIChoZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWRTZGs7XG4iLCJpbXBvcnQgeyBiZW5jaG1hcmsgfSBmcm9tICcuLi9zdHVicy9kYXRhLmpzJztcbmltcG9ydCB7IGdlbCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBsZXQgc3RhcnRUaW1lO1xuXG5leHBvcnQgY29uc3Qgc2V0U3RhcnRUaW1lID0gKCkgPT4gc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUJlbmNobWFya3MgPSAoKSA9PiBnZWwoJ2JlbmNobWFya19kYXRhJykudmFsdWUgPSBKU09OLnN0cmluZ2lmeShiZW5jaG1hcmssIG51bGwsIDIpO1xuIiwiaW1wb3J0IHsgaW5pdERhdGEsIGdldEludGVudFBheWxvYWQgfSBmcm9tICcuLi9zdHVicy9kYXRhLmpzJztcbmltcG9ydCB7IGdldEVudmlyb25tZW50IH0gZnJvbSAnLi9nZXQta2V5cy50cyc7XG5cbi8vIE1ldGhvZCB0byBnZW5lcmF0ZSByYW5kb20gVVVJRFxuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5cbi8vIFRvIGF1dG9maWxsIFVVSUQgb24gZXZlcnkgcGFnZSByZWZyZXNoXG5leHBvcnQgZnVuY3Rpb24gYXV0b0ZpbGxVVUlEKGtleSkge1xuICBjb25zdCBpbnRlbnRQYXlsb2FkID0gZ2V0SW50ZW50UGF5bG9hZCgpO1xuICBjb25zdCBzcmNpVHJhbnNhY3Rpb25JZCA9IHV1aWR2NCgpO1xuICBjb25zdCBlbnYgPSBnZXRFbnZpcm9ubWVudChrZXkpO1xuICBpbml0RGF0YS5zcmNpVHJhbnNhY3Rpb25JZCA9IHNyY2lUcmFuc2FjdGlvbklkO1xuICBpbnRlbnRQYXlsb2FkLnNyY2lUcmFuc2FjdGlvbklkID0gc3JjaVRyYW5zYWN0aW9uSWQ7XG5cbiAgY29uc3QgYmFkID0gWydzcmNEcGFJZCcsICdwYW5FbmNyeXB0aW9uSWQnXTtcbiAgZm9yIChsZXQgayBpbiBlbnYpIHtcbiAgICBpZiAoYmFkLmluZGV4T2YoaykgPT09IC0xKVxuICAgICAgaW5pdERhdGFba10gPSBlbnZba107XG4gIH1cbn1cbiIsImltcG9ydCB7IHFzYSwgZ2VsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHMuanNcIlxuaW1wb3J0IHsgYmVuY2htYXJrIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5cbmNvbnN0IHRhcmdldHMgPSBbXG4gICdpbml0X2NvbXBsZXRlJywgJ2lzX3JlY29nbml6ZWRfY29tcGxldGUnLCAnYXV0aF9jb21wbGV0ZScsICdnZXRfc3JjX3Byb2ZpbGVfY29tcGxldGUnLCAnY2hlY2tvdXRfY29tcGxldGUnLCAndW5iaW5kX2NvbXBsZXRlJ1xuXTtcblxuZXhwb3J0IGNvbnN0IHJlc2V0VWkgPSAoKSA9PiB7XG4gIHRhcmdldHMuZm9yRWFjaChpZCA9PiB7XG4gICAgZ2VsKGlkKS5jaGVja2VkID0gZmFsc2U7XG4gICAgZ2VsKGAke2lkfV90aW1pbmdgKS5pbm5lckhUTUwgPSAnJztcbiAgfSk7XG5cbiAgQXJyYXkocXNhKCcubWVzc2FnaW5nJykpLmZvckVhY2goZWwgPT4ge1xuICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICB9KTtcblxuICBnZWwoJ2F1dGhfYnJlYWtkb3duJykuaW5uZXJIVE1MID0gJyc7XG4gIGdlbCgnZXJyb3JfbG9nJykuaW5uZXJIVE1MID0gJyc7XG4gIGdlbCgnYmVuY2htYXJrX2RhdGEnKS52YWx1ZSA9ICcnO1xuICBnZWwoJ290cF9lbnRyeScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgZm9yIChsZXQgayBpbiBiZW5jaG1hcmspIHtcbiAgICBiZW5jaG1hcmtba10gPSAwO1xuICB9XG59XG4iLCJjb25zdCBnZW5JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbmV4cG9ydCBjb25zdCBzeXN0ZW1Db3JyZWxhdGlvbklkID0gYDFfMTQ5MjU2MTExMV83NjZfNDhfJHtnZW5JZCgpfV9DSEVDS09VVC1XSURHRVRgO1xuZXhwb3J0IGNvbnN0IHN5c3RlbVNlc3Npb25JZCA9IGB2bWVfcWFfMDAxJHtnZW5JZCgpfWA7XG5cbmV4cG9ydCB2YXIgZmV0Y2hSZXEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIGJvZHksXG4gICAgbWV0aG9kLFxuICAgIGhlYWRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGhlYWRlcnNbJ1gtQ09SUkVMQVRJT04tSUQnXSA9IHN5c3RlbUNvcnJlbGF0aW9uSWQ7XG4gIGhlYWRlcnNbJ2RmcFNlc3Npb25JZCddID0gc3lzdGVtU2Vzc2lvbklkO1xuICBoZWFkZXJzWydYLVRITUlEJ10gPSBzeXN0ZW1TZXNzaW9uSWQ7XG5cbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgbGV0IGZpbmFsQm9keSA9IHt9O1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygneC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcbiAgICBmaW5hbEJvZHkgPSBzZXJpYWxpemVPYmplY3QoYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgZmluYWxCb2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gIH1cbiAgcmV0dXJuIGZldGNoKFxuICAgICAgdXJsLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBib2R5OiBmaW5hbEJvZHksXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICBtZXRob2RcbiAgICAgIH0pXG4gICAgKVxuICAgIC50aGVuKHJlcyA9PiBoYW5kbGVKc29uUmVzcG9uc2UocmVzKSlcbiAgICAudGhlbihkYXRhID0+IGRhdGEpXG4gICAgLmNhdGNoKGVycm9yID0+IHtyZXR1cm4gZXJyb3J9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1dWlkdjQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxuICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlSnNvblJlc3BvbnNlKHJlcykge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIHJlcy5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICBoZWFkZXJzW2tdID0gdjtcbiAgfSk7XG4gIC8vIGNvbnNvbGUubG9nKCdoZWFkZXJzIC0gJyArIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpKTtcbiAgcmV0dXJuIChcbiAgICByZXNcbiAgICAuanNvbigpXG4gICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdkYXRhJywgZGF0YSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICB9XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgfVxuICAgIH0pKVxufTtcblxuXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHMgPSBbXTtcblxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChvYmpba2V5XSAmJiBvYmpba2V5XS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIG9ialtrZXldLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHMucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcy5qb2luKCcmJyk7XG59O1xuIiwiaW1wb3J0IHsgYmVuY2htYXJrU3RhdGUgfSBmcm9tICcuLi9zdHVicy9kYXRhLmpzJztcbmltcG9ydCB7IGZldGNoUmVxLCBoYW5kbGVKc29uUmVzcG9uc2UgfSBmcm9tICcuL2ZldGNoLmpzJztcbmltcG9ydCB7IGV4dHJhY3RIb3N0bmFtZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5sZXQgaXNRQVBlcmYgPSBmYWxzZTtcbmNvbnN0IHVzZVByb3h5ID0gdHJ1ZTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9UUChlbWFpbCkge1xuICBjb25zb2xlLmluZm8oJ0BnZXRPVFAgLSBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIE9UUCBjb2RlIHZpYSBBUEknKTtcblxuICBpc1FBUGVyZiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZGsnKS5pbmRleE9mKCdxYXBlcmYnKSA+IC0xO1xuXG4gIGlmIChpc1FBUGVyZikge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvaWQ/ZW1haWw9JHtlbWFpbH1gKS50aGVuKGhhbmRsZUpzb25SZXNwb25zZSk7XG5cbiAgICBpZiAocmVzLmRhdGEudXVpZCkge1xuICAgICAgLy8gc2hhMjU2IGhhc2ggb2YgVVVJRCArIGVtYWlsXG4gICAgICAvLyBubyB0cmFuc3BpbGUgb2Ygbm9kZSBjb2RlLCBsZXZlcmFnZSBzaW1wbGUgQVBJXG4gICAgICBjb25zdCBoYXNoID0gYXdhaXQgZmV0Y2goYC9zaGE/cz0ke3Jlcy5kYXRhLnV1aWR9JHtlbWFpbC50b0xvd2VyQ2FzZSgpfWApLnRoZW4oaGFuZGxlSnNvblJlc3BvbnNlKTtcbiAgICAgIC8vIGJhc2U2NCBlbmNvZGUgc2hhc3VtXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBidG9hKGhhc2guZGF0YS5zaGEyNTYpO1xuICAgICAgICBjb25zdCBvdHBCb2R5ID0gYXdhaXQgZmV0Y2goYC9vdHA/ZW5jcnlwdGVkPSR7ZW5jcnlwdGVkfWApLnRoZW4oaGFuZGxlSnNvblJlc3BvbnNlKTtcbi8vIGNvbnNvbGUubG9nKCdvdHAnLCBvdHBCb2R5KTtRXG5cbiAgICAgICAgaWYgKG90cEJvZHkuZGF0YS5vdHBWYWx1ZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBnb3QgT1RQIHZhbHVlIFske290cEJvZHkuZGF0YS5vdHBWYWx1ZX1dYCk7XG4gICAgICAgICAgcmV0dXJuIG90cEJvZHkuZGF0YS5vdHBWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPVFAgZmV0Y2ggZmFpbGVkYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCB0b2tlbjtcbiAgICBjb25zdCBwcm94eSA9IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3RuYW1lfToke3dpbmRvdy5sb2NhdGlvbi5wb3J0fS9wcm94eWA7XG4gICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vdmJveDY3MS5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20vc3Jjc2RrdGVzdGVyL2dlbmVyYXRlT3RwJztcbiAgXG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBleHRyYWN0SG9zdG5hbWUoYmVuY2htYXJrU3RhdGUuc2RrVXJsKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkVudmlyb25tZW50OlwiLCBlbnZpcm9ubWVudCk7XG4gIFxuICAgIC8vIE1ha2UgaW5kaXJlY3QgY2FsbCB0byBnZXQgT1RQXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IHVzZVByb3h5ID8gYCR7cHJveHl9P3VybD0ke3VybH1gIDogdXJsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnLFxuICAgICAgICAnZW52bic6IGVudmlyb25tZW50LFxuICAgICAgICAnZW1haWwnOiBlbWFpbCxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hSZXEob3B0aW9ucykuY2F0Y2goZXJyID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldE9UUCBlcnJvcjonLCBlcnIpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZGF0YS5vdHBWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhLm90cFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYGNvdWxkIG5vdCBhdXRvZ2V0IE9UUCBjb2RlIGZyb20gWyR7dXJsfV1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsIlxuZXhwb3J0IGNvbnN0IGNhblVzZU90cEFwaSA9ICgpID0+IHtcbiAgY29uc3QgaG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIChob3N0bmFtZS5pbmRleE9mKCdnaXRodWInKSA+IC0xKTpcbiAgICBjYXNlIChob3N0bmFtZS5pbmRleE9mKCdoZXJva3UnKSA+IC0xKTpcbiAgICBjYXNlIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2RrJykuaW5kZXhPZigncWFwZXJmJykgPiAtMSk6XG4gICAgLy8gY2FzZSAoaG9zdG5hbWUuaW5kZXhPZignbG9jYWxob3N0JykgPiAtMSk6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBhdXRvRmlsbEVtYWlsQWRkcmVzc0luQ2hlY2tvdXRBcGlyZXF1ZXN0IH0gZnJvbSAnLi4vaGVscGVycy9lbWFpbC5qcyc7XG5pbXBvcnQgeyBiZW5jaG1hcmssIGdldEludGVudFBheWxvYWQgfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tvdXQoYWRhcHRlcikge1xuICBjb25zdCBpbnRlbnRQYXlsb2FkID0gZ2V0SW50ZW50UGF5bG9hZCgpO1xuICBjb25zb2xlLmxvZygnW0NIRUNLT1VUXSBzdGFydCcpO1xuICBjb25zdCBlbWFpbCA9IGdlbCgnZW1haWxJbnB1dCcpLnZhbHVlO1xuICBhdXRvRmlsbEVtYWlsQWRkcmVzc0luQ2hlY2tvdXRBcGlyZXF1ZXN0KGVtYWlsKTtcblxuICBjb25zb2xlLmxvZygnLS0gaW50ZW50IHBheWxvYWQnLCBpbnRlbnRQYXlsb2FkKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmNoZWNrb3V0KGludGVudFBheWxvYWQpO1xuICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBiZW5jaG1hcmsuY2hlY2tvdXQgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gIGNvbnNvbGUubG9nKGBbY2hlY2tvdXRdIHR0YWtlbjogJHsoYmVuY2htYXJrLmNoZWNrb3V0KX1tc2ApO1xuICBcbiAgaWYgKHJlc3BvbnNlLmVycm9yIHx8IHJlc3BvbnNlWydyZWFzb24nXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICB9IGVsc2Uge1xuICAgIGdlbCgnY2hlY2tvdXRfY29tcGxldGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICBnZWwoJ2NoZWNrb3V0X2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAkeyhiZW5jaG1hcmsuY2hlY2tvdXQpfW1zYDtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59XG4iLCJcbmltcG9ydCB7IGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBiZW5jaG1hcmssIGdldEludGVudFBheWxvYWQsIHNyY1Byb2ZpbGVzIH0gZnJvbSBcIi4uL3N0dWJzL2RhdGEuanNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNyY1Byb2ZpbGUoYWRhcHRlciwgYXV0aFRva2VuKSB7XG4gIGNvbnNvbGUubG9nKCdbR0VUX1NSQ19QUk9GSUxFXSBzdGFydCcpO1xuICBjb25zdCBpbnRlbnRQYXlsb2FkID0gZ2V0SW50ZW50UGF5bG9hZCgpO1xuXG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWRhcHRlci5nZXRTcmNQcm9maWxlKGF1dGhUb2tlbik7XG4gIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICBiZW5jaG1hcmsuZ2V0U3JjUHJvZmlsZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gIGNvbnNvbGUubG9nKGBbZ2V0U3JjUHJvZmlsZV0gdHRha2VuOiAkeyhiZW5jaG1hcmsuZ2V0U3JjUHJvZmlsZSl9bXNgKTtcblxuICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpKTtcbiAgfSBlbHNlIGlmIChyZXNwb25zZVsncmVhc29uJ10pIHtcbiAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBnZXQgY2FyZCBsaXN0OiAlbycsIHJlc3BvbnNlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpKTtcbiAgfSBlbHNlIHtcbiAgICBnZWwoJ2dldF9zcmNfcHJvZmlsZV9jb21wbGV0ZScpLmNoZWNrZWQgPSB0cnVlO1xuICAgIGdlbCgnZ2V0X3NyY19wcm9maWxlX2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAkeyhiZW5jaG1hcmsuZ2V0U3JjUHJvZmlsZSl9bXNgO1xuICB9XG5cbiAgcmVzcG9uc2UucHJvZmlsZXMuZm9yRWFjaChwcm9maWxlID0+IHNyY1Byb2ZpbGVzLnB1c2gocHJvZmlsZSkpO1xuXG4gIC8vIHNldCBmaXJzdCBjYXJkXG4gIHRyeSB7XG4gICAgaW50ZW50UGF5bG9hZC5zcmNEaWdpdGFsQ2FyZElkID0gc3JjUHJvZmlsZXNbMF0ubWFza2VkQ2FyZHNbMF0uc3JjRGlnaXRhbENhcmRJZDtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBjb25zb2xlLndhcm4oJ1NSQyBQcm9maWxlIGNvbnRhaW5lZCBubyBjYXJkcycpO1xuICAgIC8vIHRocm93IG5ldyBFcnJvcigncHJvZmlsZSBtYXNrZWQgY2FyZCBtaXNzaW5nIHNyY0RpZ2l0YWxDYXJkSWQnLCBKU09OLnN0cmluZ2lmeShzcmNQcm9maWxlcywgbnVsbCwgMikpO1xuICB9XG4gIGludGVudFBheWxvYWQuaWRUb2tlbiA9IHNyY1Byb2ZpbGVzWzBdLmlkVG9rZW47XG4gIGludGVudFBheWxvYWQuc3JjQ29ycmVsYXRpb25JZCA9IHJlc3BvbnNlLnNyY0NvcnJlbGF0aW9uSWQ7XG4gIGludGVudFBheWxvYWQucHJvZmlsZXMgPSBzcmNQcm9maWxlcztcblxuICBjb25zb2xlLmxvZyhyZXNwb25zZSlcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJlbmNobWFyayB9IGZyb20gXCIuLi9zdHVicy9kYXRhLmpzXCI7XG5pbXBvcnQgeyB1cGRhdGVCZW5jaG1hcmtzIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXBkYXRlLWJlbmNobWFya3NcIjtcblxuZXhwb3J0IGNvbnN0IHVuYmluZCA9IGFzeW5jIChhZGFwdGVyLCB0b2tlbikgPT4ge1xuICBpZiAodG9rZW4pIHtcbiAgICBjb25zb2xlLmxvZygnW1VOQklORF0nKTtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLnVuYmluZEFwcEluc3RhbmNlKHt9KTtcbiAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xuXG4gICAgYmVuY2htYXJrLnVuYmluZCA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VsKCd1bmJpbmRfY29tcGxldGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGdlbCgndW5iaW5kX2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAke2JlbmNobWFyay51bmJpbmR9bXNgO1xuXG4gICAgICBjb25zb2xlLmxvZygnVW5iaW5kIHJlc3VsdCByZWNlaXZlZCBmcm9tIFZpc2EgU1JDIFN5c3RlbScpO1xuLy8gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgRGF0YScsIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICByZXR1cm47XG59XG4iLCJleHBvcnQgY29uc3Qga2V5cyA9IHtcbiAgc2FuZGJveDoge1xuICAgIC8vIGtpZDogXCIxYmRhYjNjY1wiLFxuICAgIGtpZDogJ1Y2WVBMMERGSjJWNTZISUg2UTNGMTMzZmJaV3lBeUlIaldWU2VjeDZLTUY2aVRIR00nLCAvLyBBUElrZXkvc3JjSW5pdGlhdG9ySWRcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDY1NTM3LFxuICAgICAgbjogXCIwMDpiMTo5MzpjODpiYTpjMDpkZjplZjoyNDoyNzo5ZToxMDo2NDo1MzpkOTphZTpkNzo4NTo0ZTozYjo3MDphYjpiYToyZDpkYjplZTpiMDoxZjpkODphNjoxZTphMTpiNToxMTo5OTo3MDozNTplZDpiZDo0OTo1ZjpkODplMDpkMDoyNzo3ZTpiZTowYTo2NjpiYjoyNDplYjpjNDoxNToxMjo3MzplZToxYjpkMzplNTowZjo4MToyYzowNjoxNjphMzpkNjo1Mjo5Yzo3NDpmMDo0Yzo2YTphZjowMzpjMzozYTpmMTo2ODo4YzoxYToyZTpkYjowOTo3MjphYjpjNjpkYzpjYjo0NToyYzpmODoxNzpkZTowYjozNDo4NDplNjo1MzoxNTo3NToyNTpkMzo1ZDo3NTpkYzozNjphYjpiZTphOTpiZDpiNjo4YzoyMDo4MjoyNDowMjplOTpjNjpjMDoyYjpiMTpiYTowYzozOTo3YjowYjo3OTpkODo3NzozMzo4NTpjZDo0Mzo5NTpjNjowMjpkNDo1ZjplZDpiZjpiZTpiOTozNjozOTowZTpiZjo0YToyZDo4Yzo5NDpiZDo5Mjo4MDo5ZDo4ZDozODozMDphMjo0ZjoxMDplZTo3ODo2MjoyMjowNTozMzo5MDpkMzowMjoxMzo0ZTo5YTpjZDozYzpmNjozNzo0Yzo3NzoxZjo5NDo0NDo4Mjo4OTo4YzpmNTozNjpmOToxYTo0NzoxYjo1YjpiYzoyYzoyMTpiNDpkYjpjNDo1MzoyMjo5MzplYzozNTpiNDo1YTo5ZTplNDpiOTo0YzowNjozZjpjZTo1Yzo0Mzo4MTpiZDo2MToyODo5ZDpmYTo2MTpiNjo0NDozNDo3MjplMDpmNDpmNTpkMzowNjoxNzo0ZTozMjo1NTozZDpkMDozNDpjYjo5NTpmNzoxYjoyZDozNjpiZTowZjpiMDplMDo5NjozMDoxYTo1ODoyYjphZjpjYzpiMzpkYToxYlwiXG4gICAgfVxuICB9LFxuICBxYV9wZXJmOiB7XG4gICAga2lkOiAnTDZNTEEzUDI2M05DOEFGVUpHVzQxMXg5cW83TlZDVWpMOTJzRWxaM3ZkSWxzU255MCcsXG4gICAgcHVibGljS2V5OiB7XG4gICAgICBlOiA2NTUzNyxcbiAgICAgIG46ICcwMDpjNjplYzoyYTpmNzo0ZTo5NjpkMDo4OTowZDozYTo1MDpjZjpiYjo4MDo1MDo1NDo0Zjo4NjowNTo5Yzo1Mjo1ZDpmNzpjNTo4MzoxMDozYTo3ZToxMzozOTpkODpkYjphYzo4MTpkZDowNjo1MDpmODozZjphMzplNjo4YjoxZjoxYzo2Nzo3ZToxMDpkYjo4NzpmNzoxMjoyMjpkYTpjMzozODoxNzo3MDo5ZTpkYjowZDoxYzo0YTpjZDpmYjpiMjpjYjoxZDo5ZDo2Nzo0ODo0ZTo5MTpmNjo2ODo4YTplOTpjMzpmNzo4Yzo0Zjo1ODphODowNjoyYzphNTozMzpmODo4YTpjMzo5ZDpjODo4MzoyMjoyYTpjZTo4OTo3Nzo2ZToxYzpiYjo4ZTpkMTozOTpiOTo2ZDowYzozZTo3YTozYTo0ZTo1MzowYjpiYjowMjoyMDplNzoyZDowOToyNDoxMDplYTpmMDo5NToxZTowMDo5NDpmYzo4MjoyODo5ODoxODoyZjo1YTplOTo4MzpiZjo0NDpjYjoxMzo2ZjpjMzpiMzpiYjo5Yjo5NTpmZDpjNDo4Zjo2Njo4MToyYjoxMzo1Yzo1ZTo5ZDoxNjowNTplZjo5OTo2Mzo0YTpjMToyYjo5OTowODpjMjpjNTpkYzoyZTpiYTo1YzoyYTo3MzplNzo3ZjowMDozMjpiNTo5NTphYTozNjpjNTozNjphZTo3NDphMTozYTo2MTo3MTplYjowYzpjZjo3NjozMTo0YTplZDo2NjpkZDphNjpiMTpjOTpmNjo5MjpiODpiOToyYjplZToyNTowZTo5MToxNDpjOTozZDoxNjo5Yjo5YzphYzoxYTpkMTowYzphMjpkMTpiNzo5Mzo3MTpkMzpkZDpmNDphNjo5ODphMjpiNDowMjoxNzplNDozYzpjNDoyODo1YzpiZjplOTpkZTo4ZDoxZTo5YzoyMDpiMTo0YzpiNjphMzo3MToyOTpmOToyZjo3ZTo0ZCdcbiAgICB9XG4gIH0sXG4gIHByb2R1Y3Rpb246IHtcbiAgICBraWQ6IFwiSkhBMTBMQUtFRkcwVDdDSUJTMU8xNENobjZscTNjZE94cS1Xd3FhNjJaVXdLdm5tNFwiLFxuICAgIHB1YmxpY0tleToge1xuICAgICAgZTogNjU1MzcsXG4gICAgICBuOiBcIjAwOjkwOmZiOmEzOmMxOjUyOjYzOjdhOmYyOjNmOmExOmU2OjcwOjY2OjgwOjM2OjVhOjNiOjdkOmUwOjMxOjVjOjMyOmY0OjQyOjY5OmJmOjIyOjQ2OjIxOjA2OmFjOjY3OmNhOjVhOmQzOjQyOmMxOjA2OjI0OmNhOjVjOmFlOjQ2OjgwOjdhOmQ3Ojk3OjE4OjliOjYwOjU1OjZlOmZhOjBhOjFmOmM2OjMyOmJmOjQ2OjgyOmRkOmRjOjFhOjg3OmE1OjI2OjM5OmQyOjZjOmNlOjYyOmY0OmE1OjVmOmRjOjZmOjFmOmVkOjVmOjM1OmEwOjYyOjBkOmVjOjYwOmRiOjI5OmQyOmMwOjcxOjUwOjU3OjEwOmQ0OjBlOjgzOjU1OmJjOjhlOmM3OjEyOjViOjlhOjdjOjI1OjFjOjYxOjM5OjdlOjRiOmIzOjI2OmJmOmFhOmFhOmU5Ojc3OjQ2OmNjOjJjOjA4OjZmOmFmOjNlOmI4OjdmOmZiOmVkOmJmOjQ1OjI4OmE5OjZiOmQ5OjU1OmFmOmQ4OjJmOjdjOjhlOjAwOjZjOjUwOjAxOjJkOjNhOjhhOjdhOmRhOjM0OmFkOjYzOmRiOjIwOjEyOjlkOjg1OmMxOjkwOmVjOjkzOjBmOmM3OjNhOmJjOmRiOjdmOjRhOjNkOjQ2OjVmOjRiOjIzOjZlOjc4OjA3OjFkOjJmOmVjOjg3OjAwOjM4OmI3OjJmOjY1OjUyOmNkOmQxOjdiOmI1OjJlOmVjOjhiOjdiOjllOmZjOjgxOjY4OjVjOjNhOjViOjgyOjBiOjA1OmM2OmYxOjJkOmVmOmQ1OjI1OjA0OjMzOjgxOmIxOmE4OjFjOmZlOjZiOjNkOmZkOjliOjE4Ojk0Ojk2OjhhOjA5OjNmOjE5OjhmOjA4OjVhOjkwOmNhOjNmOmY5Ojk3OjVjOmY3OmI5OmFlOjc1OjU4OmY1OjhmOjNkOmJmOjJmOjk5Ojc4Ojk3OmZjOmUyOjZjOjVlOjZiOjhiXCJcbiAgICB9XG4gIH0sXG4gIGRldmVsb3BtZW50OiB7XG4gICAga2lkOiBcIklQVzRXMURYNUQ0TjVFOExNQUM2MTE1bGE0NE51OXpZb2JfYmdyZzVFVU1rc2JnVDRcIixcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDY1NTM3LFxuICAgICAgbjogXCIwMDpiYTo3ZTplZDo4YTo5ODplOTo5OTpmYjpiYjowZDpkODpiZjpiMzo4OTo0YzoxMzo3NDo5Mzo2NzowYzowMjpjOTplODozMjo4ZDo0MjoyYzo1YTpmZDphYzpjYjo2NzowZTpjOTo0YjoyZTo3Mzo2NTo3YToxYTpkMjo0NTo2YzpiODoyODpkNzowNjphYzoxZDo4YjowZDoxYjo4ODo5NjoyMjozNTpjMTo2Zjo1Zjo5NTpjNzowOTowYTpkNTpmZDo5MjpiZTo2NTpmYzozNjoxNDplZDo0YTo2MDo1ZjpmMzpiYzpiOToyMDphNTo3ZTpjYjo5YzozNTpjNDplZjowOToyNjo3ODozYzoxOTozZTpkMjphMjo5YjpkZDpiNDoxNTo2MzpiMjphNjo0OToyMTo5NDoxNTplNDozNzpkNDoxZTplMDpkOTpmMTo3OTplNzowMTphNzo1Njo4MzozYjozNzo1OTpiZTo5ZTo1NzplODo5YzphODo4NDoyYjo0OTpkZDo1ZDozZDowNDozNzpmZDowOTo1Zjo1OTo5MzoyMDpmNjowMTpkMjpkMjoxYTo1NzoxZDphYTo2Zjo1ODo1YzplYzplMjpkZjo3NzphZTowMjpiZjo5ZTpmMzpiYjo0ZTplOTo5MDo2MDo5OTo2NDowODphNDo4NDo3MTpjMDoxOTpmMDplZTo2NDozOTo4OTo2ZDpiYzozNDpiZjowMzpmMDoyZTo2OTo4YTo3ODo2ZDoyMDo5YToxNTo4Zjo2NDpiNjplZTo1ZDoxYTo0ZDo1YjoyYzpjOTo4NzphMTo0MTplZTo5MjpmMzpiNDo1NjoyNDozNTo3Mzo1MzplMTo4Yzo0Yjo5MTpkNjpmMTo5ZjozMTo2ZDpjODphNTo1MDoxMjpiZjpkODpjMTphMzo2MTo3Zjo0ZjphNTo2YTo1Yjo5ODo5MTo5NDo2ODpiZjo4Zjo0OTo1ZjpkNTplMzo2MjphMTphNTpjYzo5ODo3ZDo5MTpiYlwiXG4gICAgfVxuICB9LFxuICBjZXJ0OiB7XG4gICAgXCJraWRcIjogXCJiYjkxN2Q5OFwiLFxuICAgIFwibmFtZVwiOiBcInFhLWNicC1yc2EtZW5jLWNzci0xXCIsXG4gICAgXCJwdWJsaWNLZXlcIjoge1xuICAgICAgXCJlXCI6IDY1NTM3LFxuICAgICAgXCJuXCI6IFwiMDA6YmE6N2U6ZWQ6OGE6OTg6ZTk6OTk6ZmI6YmI6MGQ6ZDg6YmY6YjM6ODk6NGM6MTM6NzQ6OTM6Njc6MGM6MDI6Yzk6ZTg6MzI6OGQ6NDI6MmM6NWE6ZmQ6YWM6Y2I6Njc6MGU6Yzk6NGI6MmU6NzM6NjU6N2E6MWE6ZDI6NDU6NmM6Yjg6Mjg6ZDc6MDY6YWM6MWQ6OGI6MGQ6MWI6ODg6OTY6MjI6MzU6YzE6NmY6NWY6OTU6Yzc6MDk6MGE6ZDU6ZmQ6OTI6YmU6NjU6ZmM6MzY6MTQ6ZWQ6NGE6NjA6NWY6ZjM6YmM6Yjk6MjA6YTU6N2U6Y2I6OWM6MzU6YzQ6ZWY6MDk6MjY6Nzg6M2M6MTk6M2U6ZDI6YTI6OWI6ZGQ6YjQ6MTU6NjM6YjI6YTY6NDk6MjE6OTQ6MTU6ZTQ6Mzc6ZDQ6MWU6ZTA6ZDk6ZjE6Nzk6ZTc6MDE6YTc6NTY6ODM6M2I6Mzc6NTk6YmU6OWU6NTc6ZTg6OWM6YTg6ODQ6MmI6NDk6ZGQ6NWQ6M2Q6MDQ6Mzc6ZmQ6MDk6NWY6NTk6OTM6MjA6ZjY6MDE6ZDI6ZDI6MWE6NTc6MWQ6YWE6NmY6NTg6NWM6ZWM6ZTI6ZGY6Nzc6YWU6MDI6YmY6OWU6ZjM6YmI6NGU6ZTk6OTA6NjA6OTk6NjQ6MDg6YTQ6ODQ6NzE6YzA6MTk6ZjA6ZWU6NjQ6Mzk6ODk6NmQ6YmM6MzQ6YmY6MDM6ZjA6MmU6Njk6OGE6Nzg6NmQ6MjA6OWE6MTU6OGY6NjQ6YjY6ZWU6NWQ6MWE6NGQ6NWI6MmM6Yzk6ODc6YTE6NDE6ZWU6OTI6ZjM6YjQ6NTY6MjQ6MzU6NzM6NTM6ZTE6OGM6NGI6OTE6ZDY6ZjE6OWY6MzE6NmQ6Yzg6YTU6NTA6MTI6YmY6ZDg6YzE6YTM6NjE6N2Y6NGY6YTU6NmE6NWI6OTg6OTE6OTQ6Njg6YmY6OGY6NDk6NWY6ZDU6ZTM6NjI6YTE6YTU6Y2M6OTg6N2Q6OTE6YmJcIlxuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IFBBTkpXRSB9IGZyb20gJy4uL2pvc2UvdmlzYS1lbmNyeXB0LmpzJztcbmltcG9ydCB7IGtleXMgfSBmcm9tICcuLi9zdHVicy9wYW4tZW5jcnlwdGlvbi1rZXlzLmpzJztcbmltcG9ydCBnZXRSb290RG9tYWluIGZyb20gJy4vZ2V0LXJvb3QtZG9tYWluLmpzJztcbmltcG9ydCB7IGdldEVuY3J5cHRpb25LZXlzIH0gZnJvbSAnLi9nZXQta2V5cy50cyc7XG5cbi8vIGV4dGVybmFsLCBzY3J1YmJlZCBzaXRlc1xuaWYgKCFrZXlzKSB7XG4gIGtleXMgPSBnZXRFbmNyeXB0aW9uS2V5cygpO1xufVxuXG5jb25zdCBnZXRSc2FLZXlGcm9tRG9tYWluID0gKCkgPT4ge1xuICBjb25zdCBkb21haW4gPSBnZXRSb290RG9tYWluKCk7XG4gIGNvbnNvbGUubG9nKGAtLSBkZXRlY3RlZCAke2RvbWFpbn0gZnJvbSB2aXNhIHNkayB1cmxgKTtcblxuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlICdodHRwczovL3NlY3VyZS5jaGVja291dC52aXNhLmNvbSc6XG4gICAgICByZXR1cm4ga2V5cy5wcm9kdWN0aW9uO1xuICAgIGNhc2UgZG9tYWluLmluZGV4T2YoJ3FhcGVyZicpID4gLTE6XG4gICAgICByZXR1cm4ga2V5cy5xYV9wZXJmO1xuICAgIGNhc2UgZG9tYWluLmluZGV4T2YoJ2NlcnQuJykgPiAtMTpcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBjZXJ0IGVuYyBrZXlzJyk7XG4gICAgICByZXR1cm4ga2V5cy5jZXJ0O1xuICAgIGNhc2UgZG9tYWluLmluZGV4T2YoJ3NhbmRib3guJykgPiAtMTpcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBzYnggZW5jIGtleXMnKTtcbiAgICAgIHJldHVybiBrZXlzLnNhbmRib3g7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBrZXlzLmNlcnQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBBTkpXRV92aXNhID0gYXN5bmMgKHMpID0+IHtcbiAgY29uc3QgeyBwdWJsaWNLZXksIGtpZCB9ID0gZ2V0UnNhS2V5RnJvbURvbWFpbigpO1xuICBjb25zb2xlLmluZm8oYFtQQU5KV0VdIGtpZDogJHtraWR9YCk7XG4gIGNvbnNvbGUuaW5mbygnW1BBTkpXRV0gcHVibGljS2V5OiAnLCBwdWJsaWNLZXkpO1xuICBjb25zdCBjcnlwdCA9IG5ldyBQQU5KV0Uoa2lkLCBwdWJsaWNLZXkpO1xuICByZXR1cm4gY3J5cHQuZW5jcnlwdChzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKGNhcmREYXRhT2JqZWN0KSA9PiBhd2FpdCBQQU5KV0VfdmlzYShKU09OLnN0cmluZ2lmeShjYXJkRGF0YU9iamVjdCkpO1xuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vaGVscGVycy91dGlscyc7XG5pbXBvcnQgZW5jcnlwdENhcmQgZnJvbSAnLi9lbmNyeXB0LWNhcmQnO1xuaW1wb3J0IHsgaGFuZGxlSnNvblJlc3BvbnNlIH0gZnJvbSAnLi9mZXRjaC5qcyc7XG5cblxuZXhwb3J0IGNvbnN0IGhhbmRsZUNhcmREYXRhID0gYXN5bmMgY2FyZERhdGEgPT4ge1xuICBjb25zdCByZXQgPSB7IGNhcmREYXRhOiBudWxsLCBlbmNyeXB0ZWRDYXJkOiBudWxsIH07XG4gIGNvbnN0IGQgPSBjYXJkRGF0YS5wYW4gfHwgY2FyZERhdGEuZGF0YT8ucGFuIHx8IGNhcmREYXRhLmRhdGE7XG4gIGNvbnN0IGV4cERhdGVBcnJheSA9IGQuRXhwaXJhdGlvbkRhdGUuc3BsaXQoJy8nKTtcbiAgY29uc3QgdmNvQ2FyZCA9IHtcbiAgICBjYXJkIDoge1xuICAgICAgY2FyZFNlY3VyaXR5Q29kZTogZC5DdnYyVmFsdWUsXG4gICAgICBjYXJkaG9sZGVyRnVsbE5hbWU6IGQuQ2FyZGhvbGRlck5hbWUgfHwgXCJTUkMgU0RLXCIsXG4gICAgICBwYW5FeHBpcmF0aW9uTW9udGg6IHBhcnNlSW50KGV4cERhdGVBcnJheVswXSksXG4gICAgICBwYW5FeHBpcmF0aW9uWWVhcjogcGFyc2VJbnQoJzIwJyArIGV4cERhdGVBcnJheVsxXSksXG4gICAgICBwcmltYXJ5QWNjb3VudE51bWJlcjogZC5QcmltYXJ5QWNjb3VudE51bWJlcixcbiAgICAgIGNhcmRob2xkZXJGaXJzdE5hbWU6IFwiVGVzdFRvb2xcIixcbiAgICAgIGNhcmRob2xkZXJMYXN0TmFtZTogXCJTYW1wbGVEYXRhXCIsXG4gICAgICBwYXltZW50QWNjb3VudFJlZmVyZW5jZTogXCJcIixcblxuICAgICAgYmlsbGluZ0FkZHJlc3M6IHtcbiAgICAgICAgYWRkcmVzc0lkOiBcIlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICBsaW5lMTogZC5BZGRyZXNzU3RyZWV0LFxuICAgICAgICBsaW5lMjogZC5BZGRyZXNzU3RyZWV0MixcbiAgICAgICAgbGluZTM6IGQuQWRkcmVzc1N0cmVldDMsXG4gICAgICAgIGNpdHk6IGQuQ2l0eSxcbiAgICAgICAgc3RhdGU6IGQuU3RhdGUsXG4gICAgICAgIGNvdW50cnlDb2RlOiBkLkNvdW50cnksXG4gICAgICAgIHppcDogZC5BZGRyZXNzUG9zdGFsQ29kZSxcbiAgICAgICAgY3JlYXRlVGltZTogXCJcIixcbiAgICAgICAgbGFzdFVzZWRUaW1lOiBcIlwiLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zb2xlLmxvZygnb2JqZWN0IHRvIGVuY3J5cHQ6ICcsIHZjb0NhcmQpO1xuICByZXQuZW5jcnlwdGVkQ2FyZCA9IGF3YWl0IGVuY3J5cHRDYXJkKHZjb0NhcmQpO1xuICBjb25zb2xlLmxvZyhyZXQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGJpblJhbmdlID0gZ2VsKCdiaW5fcmFuZ2UnKS52YWx1ZTtcbiAgY29uc3QgY2FyZERhdGEgPSBhd2FpdCBmZXRjaChgL2NhcmRzP2Jpbj0ke2JpblJhbmdlfWApLnRoZW4oaGFuZGxlSnNvblJlc3BvbnNlKTtcbiAgcmV0dXJuIGF3YWl0IGhhbmRsZUNhcmREYXRhKGNhcmREYXRhKTtcbn07XG4iLCJpbXBvcnQgeyBoYW5kbGVDYXJkRGF0YSB9IGZyb20gJy4vZ2V0LXZpc2EtY2FyZCc7XG5pbXBvcnQgeyBjYXRjaEVyciwgZ2VsIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGNvbnN0IGVuY3J5cHRNYW51YWxDYXJkRW50cnkgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHMgPSBnZWwoJ3Bhbl9qc29uJykudmFsdWU7XG4gIGxldCBwYW47XG5cbiAgdHJ5IHtcbiAgICBwYW4gPSBKU09OLnBhcnNlKHMpO1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVDYXJkRGF0YShwYW4pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2F0Y2hFcnIoJ21hbnVhbCBQQU4gSlNPTiBwYXJzZSBmYWlsZWQuJyk7XG4gICAgcmV0dXJuIHsgZW5jcnlwdGVkQ2FyZDogbnVsbCB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGNoZWNrb3V0IH0gZnJvbSAnLi4vYXN5bmMvY2hlY2tvdXQuanMnO1xuaW1wb3J0IHsgZ2V0U3JjUHJvZmlsZSB9IGZyb20gJy4uL2FzeW5jL2dldC1zcmMtcHJvZmlsZS5qcyc7XG5pbXBvcnQgeyB1bmJpbmQgfSBmcm9tICcuLi9hc3luYy91bmJpbmQuanMnO1xuaW1wb3J0IGdldFZpc2FDYXJkIGZyb20gJy4uL2hlbHBlcnMvZ2V0LXZpc2EtY2FyZCc7XG5pbXBvcnQgeyBjYXRjaEVyciwgZ2VsIH0gZnJvbSAnLi4vaGVscGVycy91dGlscy5qcyc7XG5pbXBvcnQgeyB1cGRhdGVCZW5jaG1hcmtzIH0gZnJvbSAnLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qcyc7XG5pbXBvcnQgeyBnZXRJbnRlbnRQYXlsb2FkIH0gZnJvbSAnLi4vc3R1YnMvZGF0YSc7XG5pbXBvcnQgeyBjYW5Vc2VUZXN0Q2FyZEFwaSB9IGZyb20gJy4uL2hlbHBlcnMvY2FuLXVzZS10ZXN0LWNhcmRzLWFwaS5qcyc7XG5pbXBvcnQgeyBlbmNyeXB0TWFudWFsQ2FyZEVudHJ5IH0gZnJvbSAnLi4vaGVscGVycy9nZXQtdmlzYS1jYXJkLW1hbnVhbC5qcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZnRlckF1dGhOZXdVc2VyKGFkYXB0ZXIsIGxhYmVsKSB7XG4gIGNvbnN0IGludGVudFBheWxvYWQgPSBnZXRJbnRlbnRQYXlsb2FkKCk7XG4gIGNvbnNvbGUubG9nKCc1Njc4OTg3NjU2NycsIGludGVudFBheWxvYWQpXG4gIGNvbnNvbGUuaW5mbyhgW0FERF9DQVJEXSAke2xhYmVsIHx8ICduZXcgdXNlciArIGVucm9sbCd9YCk7XG5cbiAgaWYgKGNhblVzZVRlc3RDYXJkQXBpKCkpIHtcbiAgICBpbnRlbnRQYXlsb2FkLmVuY3J5cHRlZENhcmQgPSAoYXdhaXQgZ2V0VmlzYUNhcmQoKSkuZW5jcnlwdGVkQ2FyZDtcbiAgfSBlbHNlIHtcbiAgICBpbnRlbnRQYXlsb2FkLmVuY3J5cHRlZENhcmQgPSAoYXdhaXQgZW5jcnlwdE1hbnVhbENhcmRFbnRyeSgpKS5lbmNyeXB0ZWRDYXJkO1xuICB9XG4gIC8vIGNvbnNvbGUubG9nKCdpbnRlbnQgcGF5bG9hZCBhZnRlciBnZXRWaXNhQ2FyZDogJywgaW50ZW50UGF5bG9hZCk7XG5cbiAgaWYgKGludGVudFBheWxvYWQuc3JjRGlnaXRhbENhcmRJZCkge1xuICAgIGNvbnNvbGUuaW5mbygnY2FyZCBhbHJlYWR5IGFzc2lnbmVkLCB1bmRlZmluaW5nIGludGVudFBheWxvYWQuc3JjRGlnaXRhbENhcmRJZCcpXG4gICAgaW50ZW50UGF5bG9hZC5zcmNEaWdpdGFsQ2FyZElkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc29sZS5pbmZvKGBbQ0hFQ0tPVVRdICR7bGFiZWwgfHwgJ25ldyB1c2VyICsgZW5yb2xsJ31gKTtcbiAgY29uc3QgY2hlY2tvdXRTdWNjZXNzID0gYXdhaXQgY2hlY2tvdXQoYWRhcHRlcikuY2F0Y2goY2F0Y2hFcnIpO1xuXG4gIGlmICghY2hlY2tvdXRTdWNjZXNzIHx8IGNoZWNrb3V0U3VjY2Vzcy5lcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYGNoZWNrb3V0IGVycm9yIGRldGVjdGVkOiBgLCBjaGVja291dFN1Y2Nlc3MpO1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShjaGVja291dFN1Y2Nlc3MpKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG4gIH1cblxuICBpZiAoY2hlY2tvdXRTdWNjZXNzICYmIGNoZWNrb3V0U3VjY2Vzcy51bmJpbmRBcHBJbnN0YW5jZSkge1xuICAgIGF3YWl0IHVuYmluZChhZGFwdGVyLCBjaGVja291dFN1Y2Nlc3MpLmNhdGNoKGNhdGNoRXJyKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZnRlckF1dGhSZXR1cm5pbmcoYWRhcHRlciwgdG9rZW4pIHtcbiAgY29uc29sZS5pbmZvKCdbQ0FSRF9MSVNUXScpO1xuICAvLyBnZXRTcmNQcm9maWxlXG4gIGNvbnN0IHNyY1Byb2ZpbGVzID0gYXdhaXQgZ2V0U3JjUHJvZmlsZShhZGFwdGVyLCB0b2tlbikuY2F0Y2goY2F0Y2hFcnIpO1xuICB1cGRhdGVCZW5jaG1hcmtzKCk7XG5cbiAgY29uc29sZS5sb2coXCItLS0tLS1cIiwgc3JjUHJvZmlsZXMpO1xuXG4gIGlmIChzcmNQcm9maWxlcy5lcnJvcikge1xuICAgIC8vIHRocm93IG5ldyBFcnJvcihzcmNQcm9maWxlcy5lcnJvcik7XG4gICAgY29uc29sZS53YXJuKHNyY1Byb2ZpbGVzLmVycm9yKTtcbiAgfVxuXG4gIGNvbnN0IHByZWZlckFkZENhcmQgPSBnZWwoJ2FkZF9jYXJkX2Zsb3cnKS5jaGVja2VkO1xuXG4gIC8vIGNoZWNrb3V0XG4gIGlmIChcbiAgICBmYWxzZSA9PT0gcHJlZmVyQWRkQ2FyZCAmJlxuICAgIHNyY1Byb2ZpbGVzICYmXG4gICAgIXNyY1Byb2ZpbGVzLmVycm9yICYmXG4gICAgc3JjUHJvZmlsZXMucHJvZmlsZXNbMF0ubWFza2VkQ2FyZHMubGVuZ3RoID4gMFxuICApIHtcbiAgICBjb25zb2xlLmluZm8oJ1tDSEVDS09VVF0gcmV0dXJuaW5nIHVzZXInKTtcbiAgICBjb25zdCBjaGVja291dFN1Y2Nlc3MgPSBhd2FpdCBjaGVja291dChhZGFwdGVyKS5jYXRjaChjYXRjaEVycik7XG5cbiAgICBpZiAoIWNoZWNrb3V0U3VjY2VzcyB8fCBjaGVja291dFN1Y2Nlc3MuZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYGNoZWNrb3V0IGVycm9yIGRldGVjdGVkOiBgLCBjaGVja291dFN1Y2Nlc3MpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGNoZWNrb3V0U3VjY2VzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrb3V0U3VjY2VzcyAmJiBjaGVja291dFN1Y2Nlc3MudW5iaW5kQXBwSW5zdGFuY2UpIHtcbiAgICAgIGF3YWl0IHVuYmluZChhZGFwdGVyLCBjaGVja291dFN1Y2Nlc3MpLmNhdGNoKGNhdGNoRXJyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWZ0ZXJBdXRoTmV3VXNlcihhZGFwdGVyLCAncmV0dXJuaW5nIHVzZXIgYWRkIGNhcmQnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgYmVuY2htYXJrLCBiZW5jaG1hcmtTdGF0ZSB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xuaW1wb3J0IHsgZ2V0T1RQIH0gZnJvbSAnLi4vaGVscGVycy9nZXQtb3RwLmpzJztcbmltcG9ydCB7IGNhblVzZU90cEFwaSB9IGZyb20gJy4uL2hlbHBlcnMvY2FuLXVzZS1vdHAtYXBpLmpzJztcbmltcG9ydCB7IGNhdGNoRXJyLCBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IHN0YXJ0VGltZSB9IGZyb20gJy4uL2hlbHBlcnMvdXBkYXRlLWJlbmNobWFya3MuanMnO1xuaW1wb3J0IHsgYWZ0ZXJBdXRoUmV0dXJuaW5nIH0gZnJvbSAnLi9hZnRlci1hdXRoLmpzJztcblxubGV0IGlzUUFQZXJmO1xuXG53aW5kb3cub3RwX2xpc3RlbmVyID0gZmFsc2U7XG5cblxuXG5hc3luYyBmdW5jdGlvbiBzdWJtaXRPdHAob3RwQ29kZSkge1xuICBjb25zb2xlLmluZm8oJy0tLS0gc3VibWl0T3RwJyk7XG4gIGNvbnN0IGNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uU3RhcnQgPSBEYXRlLm5vdygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbih3aW5kb3cuYzJwX2FkYXB0ZXIsIHtcbiAgICB2YWxpZGF0aW9uRGF0YTogb3RwQ29kZVxuICB9KS5jYXRjaChjYXRjaEVycik7XG4gIGJlbmNobWFyay5jb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbiA9IERhdGUubm93KCkgLSBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvblN0YXJ0O1xuXG4gIGdlbCgnYXV0aF9jb21wbGV0ZScpLmNoZWNrZWQgPSB0cnVlO1xuICBnZWwoJ2F1dGhfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7KGJlbmNobWFyay5pZGVudGl0eUxvb2t1cCArIGJlbmNobWFyay5pbml0aWF0ZUlkZW50aXR5VmFsaWRhdGlvbiArIGJlbmNobWFyay5jb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbikgLyAxMDAwfXNgO1xuICBnZWwoJ2F1dGhfYnJlYWtkb3duJykuaW5uZXJIVE1MID0gYFsgaWRlbnRpdHlMb29rdXA6ICR7YmVuY2htYXJrLmlkZW50aXR5TG9va3VwfW1zIF08YnIvPlsgaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb246ICR7YmVuY2htYXJrLmluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9ufW1zIF08YnIvPlsgY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb246ICR7YmVuY2htYXJrLmNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9ufW1zIF1gO1xuXG4gIGNvbnNvbGUubG9nKGAvcHJvYmVgLCByZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbihhZGFwdGVyLCBjb2RlKSB7XG4gIGNvbnNvbGUubG9nKFwiQGNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uIC0gVmFsaWRhdGlvbiBEYXRhID0+IFwiLCBjb2RlKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uKGNvZGUpLmNhdGNoKGNhdGNoRXJyKTtcbiAgY29uc29sZS5sb2coYC0tLS0gY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb24gLSByZXNwb25zZWAsIHJlc3BvbnNlKTtcblxuICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChyZXNwb25zZVsncmVhc29uJ10pIHtcbiAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHZlcmlmeSBPVFA6ICVvJywgcmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBmcm9tIFZlcmlmeSBPVFA6ICVvJywgcmVzcG9uc2UpO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb24oYWRhcHRlcikge1xuICBjb25zb2xlLmxvZygnQGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uJyk7XG4gIHJldHVybiBhd2FpdCBhZGFwdGVyLmluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uKCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgcmVzcG9uc2UgZnJvbSBpbml0aWF0ZUlkZW50eVZhbGlkYXRpb25gLCByZXNwb25zZSk7XG4gICAgaWYgKHJlc3BvbnNlWydyZWFzb24nXSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW5pdGlhbGl6ZSBJZGVudGl0eSB2YWxpZGF0aW9uLCBlcnJvcjogJW8nLCByZXNwb25zZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSkuY2F0Y2goY2F0Y2hFcnIpO1xufVxuXG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhGbG93KGFmdGVyQXV0aCwgdXBkYXRlQmVuY2htYXJrcykge1xuICBjb25zb2xlLmxvZygnW0FVVEhfRkxPV10gc3RhcnQnKTtcbiAgbGV0IG90cENvZGU7XG4gIGNvbnN0IGVtYWlsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtYWlsJyk7XG5cbiAgLy8gaWRMb29rdXBcbiAgY29uc3QgaWRlbnRpdHlMb29rdXBTdGFydCA9IERhdGUubm93KCk7XG5cbiAgY29uc29sZS5sb2coJy0tIHN0YXJ0aW5nIGFzeW5jIGlkZW50aXR5TG9va3VwJyk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHdpbmRvdy5jMnBfYWRhcHRlci5pZGVudGl0eUxvb2t1cCh7XG4gICAgaWRlbnRpdHlQcm92aWRlcjogXCJTUkNcIixcbiAgICBpZGVudGl0eVZhbHVlOiBlbWFpbCxcbiAgICB0eXBlOiBcIkVNQUlMXCJcbiAgfSkuY2F0Y2goY2F0Y2hFcnIpO1xuICBjb25zb2xlLmxvZygnLS0gaWRlbnRpdHlMb29rdXAgcmV0dXJuJywgcmVzKTtcblxuICBiZW5jaG1hcmsuaWRlbnRpdHlMb29rdXAgPSBEYXRlLm5vdygpIC0gaWRlbnRpdHlMb29rdXBTdGFydDtcbiAgdXBkYXRlQmVuY2htYXJrcygpO1xuXG4gIGlmIChyZXMuZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzLCBudWxsLCAyKSk7XG4gIH0gZWxzZSBpZiAocmVzLmNvbnN1bWVyUHJlc2VudCB8fCByZXMuYWNjZXNzVG9rZW4pIHtcbiAgICAvLyByZWlzc3VlYW5jZVxuICAgIGNvbnNvbGUubG9nKCctLS0gcmVpc3N1YW5jZScpO1xuICAgIGNvbnN0IGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uKHdpbmRvdy5jMnBfYWRhcHRlcikuY2F0Y2goY2F0Y2hFcnIpO1xuICAgIGJlbmNobWFyay5pbml0aWF0ZUlkZW50aXR5VmFsaWRhdGlvbiA9IERhdGUubm93KCkgLSBpbml0aWF0ZUlkZW50aXR5VmFsaWRhdGlvblN0YXJ0O1xuICAgIGJlbmNobWFyay5VSVVYX3RvX09UUCA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgdXBkYXRlQmVuY2htYXJrcygpO1xuXG4gICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHJlcywgbnVsbCwgMikpO1xuICAgIH0gZWxzZSBpZiAocmVzICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGNhblVzZU90cEFwaSgpID09PSBmYWxzZSkge1xuICAgICAgICBpZiAod2luZG93Lm90cF9saXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnaW5zdGFudGlhdGluZyBtYW51YWwgT1RQIGZvcm0nKVxuICAgICAgICAgIHdpbmRvdy5vdHBfbGlzdGVuZXIgPSB0cnVlO1xuXG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBjb25zdCBvdHAgPSBnZWwoJ290cF92YWx1ZScpLnZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE9UUCBzdWJtaXR0ZWQgWyR7b3RwfV1gKTtcblxuICAgICAgICAgICAgaWYgKG90cCkge1xuICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBzdWJtaXRPdHAob3RwKS5jYXRjaChjYXRjaEVycik7XG4gICAgICAgICAgICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcblxuICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWZ0ZXJBdXRoKHdpbmRvdy5jMnBfYWRhcHRlciwgcmVzPy5pZFRva2VuKS5jYXRjaChjYXRjaEVycik7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2F0Y2hFcnIoJ05vIE9UUCB2YWx1ZSBkZXRlY3RlZC4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBnbG9iYWxIYW5kbGVyID0gYXN5bmMgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5zcmNFbGVtZW50LmlkID09PSAnb3RwX3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzaG93IE9UUCBmaWVsZCArIGJ1dHRvblxuICAgICAgICAgIHdpbmRvdy5fbWFudWFsX290cCA9IHRydWU7XG4gICAgICAgICAgZ2VsKCdvdHBfZW50cnknKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGdsb2JhbEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCctLS0gYXV0b21hdGljIE9UUCBzaG93bicpO1xuICAgICAgICBvdHBDb2RlID0gYXdhaXQgZ2V0T1RQKGVtYWlsKTtcblxuICAgICAgICAvLyBtYW51YWxseSBlbnRlciBmb3Igc2FuZGJveCtcbiAgICAgICAgaWYgKCFvdHBDb2RlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJy0tLSBwcm9tcHQgT1RQIHNob3duJyk7XG4gICAgICAgICAgb3RwQ29kZSA9IGF3YWl0IHByb21wdCgnRW50ZXIgT1RQJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pdE90cChvdHBDb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmluZm8oJ1tBVVRIX0ZMT1ddIGNvbnN1bWVyIG5vdCBwcmVzZW50Jyk7XG4gIHJldHVybiByZXM7XG59XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IGFmdGVyQXV0aFJldHVybmluZyB9IGZyb20gJy4vYWZ0ZXItYXV0aC5qcyc7XG5pbXBvcnQgeyB1cGRhdGVCZW5jaG1hcmtzIH0gZnJvbSAnLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qcyc7XG5pbXBvcnQgeyBiZW5jaG1hcmsgfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuXG5leHBvcnQgY29uc3QgcmV0dXJuaW5nRmxvdyA9IGFzeW5jIChhY2Nlc3NUb2tlbikgPT4ge1xuICBhd2FpdCBhZnRlckF1dGhSZXR1cm5pbmcod2luZG93LmMycF9hZGFwdGVyLCBhY2Nlc3NUb2tlbik7XG5cbiAgZ2VsKCdjcml0aWNhbF9hcGlzJykuaW5uZXJIVE1MID0gYENyaXRpY2FsIEFQSSB0aW1pbmdzOiAkeyhiZW5jaG1hcmsuaW5pdCArIGJlbmNobWFyay5pc1JlY29nbml6ZWQgKyBiZW5jaG1hcmsuZ2V0U3JjUHJvZmlsZSkgLyAxMDAwfXNgO1xuICBnZWwoJ2NoZWNrb3V0X2FwaXMnKS5pbm5lckhUTUwgPSBgQ2hlY2tvdXQgQVBJIHRpbWluZ3M6ICR7KGJlbmNobWFyay5jaGVja291dCArIGJlbmNobWFyay51bmJpbmQpIC8gMTAwMH1zYDtcbiAgdXBkYXRlQmVuY2htYXJrcygpO1xuXG4gIGdlbCgnZG9uZScpLmlubmVySFRNTCA9ICdkb25lJztcbn07XG4iLCJpbXBvcnQgeyBpbml0IH0gZnJvbSAnLi4vYXN5bmMvaW5pdC5qcyc7XG5pbXBvcnQgeyBpc1JlY29nbml6ZWQgfSBmcm9tICcuLi9hc3luYy9pcy1yZWNvZ25pemVkLmpzJztcbmltcG9ydCBsb2FkU2RrIGZyb20gJy4uL2FzeW5jL2xvYWQtc2RrLmpzJztcbi8vIGltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vaGVscGVycy9zbGVlcC5qcyc7XG5pbXBvcnQgeyBzZXRTdGFydFRpbWUsIHVwZGF0ZUJlbmNobWFya3MgfSBmcm9tICcuLi9oZWxwZXJzL3VwZGF0ZS1iZW5jaG1hcmtzLmpzJztcbmltcG9ydCB7IGNhdGNoRXJyLCBxcyB9IGZyb20gJy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuaW1wb3J0IHsgYXV0b0ZpbGxVVUlEIH0gZnJvbSAnLi4vaGVscGVycy91dWlkLmpzJztcbmltcG9ydCB7IGJlbmNobWFyaywgYmVuY2htYXJrU3RhdGUsIGdldEludGVudFBheWxvYWQsIHJlc2V0RmxvdyB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xuaW1wb3J0IHsgcmVzZXRVaSB9IGZyb20gJy4uL3VpL3Jlc2V0LXVpLmpzJztcbmltcG9ydCB7IGF1dGhGbG93IH0gZnJvbSAnLi9hdXRoLWZsb3cuanMnO1xuaW1wb3J0IHsgYWZ0ZXJBdXRoTmV3VXNlciwgYWZ0ZXJBdXRoUmV0dXJuaW5nIH0gZnJvbSAnLi9hZnRlci1hdXRoLmpzJztcbmltcG9ydCB7IHJldHVybmluZ0Zsb3cgfSBmcm9tICcuL3JldHVybmluZy5qcyc7XG5cbmNvbnN0IHZhbGlkYXRlRmxvdyA9ICgpID0+IHtcbiAgLy8gbWFudWFsLCBkb24ndCB1c2UgaGVscGVycyBoZXJlXG4gIGNvbnN0IGZsb3dUeXBlID0gcXMoJ2lucHV0W25hbWU9XCJmbG93X3NlbGVjdG9yXCJdOmNoZWNrZWQnKTtcblxuICBpZiAoZmxvd1R5cGUpIHtcbiAgICByZXR1cm4gW2Zsb3dUeXBlXTtcbiAgfVxuXG4gIGNhdGNoRXJyKCdTZWxlY3QgYSBGbG93IHRvIHN0YXJ0LicpO1xuXG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59O1xuXG5jb25zdCBzdGFydEZsb3cgPSBmdW5jdGlvbigpIHtcbiAgc2V0U3RhcnRUaW1lKCk7XG4gIGNvbnN0IGxvYWRTdGFydCA9IERhdGUubm93KCk7XG4gIHJlc2V0VWkoKTtcbiAgcmVzZXRGbG93KCk7XG5cbiAgY29uc3QgW2Zsb3dUeXBlXSA9IHZhbGlkYXRlRmxvdygpO1xuXG4gIGlmIChmbG93VHlwZSkge1xuICAgIGNvbnN0IHNka1VybCA9IHRoaXMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0uaW5uZXJIVE1MLnRyaW0oKTtcblxuICAgIC8vIHVwZGF0ZSBpbml0RGF0YSBmcm9tIGVudiBjb25maWdcbiAgICBhdXRvRmlsbFVVSUQoa2V5KTtcblxuICAgIGlmIChzZGtVcmwpIHtcbiAgICAgIGJlbmNobWFya1N0YXRlLnNka1VybCA9IHNka1VybDtcbiAgICAgIC8vIHJ1bih2YWwsIHVzZXJUeXBlID09PSAnbmV3X3VzZXJfZmxvdycgPyByZXR1cm5pbmdGbG93IDogbmV3VXNlckZsb3cpO1xuXG4gICAgICBsb2FkU2RrKHNka1VybCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2RrJyk7XG4gICAgICAgIGxldCBhY2Nlc3NUb2tlbjtcbiAgICAgICAgbGV0IGNvbnN1bWVyUHJlc2VudDtcblxuICAgICAgICAvLyBEZWZhdWx0IHNlbGVjdGlvbjogVmlzYSBpcyB0aGUgU1JDLWlcbiAgICAgICAgY29uc3QgdmNvQWRhcHRlciA9IHdpbmRvdy52QWRhcHRlcnMuVmlzYVNSQ0k7XG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSBuZXcgdmNvQWRhcHRlcigpO1xuXG4gICAgICAgIHdpbmRvdy5jMnBfYWRhcHRlciA9IGFkYXB0ZXI7XG5cbiAgICAgICAgLy8gaW5pdFxuICAgICAgICBhd2FpdCBpbml0KGFkYXB0ZXIsIGtleSwgbG9hZFN0YXJ0KS5jYXRjaChjYXRjaEVycik7XG4gICAgICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcblxuICAgICAgICAvLyBpc1JlY29nbml6ZWRcbiAgICAgICAgYWNjZXNzVG9rZW4gPSBhd2FpdCBpc1JlY29nbml6ZWQoYWRhcHRlcikuY2F0Y2goY2F0Y2hFcnIpO1xuICAgICAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG5cbiAgICAgICAgLy8gaWRlbnRpdHkvYXV0aCBmbG93XG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oYHJlY29nbml6ZSAyMDQgLSBubyBhY2Nlc3MgdG9rZW5gKTtcbiAgICAgICAgICBjb25zdW1lclByZXNlbnQgPSBhd2FpdCBhdXRoRmxvdyhhZnRlckF1dGhSZXR1cm5pbmcsIHVwZGF0ZUJlbmNobWFya3MpLmNhdGNoKGNhdGNoRXJyKTtcbiAgICAgICAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG5cbiAgICAgICAgICBpZiAoY29uc3VtZXJQcmVzZW50KSB7XG4gICAgICAgICAgICAvLyByZWNvZ25pemVkIHJldHVybiBvYmpcbiAgICAgICAgICAgIGlmIChjb25zdW1lclByZXNlbnQuY29uc3VtZXJQcmVzZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBhd2FpdCBhZnRlckF1dGhOZXdVc2VyKGFkYXB0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zdW1lclByZXNlbnQuaWRUb2tlbikge1xuICAgICAgICAgICAgICBhd2FpdCBhZnRlckF1dGhSZXR1cm5pbmcoYWRhcHRlciwgY29uc3VtZXJQcmVzZW50LmlkVG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXdhaXQgYWZ0ZXJBdXRoUmV0dXJuaW5nKGFkYXB0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhGbG93IGZhaWx1cmUgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tSZXR1cm5pbmdSZWNvZ25pemVkXSBnb3QgYWNjZXNzVG9rZW4nLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgcmV0dXJuaW5nRmxvdyhhY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RhcnRGbG93O1xuIiwiaW1wb3J0IHN0YXJ0RmxvdyBmcm9tICcuLi8uLi9mbG93cy9zdGFydC5qcyc7XG5pbXBvcnQgeyBnZWwgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzLmpzJztcblxuZXhwb3J0IGNvbnN0IGJpbmRTZGtHbyA9ICgpID0+IHtcbiAgZ2VsKCdnb192MycpLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgc3RhcnRGbG93LmNhbGwoZ2VsKCdzZGtfcGlja2VyX3YzJykpO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlU2RrU2VsZWN0aW9uID0gZSA9PiB7XG4gIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nkay1waWNrZXInKSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzZGsnLCBlLnRhcmdldC52YWx1ZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiaW5kU2RrU2VsZWN0aW9uID0gKCkgPT4ge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVTZGtTZWxlY3Rpb24pO1xufVxuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscyc7XG5pbXBvcnQgeyBjYW5Vc2VUZXN0Q2FyZEFwaSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvY2FuLXVzZS10ZXN0LWNhcmRzLWFwaSc7XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVIYW5kbGVyID0gYXN5bmMgZSA9PiB7XG4gIGlmIChlLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZigndG9nZ2xlLWhlYWRlcicpID4gLTEpIHtcbiAgICBlLnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC50b2dnbGUoXCJvcGVuXCIpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbn1cblxuaWYgKCFjYW5Vc2VUZXN0Q2FyZEFwaSgpKSB7XG4gIGdlbCgncGFuX2VudHJ5Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG59XG4iLCJpbXBvcnQgeyB1dWlkdjQgfSBmcm9tICcuL3V1aWQnO1xuXG4vLyBleHBvcnQgZGVmYXVsdCAoKSA9PiBgJHt1dWlkdjQoKX1AbWFpbGluYXRvci5jb21gO1xuZXhwb3J0IGRlZmF1bHQgKCkgPT4gYGMycF8ke0RhdGUubm93KCl9QG1haWxpbmF0b3IuY29tYDtcbiIsImltcG9ydCB7IGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBpbmplY3RDb21wbGlhbmNlU2V0dGluZ3MsIHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncyB9IGZyb20gJy4uL2hlbHBlcnMvY29tcGxpYW5jZS1zZXR0aW5ncy5qcyc7XG5cbmV4cG9ydCBjb25zdCBiaW5kQ29tcGxpYW5jZVRvZ2dsZSA9ICgpID0+IHtcbiAgZ2VsKCdjb21wbGlhbmNlX3RvZ2dsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgIGlmIChlLnRhcmdldC5jaGVja2VkKSB7XG4gICAgICBpbmplY3RDb21wbGlhbmNlU2V0dGluZ3MoKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzZXRDb21wbGlhbmNlJywgJ29uJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncygpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NldENvbXBsaWFuY2UnLCAnb2ZmJyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NldENvbXBsaWFuY2UnKSA9PT0gJ29uJykge1xuICAgIGdlbCgnY29tcGxpYW5jZV90b2dnbGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgaW5pdEJpblNlbGVjdG9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9jYXJkLWJpbi1zZWxlY3Rvcic7XG5pbXBvcnQgeyBiaW5kU2RrR28sIGJpbmRTZGtTZWxlY3Rpb24gfSBmcm9tICcuLi9jb21wb25lbnRzL3Nkay1zZWxlY3Rvcic7XG5pbXBvcnQgeyB0b2dnbGVIYW5kbGVyIH0gZnJvbSAnLi4vY29tcG9uZW50cy90b2dnbGUnO1xuXG5pbXBvcnQgeyBjYXRjaEVyciwgZ2VsLCBxcyB9IGZyb20gJy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuaW1wb3J0IHsgZW1haWxTZXR0ZXIgfSBmcm9tICcuLi9oZWxwZXJzL2VtYWlsLmpzJztcbmltcG9ydCBnZW5lcmF0ZUVtYWlsQWRkcmVzcyBmcm9tICcuLi9oZWxwZXJzL2dlbmVyYXRlLWVtYWlsLWFkZHJlc3MuanMnO1xuaW1wb3J0IHsgaW5pdERhdGEgfSBmcm9tICcuLi9zdHVicy9kYXRhLmpzJztcbmltcG9ydCB7IGJpbmRDb21wbGlhbmNlVG9nZ2xlIH0gZnJvbSAnLi9iaW5kLWNvbXBsaWFuY2UuanMnO1xuXG5sZXQgYXV0b21hdGVUaW1lb3V0O1xubGV0IGF1dG9tYXRlQ2xpY2tUaW1lb3V0O1xubGV0IHRpbWVySW50ZXJ2YWw7XG5cbmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgdHJ5IHtcbiAgICB0b2dnbGVIYW5kbGVyKGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2F0Y2hFcnIoZSk7XG4gIH1cbn0pO1xuXG5jb25zdCBoYW5kbGVCdWJibGVkRXZlbnRzID0gYXN5bmMgZSA9PiB7XG4gIHN3aXRjaCAoZS50YXJnZXQuaWQpIHtcbiAgICBjYXNlICdhZGRfY2FyZF9mbG93JzpcbiAgICBjYXNlICdyZXR1cm5pbmdfZmxvdyc6XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZmxvd19zZWxlY3RvcicsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0b21hdGUnOlxuICAgICAgbGV0IHRpbWVyVmFsdWUgPSAzMDAwMDtcbiAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRvbWF0ZScsICd0cnVlJyk7XG4gICAgICAgIGF1dG9tYXRlQ2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZ2VsKCdnb192MycpLmNsaWNrKCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICBhdXRvbWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0sIHRpbWVyVmFsdWUpO1xuICAgICAgICBsZXQgZGlzcGxheVRpbWVyID0gdGltZXJWYWx1ZSAvIDEwMDA7XG4gICAgICAgIHRpbWVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgZGlzcGxheVRpbWVyIC09IDE7XG4gICAgICAgICAgZ2VsKCd0aW1lcicpLmlubmVySFRNTCA9IGAke2Rpc3BsYXlUaW1lcn1zIHVudGlsIHJlZnJlc2hgO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSAnZGlzYWJsZS11aSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0b21hdGUnLCAnZmFsc2UnKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9tYXRlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9tYXRlVGltZW91dCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJbnRlcnZhbCk7XG4gICAgICAgIGdlbCgndGltZXInKS5pbm5lckhUTUwgPSBgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cblxuXG5cbmV4cG9ydCBjb25zdCBoYW5kbGVDb25maWdBcmVhID0gKCkgPT4ge1xuICBnZWwoJ2NvbmZpZycpLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGluaXREYXRhLCBudWxsLCAyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdHRhY2hFdmVudEhhbmRsZXJzID0gKCkgPT4ge1xuICBjb25zdCBsc0VtYWlsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtYWlsJyk7XG4gIGNvbnN0IGF1dG9tYXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dG9tYXRlJyk7XG4gIGNvbnN0IHVzZXJUeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfZmxvd19zZWxlY3RvcicpO1xuICBjb25zdCBmbG93VHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmbG93X3NlbGVjdG9yJyk7XG4gIFxuICBiaW5kQ29tcGxpYW5jZVRvZ2dsZSgpO1xuICBiaW5kU2RrR28oKTtcbiAgYmluZFNka1NlbGVjdGlvbigpO1xuXG4gIGluaXRCaW5TZWxlY3RvcigpO1xuXG5cbiAgLy8gbXVsdGlzZWxlY3RcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gJ09QVElPTicgJiYgZS50YXJnZXQuY2xhc3NOYW1lID09PSAnaGlzdG9yaWNhbF9lbWFpbF9vcHRpb24nKSB7XG4gICAgICBlLnRhcmdldC52YWx1ZSAmJiBlbWFpbFNldHRlcihlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIGRyb3Bkb3duXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnU0VMRUNUJyAmJiBlLnRhcmdldC5pZCA9PT0gJ2VtYWlsX2hpc3RvcmljYWwnKSB7XG4gICAgICBlLnRhcmdldC52YWx1ZSAmJiBlbWFpbFNldHRlcihlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBuZXcgdXNlclxuICBnZWwoJ25ld191c2VyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgbmV3RW1haWwgPSBnZW5lcmF0ZUVtYWlsQWRkcmVzcygpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdlbWFpbCcsIG5ld0VtYWlsKTtcbiAgICBnZWwoJ2VtYWlsSW5wdXQnKS52YWx1ZSA9IG5ld0VtYWlsO1xuICB9KTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICBoYW5kbGVCdWJibGVkRXZlbnRzKGUpO1xuICB9KTtcblxuICBpZiAobHNFbWFpbCkge1xuICAgIGVtYWlsU2V0dGVyKGxzRW1haWwpO1xuICB9XG5cbiAgaWYgKGF1dG9tYXRlID09PSAndHJ1ZScpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYXV0b21hdGUgaXMgdHJ1ZScpO1xuICAgIGNvbnN0IGNiID0gZ2VsKCdhdXRvbWF0ZScpO1xuICAgIGNiICYmIChjYi5jaGVja2VkID0gdHJ1ZSk7XG4gICAgY29uc3QgZXZ0ID0gbmV3IEV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfSk7XG4gICAgY2IuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgaGFuZGxlQ29uZmlnQXJlYSgpO1xuXG4gIGlmICh1c2VyVHlwZSkge1xuICAgIHFzKGBpbnB1dFt2YWx1ZT1cIiR7dXNlclR5cGV9XCJdYCkgJiYgKHFzKGBpbnB1dFt2YWx1ZT1cIiR7dXNlclR5cGV9XCJdYCkuY2hlY2tlZCA9IHRydWUpO1xuICB9XG4gIGlmIChmbG93VHlwZSkge1xuICAgIHFzKGBpbnB1dFt2YWx1ZT1cIiR7Zmxvd1R5cGV9XCJdYCkgJiYgKHFzKGBpbnB1dFt2YWx1ZT1cIiR7Zmxvd1R5cGV9XCJdYCkuY2hlY2tlZCA9IHRydWUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBzZXRIaXN0b3JpY2FsRW1haWxzIH0gZnJvbSAnLi9oZWxwZXJzL2VtYWlsLmpzJztcbmltcG9ydCB7IGJ1aWxkU2RrUGlja2VyIH0gZnJvbSAnLi91aS9nZW5lcmF0ZS1zZGstbGlzdC5qcyc7XG5pbXBvcnQgeyBhdHRhY2hFdmVudEhhbmRsZXJzIH0gZnJvbSAnLi91aS9ldmVudC1oYW5kbGVycyc7XG5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG5idWlsZFNka1BpY2tlcigpO1xuc2V0SGlzdG9yaWNhbEVtYWlscygpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///157\n")}},__webpack_module_cache__={};function __webpack_require__(n){var c=__webpack_module_cache__[n];if(void 0!==c)return c.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__(157)})();