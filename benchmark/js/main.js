/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={1:(module,exports)=>{eval('/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar Jose = {};\n\n/**\n * Javascript Object Signing and Encryption library.\n *\n * @author Alok Menghrajani <alok@squareup.com>\n */\n\n/**\n * Initializes a JoseJWE object.\n */\nvar JoseJWE = {};\n\n/**\n * Initializes a JoseJWS object.\n */\nvar JoseJWS = {};\n\n/**\n * Set crypto provider to use (window.crypto, node-webcrypto-ossl, node-webcrypto-pkcs11 etc.).\n */\nexports.setCrypto = function (cp) {\n  Jose.crypto = cp;\n};\n\n/**\n * Default to the global "crypto" variable\n */\nif (typeof(crypto) !== \'undefined\') {\n  exports.setCrypto(crypto);\n}\n\n/**\n * Use Node versions of atob, btoa functions outside the browser\n */\nif (typeof atob !== "function") {\n  atob = function (str) {\n    return new Buffer(str, \'base64\').toString(\'binary\');\n  };\n}\n\nif (typeof btoa !== "function") {\n  btoa = function (str) {\n    var buffer;\n    if (str instanceof Buffer) {\n      buffer = str;\n    } else {\n      buffer = new Buffer(str.toString(), \'binary\');\n    }\n    return buffer.toString(\'base64\');\n  };\n}\n\n/**\n * Checks if we have all the required APIs.\n *\n * It might make sense to take a Cryptographer and delegate some of the checks\n * to the cryptographer. I however wanted to keep things simple, so I put all\n * the checks here for now.\n *\n * This list is generated manually and needs to be kept up-to-date.\n *\n * Casual testing shows that:\n * - things work in Chrome 40.0.2214.115\n * - things work in Firefox 35.0.1\n * - Safari 7.1.3 doesn\'t support JWK keys.\n * - Internet Explorer doesn\'t support Promises.\n *\n * Note: We don\'t check if the browser supports specific crypto operations.\n *       I.e. it\'s possible for this function to return true, but encryption or\n *       decryption to subsequently fail because the browser does not support a\n *       given encryption, decryption, key wrapping, key unwrapping or hmac\n *       operation.\n *\n * @return bool\n */\nJose.caniuse = function() {\n  var r = true;\n\n  // Promises/A+ (https://promisesaplus.com/)\n  r = r && (typeof Promise == "function");\n  r = r && (typeof Promise.reject == "function");\n  r = r && (typeof Promise.prototype.then == "function");\n  r = r && (typeof Promise.all == "function");\n\n  // Crypto (http://www.w3.org/TR/WebCryptoAPI/)\n  r = r && (typeof Jose.crypto == "object");\n  r = r && (typeof Jose.crypto.subtle == "object");\n  r = r && (typeof Jose.crypto.getRandomValues == "function");\n  r = r && (typeof Jose.crypto.subtle.importKey == "function");\n  r = r && (typeof Jose.crypto.subtle.generateKey == "function");\n  r = r && (typeof Jose.crypto.subtle.exportKey == "function");\n  r = r && (typeof Jose.crypto.subtle.wrapKey == "function");\n  r = r && (typeof Jose.crypto.subtle.unwrapKey == "function");\n  r = r && (typeof Jose.crypto.subtle.encrypt == "function");\n  r = r && (typeof Jose.crypto.subtle.decrypt == "function");\n  r = r && (typeof Jose.crypto.subtle.sign == "function");\n\n  // ArrayBuffer (http://people.mozilla.org/~jorendorff/es6-draft.html#sec-arraybuffer-constructor)\n  r = r && (typeof ArrayBuffer == "function");\n  r = r && (typeof Uint8Array == "function" || typeof Uint8Array == "object"); // Safari uses "object"\n  r = r && (typeof Uint32Array == "function" || typeof Uint32Array == "object"); // Safari uses "object"\n  // skipping Uint32Array.prototype.buffer because https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-%typedarrayprototype%-object\n\n  // JSON (http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)\n  r = r && (typeof JSON == "object");\n  r = r && (typeof JSON.parse == "function");\n  r = r && (typeof JSON.stringify == "function");\n\n  // Base64 (http://www.w3.org/TR/html5/webappapis.html#dom-windowbase64-atob)\n  r = r && (typeof atob == "function");\n  r = r && (typeof btoa == "function");\n\n  // skipping Array functions (map, join, push, length, etc.)\n  // skipping String functions (split, charCodeAt, fromCharCode, replace, etc.)\n  // skipping regexp.test and parseInt\n\n  return r;\n};\n\n/**\n * Feel free to override this function.\n */\nJose.assert = function(expr, msg) {\n  if (!expr) {\n    throw new Error(msg);\n  }\n};\n\nexports.Jose = Jose;\nexports.JoseJWE = JoseJWE;\nexports.JoseJWS = JoseJWS;\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The WebCryptographer uses http://www.w3.org/TR/WebCryptoAPI/ to perform\n * various crypto operations. In theory, this should help build the library with\n * different underlying crypto APIs. I\'m however unclear if we\'ll run into code\n * duplication or callback vs Promise based API issues.\n */\nvar WebCryptographer = function() {\n  this.setKeyEncryptionAlgorithm("RSA-OAEP");\n  this.setContentEncryptionAlgorithm("A256GCM");\n  this.setContentSignAlgorithm("RS256");\n};\n\nJose.WebCryptographer = WebCryptographer;\n\n/**\n * Overrides the default key encryption algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setKeyEncryptionAlgorithm = function(alg) {\n  this.key_encryption = getCryptoConfig(alg);\n};\n\nWebCryptographer.prototype.getKeyEncryptionAlgorithm = function() {\n  return this.key_encryption.jwe_name;\n};\n\n/**\n * Overrides the default content encryption algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setContentEncryptionAlgorithm = function(alg) {\n  this.content_encryption = getCryptoConfig(alg);\n};\n\nWebCryptographer.prototype.getContentEncryptionAlgorithm = function() {\n  return this.content_encryption.jwe_name;\n};\n\n/**\n * Overrides the default content sign algorithm\n * @param alg  string\n */\nWebCryptographer.prototype.setContentSignAlgorithm = function(alg) {\n  this.content_sign = getSignConfig(alg);\n};\n\nWebCryptographer.prototype.getContentSignAlgorithm = function() {\n  return this.content_sign.jwa_name;\n};\n\n/**\n * Generates an IV.\n * This function mainly exists so that it can be mocked for testing purpose.\n *\n * @return Uint8Array with random bytes\n */\nWebCryptographer.prototype.createIV = function() {\n  var iv = new Uint8Array(new Array(this.content_encryption.iv_bytes));\n  return Jose.crypto.getRandomValues(iv);\n};\n\n/**\n * Creates a random content encryption key.\n * This function mainly exists so that it can be mocked for testing purpose.\n *\n * @return Promise<CryptoKey>\n */\nWebCryptographer.prototype.createCek = function() {\n  var hack = getCekWorkaround(this.content_encryption);\n  return Jose.crypto.subtle.generateKey(hack.id, true, hack.enc_op);\n};\n\nWebCryptographer.prototype.wrapCek = function(cek, key) {\n  return Jose.crypto.subtle.wrapKey("raw", cek, key, this.key_encryption.id);\n};\n\nWebCryptographer.prototype.unwrapCek = function(cek, key) {\n  var hack = getCekWorkaround(this.content_encryption);\n  var extractable = (this.content_encryption.specific_cek_bytes > 0);\n  var key_encryption = this.key_encryption.id;\n\n  return Jose.crypto.subtle.unwrapKey("raw", cek, key, key_encryption, hack.id, extractable, hack.dec_op);\n};\n\n/**\n * Returns algorithm and operation needed to create a CEK.\n *\n * In some cases, e.g. A128CBC-HS256, the CEK gets split into two keys. The Web\n * Crypto API does not allow us to generate an arbitrary number of bytes and\n * then create a CryptoKey without any associated algorithm. We therefore piggy\n * back on AES-CBS and HMAC which allows the creation of CEKs of size 16, 32, 64\n * and 128 bytes.\n */\nvar getCekWorkaround = function(alg) {\n  var len = alg.specific_cek_bytes;\n  if (len) {\n    if (len == 16) {\n      return {id: {name: "AES-CBC", length: 128}, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n    } else if (len == 32) {\n      return {id: {name: "AES-CBC", length: 256}, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n    } else if (len == 64) {\n      return {id: {name: "HMAC", hash: {name: "SHA-256"}}, enc_op: ["sign"], dec_op: ["verify"]};\n    } else if (len == 128) {\n      return {id: {name: "HMAC", hash: {name: "SHA-384"}}, enc_op: ["sign"], dec_op: ["verify"]};\n    } else {\n      Jose.assert(false, "getCekWorkaround: invalid len");\n    }\n  }\n  return {id: alg.id, enc_op: ["encrypt"], dec_op: ["decrypt"]};\n};\n\n/**\n * Encrypts plain_text with cek.\n *\n * @param iv          Uint8Array\n * @param aad         Uint8Array\n * @param cek_promise Promise<CryptoKey>\n * @param plain_text  Uint8Array\n * @return Promise<json>\n */\nWebCryptographer.prototype.encrypt = function(iv, aad, cek_promise, plain_text) {\n  var config = this.content_encryption;\n  if (iv.length != config.iv_bytes) {\n    return Promise.reject(Error("invalid IV length"));\n  }\n  if (config.auth.aead) {\n    var tag_bytes = config.auth.tag_bytes;\n\n    var enc = {\n      name: config.id.name,\n      iv: iv,\n      additionalData: aad,\n      tagLength: tag_bytes * 8\n    };\n\n    return cek_promise.then(function(cek) {\n      return Jose.crypto.subtle.encrypt(enc, cek, plain_text).then(function(cipher_text) {\n        var offset = cipher_text.byteLength - tag_bytes;\n        return {\n          cipher: cipher_text.slice(0, offset),\n          tag: cipher_text.slice(offset)\n        };\n      });\n    });\n  } else {\n    var keys = splitKey(config, cek_promise, ["encrypt"]);\n    var mac_key_promise = keys[0];\n    var enc_key_promise = keys[1];\n\n    // Encrypt the plain text\n    var cipher_text_promise = enc_key_promise.then(function(enc_key) {\n      var enc = {\n        name: config.id.name,\n        iv: iv\n      };\n      return Jose.crypto.subtle.encrypt(enc, enc_key, plain_text);\n    });\n\n    // compute MAC\n    var mac_promise = cipher_text_promise.then(function(cipher_text) {\n      return truncatedMac(\n        config,\n        mac_key_promise,\n        aad,\n        iv,\n        cipher_text);\n    });\n\n    return Promise.all([cipher_text_promise, mac_promise]).then(function(all) {\n      var cipher_text = all[0];\n      var mac = all[1];\n      return {\n        cipher: cipher_text,\n        tag: mac\n      };\n    });\n  }\n};\n\n/**\n * Decrypts cipher_text with cek. Validates the tag.\n *\n * @param cek_promise    Promise<CryptoKey>\n * @param aad protected header\n * @param iv IV\n * @param cipher_text text to be decrypted\n * @param tag to be verified\n * @return Promise<string>\n */\nWebCryptographer.prototype.decrypt = function(cek_promise, aad, iv, cipher_text, tag) {\n  /**\n   * Compares two Uint8Arrays in constant time.\n   *\n   * @return Promise<void>\n   */\n  var compare = function(config, mac_key_promise, arr1, arr2) {\n    Jose.assert(arr1 instanceof Uint8Array, "compare: invalid input");\n    Jose.assert(arr2 instanceof Uint8Array, "compare: invalid input");\n\n    return mac_key_promise.then(function(mac_key) {\n      var hash1 = Jose.crypto.subtle.sign(config.auth.id, mac_key, arr1);\n      var hash2 = Jose.crypto.subtle.sign(config.auth.id, mac_key, arr2);\n      return Promise.all([hash1, hash2]).then(function(all) {\n        var hash1 = new Uint8Array(all[0]);\n        var hash2 = new Uint8Array(all[1]);\n        if (hash1.length != hash2.length) {\n          throw new Error("compare failed");\n        }\n        for (var i = 0; i < hash1.length; i++) {\n          if (hash1[i] != hash2[i]) {\n            throw new Error("compare failed");\n          }\n        }\n        return Promise.resolve(null);\n      });\n    });\n  };\n\n  if (iv.length != this.content_encryption.iv_bytes) {\n    return Promise.reject(Error("decryptCiphertext: invalid IV"));\n  }\n\n  var config = this.content_encryption;\n  if (config.auth.aead) {\n    var dec = {\n      name: config.id.name,\n      iv: iv,\n      additionalData: aad,\n      tagLength: config.auth.tag_bytes * 8\n    };\n\n    return cek_promise.then(function(cek) {\n      var buf = Utils.arrayBufferConcat(cipher_text, tag);\n      return Jose.crypto.subtle.decrypt(dec, cek, buf);\n    });\n  } else {\n    var keys = splitKey(config, cek_promise, ["decrypt"]);\n    var mac_key_promise = keys[0];\n    var enc_key_promise = keys[1];\n\n    // Validate the MAC\n    var mac_promise = truncatedMac(\n      config,\n      mac_key_promise,\n      aad,\n      iv,\n      cipher_text);\n\n    return Promise.all([enc_key_promise, mac_promise]).then(function(all) {\n      var enc_key = all[0];\n      var mac = all[1];\n\n      return compare(config, mac_key_promise, new Uint8Array(mac), tag).then(function() {\n        var dec = {\n          name: config.id.name,\n          iv: iv\n        };\n        return Jose.crypto.subtle.decrypt(dec, enc_key, cipher_text);\n      }).catch(function(err) {\n        return Promise.reject(Error("decryptCiphertext: MAC failed."));\n      });\n    });\n  }\n};\n\n/**\n * Signs plain_text.\n *\n * @param aad         json\n * @param payload     String or json\n * @param key_promise Promise<CryptoKey>\n * @return Promise<ArrayBuffer>\n */\nWebCryptographer.prototype.sign = function(aad, payload, key_promise) {\n  var config = this.content_sign;\n\n  if (aad.alg) {\n    config = getSignConfig(aad.alg);\n  }\n\n  // Encrypt the plain text\n  return key_promise.then(function(key) {\n    return Jose.crypto.subtle.sign(config.id, key, Utils.arrayFromString(Utils.Base64Url.encode(JSON.stringify(aad)) + \'.\' + Utils.Base64Url.encodeArray(payload)));\n  });\n};\n\n/**\n * Verify JWS.\n *\n * @param payload     Base64Url encoded payload\n * @param aad         String Base64Url encoded JSON representation of the protected JWS header\n * @param signature   Uint8Array containing the signature\n * @param key_promise Promise<CryptoKey>\n * @param key_id      value of the kid JoseHeader, it\'ll be passed as part of the result to the returned promise\n * @return Promise<json>\n */\nWebCryptographer.prototype.verify = function(aad, payload, signature, key_promise, key_id) {\n  var config = this.content_sign;\n\n  return key_promise.then(function(key) {\n    config = getSignConfig(getJwaNameForSignKey(key));\n    return Jose.crypto.subtle.verify(config.id, key, signature, Utils.arrayFromString(aad + "." + payload)).then(function(res) {\n      return {kid: key_id, verified: res};\n    });\n  });\n};\n\nJose.WebCryptographer.keyId = function(rsa_key) {\n  return Utils.sha256(rsa_key.n + "+" + rsa_key.d);\n};\n\n/**\n * Splits a CEK into two pieces: a MAC key and an ENC key.\n *\n * This code is structured around the fact that the crypto API does not provide\n * a way to validate truncated MACs. The MAC key is therefore always imported to\n * sign data.\n *\n * @param config (used for key lengths & algorithms)\n * @param cek_promise Promise<CryptoKey>  CEK key to split\n * @param purpose Array<String> usages of the imported key\n * @return [Promise<mac key>, Promise<enc key>]\n */\nvar splitKey = function(config, cek_promise, purpose) {\n  // We need to split the CEK key into a MAC and ENC keys\n  var cek_bytes_promise = cek_promise.then(function(cek) {\n    return Jose.crypto.subtle.exportKey("raw", cek);\n  });\n  var mac_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n    if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n      return Promise.reject(Error("encryptPlainText: incorrect cek length"));\n    }\n    var bytes = cek_bytes.slice(0, config.auth.key_bytes);\n    return Jose.crypto.subtle.importKey("raw", bytes, config.auth.id, false, ["sign"]);\n  });\n  var enc_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n    if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n      return Promise.reject(Error("encryptPlainText: incorrect cek length"));\n    }\n    var bytes = cek_bytes.slice(config.auth.key_bytes);\n    return Jose.crypto.subtle.importKey("raw", bytes, config.id, false, purpose);\n  });\n  return [mac_key_promise, enc_key_promise];\n};\n\n/**\n * Converts the Jose web algorithms into data which is\n * useful for the Web Crypto API.\n *\n * length = in bits\n * bytes = in bytes\n */\nvar getCryptoConfig = function(alg) {\n  switch (alg) {\n    // Key encryption\n    case "RSA-OAEP":\n      return {\n        jwe_name: "RSA-OAEP",\n        id: {name: "RSA-OAEP", hash: {name: "SHA-1"}}\n      };\n    case "RSA-OAEP-256":\n      // return {\n      //   jwe_name: "RSA-OAEP-256",\n      //   id: {name: "RSA-OAEP-256", hash: {name: "SHA-256"}}\n      // };\n\n      // ORIGINAL SQUARE HEADER CONFIG\n      return {\n        jwe_name: "RSA-OAEP-256",\n        id: {name: "RSA-OAEP", hash: {name: "SHA-256"}}\n      };\n    case "A128KW":\n      return {\n        jwe_name: "A128KW",\n        id: {name: "AES-KW", length: 128}\n      };\n    case "A256KW":\n      return {\n        jwe_name: "A256KW",\n        id: {name: "AES-KW", length: 256}\n      };\n    case "dir":\n      return {\n        jwe_name: "dir"\n      };\n\n    // Content encryption\n    case "A128CBC-HS256":\n      return {\n        jwe_name: "A128CBC-HS256",\n        id: {name: "AES-CBC", length: 128},\n        iv_bytes: 16,\n        specific_cek_bytes: 32,\n        auth: {\n          key_bytes: 16,\n          id: {name: "HMAC", hash: {name: "SHA-256"}},\n          truncated_bytes: 16\n        }\n      };\n    case "A256CBC-HS512":\n      return {\n        jwe_name: "A256CBC-HS512",\n        id: {name: "AES-CBC", length: 256},\n        iv_bytes: 16,\n        specific_cek_bytes: 64,\n        auth: {\n          key_bytes: 32,\n          id: {name: "HMAC", hash: {name: "SHA-512"}},\n          truncated_bytes: 32\n        }\n      };\n    case "A128GCM":\n      return {\n        jwe_name: "A128GCM",\n        id: {name: "AES-GCM", length: 128},\n        iv_bytes: 12,\n        auth: {\n          aead: true,\n          tag_bytes: 16\n        }\n      };\n    case "A256GCM":\n      return {\n        jwe_name: "A256GCM",\n        id: {name: "AES-GCM", length: 256},\n        iv_bytes: 12,\n        auth: {\n          aead: true,\n          tag_bytes: 16\n        }\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n/**\n * Computes a truncated MAC.\n *\n * @param config              configuration\n * @param mac_key_promise     Promise<CryptoKey>  mac key\n * @param aad                 Uint8Array\n * @param iv                  Uint8Array\n * @param cipher_text         Uint8Array\n * @return Promise<buffer>    truncated MAC\n */\nvar truncatedMac = function(config, mac_key_promise, aad, iv, cipher_text) {\n  return mac_key_promise.then(function(mac_key) {\n    var al = new Uint8Array(Utils.arrayFromInt32(aad.length * 8));\n    var al_full = new Uint8Array(8);\n    al_full.set(al, 4);\n    var buf = Utils.arrayBufferConcat(aad, iv, cipher_text, al_full);\n    return Jose.crypto.subtle.sign(config.auth.id, mac_key, buf).then(function(bytes) {\n      return bytes.slice(0, config.auth.truncated_bytes);\n    });\n  });\n};\n\n/**\n * Converts the Jose web algorithms into data which is\n * useful for the Web Crypto API.\n */\nvar getSignConfig = function(alg) {\n\n  switch (alg) {\n    case "RS256":\n      return {\n        jwa_name: "RS256",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-256"}}\n      };\n    case "RS384":\n      return {\n        jwa_name: "RS384",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-384"}}\n      };\n    case "RS512":\n      return {\n        jwa_name: "RS512",\n        id: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-512"}}\n      };\n    case "PS256":\n      return {\n        jwa_name: "PS256",\n        id: {name: "RSA-PSS", hash: {name: "SHA-256"}, saltLength: 20}\n      };\n    case "PS384":\n      return {\n        jwa_name: "PS384",\n        id: {name: "RSA-PSS", hash: {name: "SHA-384"}, saltLength: 20}\n      };\n    case "PS512":\n      return {\n        jwa_name: "PS512",\n        id: {name: "RSA-PSS", hash: {name: "SHA-512"}, saltLength: 20}\n      };\n    case "HS256":\n      return {\n        jwa_name: "HS256",\n        id: {name: "HMAC", hash: {name: "SHA-256"}}\n      };\n    case "HS384":\n      return {\n        jwa_name: "HS384",\n        id: {name: "HMAC", hash: {name: "SHA-384"}}\n      };\n    case "HS512":\n      return {\n        jwa_name: "HS512",\n        id: {name: "HMAC", hash: {name: "SHA-512"}}\n      };\n    case "ES256":\n      return {\n        jwa_name: "ES256",\n        id: {name: "ECDSA", hash: {name: "SHA-256"}}\n      };\n    case "ES384":\n      return {\n        jwa_name: "ES384",\n        id: {name: "ECDSA", hash: {name: "SHA-384"}}\n      };\n    case "ES512":\n      return {\n        jwa_name: "ES512",\n        id: {name: "ECDSA", hash: {name: "SHA-512"}}\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n/**\n * Returns JWA name for a given CryptoKey\n * @param key CryptoKey\n */\nvar getJwaNameForSignKey = function(key) {\n\n  var rv = "",\n    sign_algo = key.algorithm.name,\n    hash_algo = key.algorithm.hash.name;\n\n  if(sign_algo == "RSASSA-PKCS1-v1_5") {\n    rv = "R";\n  } else if(sign_algo == "RSA-PSS") {\n    rv = "P";\n  } else {\n    throw new Error("unsupported sign/verify algorithm " + sign_algo);\n  }\n\n  if(hash_algo.indexOf("SHA-") === 0) {\n    rv += "S";\n  } else {\n    throw new Error("unsupported hash algorithm " + sign_algo);\n  }\n\n  rv += hash_algo.substring(4);\n\n  return rv;\n};\n\n/**\n * Derives key usage from algorithm\'s name\n *\n * @param alg String algorithm name\n * @returns {*}\n */\nvar getKeyUsageByAlg = function(alg) {\n\n  switch (alg) {\n    // signature\n    case "RS256":\n    case "RS384":\n    case "RS512":\n    case "PS256":\n    case "PS384":\n    case "PS512":\n    case "HS256":\n    case "HS384":\n    case "HS512":\n    case "ES256":\n    case "ES384":\n    case "ES512":\n      return {\n        publicKey: "verify",\n        privateKey: "sign"\n      };\n    // key encryption\n    case "RSA-OAEP":\n    case "RSA-OAEP-256":\n    case "A128KW":\n    case "A256KW":\n      return {\n        publicKey: "wrapKey",\n        privateKey: "unwrapKey"\n      };\n    default:\n      throw Error("unsupported algorithm: " + alg);\n  }\n};\n\n// Visa-specific\nmodule.exports = WebCryptographer;\n\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nJose.Utils = {};\nvar Utils = {};\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  public RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for \'e\').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nJose.Utils.importRsaPublicKey = function(rsa_key, alg) {\n  var jwk;\n  var config;\n  var usage = getKeyUsageByAlg(alg);\n\n  if (usage.publicKey == "wrapKey") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rsa_key, ["n", "e"]);\n    config = getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    config = getSignConfig(rk.alg);\n    jwk = Utils.convertRsaKey(rk, ["n", "e"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey("jwk", jwk, config.id, false, [usage.publicKey]);\n};\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP and RSA. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  private RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for \'e\').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nJose.Utils.importRsaPrivateKey = function(rsa_key, alg) {\n  var jwk;\n  var config;\n  var usage = getKeyUsageByAlg(alg);\n\n  if (usage.privateKey == "unwrapKey") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rsa_key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]);\n    config = getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n    config = getSignConfig(alg);\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    jwk = Utils.convertRsaKey(rk, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey("jwk", jwk, config.id, false, [usage.privateKey]);\n};\n\n// Private functions\n\nUtils.isString = function(str) {\n  return ((typeof(str) == "string") || (str instanceof String));\n};\n\n/**\n * Takes an arrayish (an array, ArrayBuffer or Uint8Array)\n * and returns an array or a Uint8Array.\n *\n * @param arr  arrayish\n * @return array or Uint8Array\n */\nUtils.arrayish = function(arr) {\n  if (arr instanceof Array) {\n    return arr;\n  }\n  if (arr instanceof Uint8Array) {\n    return arr;\n  }\n  if (arr instanceof ArrayBuffer) {\n    return new Uint8Array(arr);\n  }\n  Jose.assert(false, "arrayish: invalid input");\n};\n\n/**\n * Checks if an RSA key contains all the expected parameters. Also checks their\n * types. Converts hex encoded strings (or numbers) to base64.\n *\n * @param rsa_key     RSA key in json format. Parameters can be base64 encoded,\n *                    strings or number (for \'e\').\n * @param parameters  array<string>\n * @return json\n */\nUtils.convertRsaKey = function(rsa_key, parameters) {\n  var r = {};\n  var alg;\n\n  // Check that we have all the parameters\n  var missing = [];\n  parameters.map(function(p){if (typeof(rsa_key[p]) == "undefined") { missing.push(p); }});\n\n  if (missing.length > 0) {\n    Jose.assert(false, "convertRsaKey: Was expecting " + missing.join());\n  }\n\n  // kty is either missing or is set to "RSA"\n  if (typeof(rsa_key.kty) != "undefined") {\n    Jose.assert(rsa_key.kty == "RSA", "convertRsaKey: expecting rsa_key[\'kty\'] to be \'RSA\'");\n  }\n  r.kty = "RSA";\n\n  try {\n    getSignConfig(rsa_key.alg);\n    alg = rsa_key.alg;\n  } catch (err) {\n    try {\n      getCryptoConfig(rsa_key.alg);\n      alg = rsa_key.alg;\n    } catch (er) {\n      Jose.assert(alg, "convertRsaKey: expecting rsa_key[\'alg\'] to have a valid value");\n    }\n  }\n  r.alg = alg;\n\n  // note: we punt on checking key_ops\n\n  var intFromHex = function(e) {\n    return parseInt(e, 16);\n  };\n  for (var i = 0; i < parameters.length; i++) {\n    var p = parameters[i];\n    var v = rsa_key[p];\n    if (p == "e") {\n      if (typeof(v) == "number") {\n        v = Utils.Base64Url.encodeArray(Utils.stripLeadingZeros(Utils.arrayFromInt32(v)));\n      }\n    } else if (/^([0-9a-fA-F]{2}:)+[0-9a-fA-F]{2}$/.test(v)) {\n      var arr = v.split(":").map(intFromHex);\n      v = Utils.Base64Url.encodeArray(Utils.stripLeadingZeros(arr));\n    } else if (typeof(v) != "string") {\n      Jose.assert(false, "convertRsaKey: expecting rsa_key[\'" + p + "\'] to be a string");\n    }\n    r[p] = v;\n  }\n\n  return r;\n};\n\n/**\n * Converts a string into an array of ascii codes.\n *\n * @param str  ascii string\n * @return Uint8Array\n */\nUtils.arrayFromString = function(str) {\n  Jose.assert(Utils.isString(str), "arrayFromString: invalid input");\n  var arr = str.split(\'\').map(function(c) {\n    return c.charCodeAt(0);\n  });\n  return new Uint8Array(arr);\n};\n\n/**\n * Converts a string into an array of utf-8 codes.\n *\n* @param str  utf-8 string\n * @return Uint8Array\n */\nUtils.arrayFromUtf8String = function(str) {\n  Jose.assert(Utils.isString(str), "arrayFromUtf8String: invalid input");\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  str = unescape(encodeURIComponent(str));\n  return Utils.arrayFromString(str);\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  arrayish\n * @return ascii string\n */\nUtils.stringFromArray = function(arr) {\n  arr = Utils.arrayish(arr);\n  var r = \'\';\n  for (var i = 0; i < arr.length; i++) {\n    r += String.fromCharCode(arr[i]);\n  }\n\n  return r;\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  ArrayBuffer\n * @return ascii string\n */\nUtils.utf8StringFromArray = function(arr) {\n  Jose.assert(arr instanceof ArrayBuffer, "utf8StringFromArray: invalid input");\n\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  var r = Utils.stringFromArray(arr);\n  return decodeURIComponent(escape(r));\n};\n\n/**\n * Strips leading zero in an array.\n *\n * @param arr  arrayish\n * @return array\n */\nUtils.stripLeadingZeros = function(arr) {\n  if (arr instanceof ArrayBuffer) {\n    arr = new Uint8Array(arr);\n  }\n  var is_leading_zero = true;\n  var r = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (is_leading_zero && arr[i] === 0) {\n      continue;\n    }\n    is_leading_zero = false;\n    r.push(arr[i]);\n  }\n  return r;\n};\n\n/**\n * Converts a number into an array of 4 bytes (big endian).\n *\n * @param i  number\n * @return ArrayBuffer\n */\nUtils.arrayFromInt32 = function(i) {\n  Jose.assert(typeof(i) == "number", "arrayFromInt32: invalid input");\n  Jose.assert(i == i | 0, "arrayFromInt32: out of range");\n\n  var buf = new Uint8Array(new Uint32Array([i]).buffer);\n  var r = new Uint8Array(4);\n  for (var j = 0; j < 4; j++) {\n    r[j] = buf[3 - j];\n  }\n  return r.buffer;\n};\n\n/**\n * Concatenates arrayishes.\n *\n * @param arguments two or more arrayishes\n * @return Uint8Array\n */\nUtils.arrayBufferConcat = function(/* ... */) {\n  // Compute total size\n  var args = [];\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(Utils.arrayish(arguments[i]));\n    total += args[i].length;\n  }\n  var r = new Uint8Array(total);\n  var offset = 0;\n  for (i = 0; i < arguments.length; i++) {\n    for (var j = 0; j < args[i].length; j++) {\n      r[offset++] = args[i][j];\n    }\n  }\n  Jose.assert(offset == total, "arrayBufferConcat: unexpected offset");\n  return r;\n};\n\nUtils.Base64Url = {};\n\n/**\n * Base64Url encodes a string (no trailing \'=\')\n *\n * @param str  string\n * @return string\n */\nUtils.Base64Url.encode = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.encode: invalid input");\n  return btoa(str)\n    .replace(/\\+/g, "-")\n    .replace(/\\//g, "_")\n    .replace(/=+$/, "");\n};\n\n/**\n * Base64Url encodes an array\n *\n * @param arr array or ArrayBuffer\n * @return string\n */\nUtils.Base64Url.encodeArray = function(arr) {\n  return Utils.Base64Url.encode(Utils.stringFromArray(arr));\n};\n\n/**\n * Base64Url decodes a string\n *\n * @param str  string\n * @return string\n */\nUtils.Base64Url.decode = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.decode: invalid input");\n  // atob is nice and ignores missing \'=\'\n  return atob(str.replace(/-/g, "+").replace(/_/g, "/"));\n};\n\nUtils.Base64Url.decodeArray = function(str) {\n  Jose.assert(Utils.isString(str), "Base64Url.decodeArray: invalid input");\n  return Utils.arrayFromString(Utils.Base64Url.decode(str));\n};\n\nUtils.sha256 = function(str) {\n  // Browser docs indicate the first parameter to crypto.subtle.digest to be a\n  // DOMString. This was initially implemented as an object and continues to be\n  // supported, so we favor the older form for backwards compatibility.\n  return Jose.crypto.subtle.digest({name: "SHA-256"}, Utils.arrayFromString(str)).then(function(hash) {\n    return Utils.Base64Url.encodeArray(hash);\n  });\n};\n\nUtils.isCryptoKey = function(rsa_key) {\n  // Some browsers don\'t expose the CryptoKey as an object, so we need to check\n  // the constructor\'s name.\n  if (rsa_key.constructor.name == \'CryptoKey\') {\n    return true;\n  }\n\n  // In the presence of minifiers, relying on class names can be problematic,\n  // so let\'s also allow objects that have an \'algorithm\' property.\n  if (rsa_key.hasOwnProperty(\'algorithm\')) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = Utils;\n\n\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Handles encryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent).\n * @param key_promise    Promise<CryptoKey>, either RSA or shared key\n */\nJoseJWE.Encrypter = function(cryptographer, key_promise) {\n  this.cryptographer = cryptographer;\n  this.key_promise = key_promise;\n  this.userHeaders = {};\n};\n\n/**\n * Adds a key/value pair which will be included in the header.\n *\n * The data lives in plaintext (an attacker can read the header) but is tamper\n * proof (an attacker cannot modify the header).\n *\n * Note: some headers have semantic implications. E.g. if you set the "zip"\n * header, you are responsible for properly compressing plain_text before\n * calling encrypt().\n *\n * @param k  String\n * @param v  String\n */\nJoseJWE.Encrypter.prototype.addHeader = function(k, v) {\n  this.userHeaders[k] = v;\n};\n\n/**\n *\n * Visa-custom\n * returns the header value\n * \n * @param k  String\n */\nJoseJWE.Encrypter.prototype.getHeader = function(k) {\n  return this.userHeaders[k];\n};\n\n/**\n * Performs encryption.\n *\n * @param plain_text  utf-8 string\n * @return Promise<String>\n */\nJoseJWE.Encrypter.prototype.encrypt = function(plain_text) {\n  /**\n   * Encrypts plain_text with CEK.\n   *\n   * @param cek_promise  Promise<CryptoKey>\n   * @param plain_text   string\n   * @return Promise<json>\n   */\n  var encryptPlainText = function(cek_promise, plain_text) {\n    // Create header\n    var headers = {};\n    for (var i in this.userHeaders) {\n      headers[i] = this.userHeaders[i];\n    }\n\n    headers.alg = this.cryptographer.getKeyEncryptionAlgorithm();\n    headers.enc = this.cryptographer.getContentEncryptionAlgorithm();\n    var jwe_protected_header = Utils.Base64Url.encode(JSON.stringify(headers));\n\n    // Create the IV\n    var iv = this.cryptographer.createIV();\n\n    // Create the AAD\n    var aad = Utils.arrayFromString(jwe_protected_header);\n    plain_text = Utils.arrayFromUtf8String(plain_text);\n\n    return this.cryptographer.encrypt(iv, aad, cek_promise, plain_text).then(function(r) {\n      r.header = jwe_protected_header;\n      r.iv = iv;\n      return r;\n    });\n  };\n\n  var cek_promise, encrypted_cek;\n\n  if (this.cryptographer.getKeyEncryptionAlgorithm() == "dir") {\n    // with direct encryption, this.key_promise provides the cek\n    // and encrypted_cek is empty\n    cek_promise = Promise.resolve(this.key_promise);\n    encrypted_cek = [];\n  } else {\n    // Create a CEK key\n    cek_promise = this.cryptographer.createCek();\n\n    // Key & Cek allows us to create the encrypted_cek\n    encrypted_cek = Promise.all([this.key_promise, cek_promise]).then(function (all) {\n      var key = all[0];\n      var cek = all[1];\n      return this.cryptographer.wrapCek(cek, key);\n    }.bind(this));\n  }\n\n  // Cek allows us to encrypy the plain text\n  var enc_promise = encryptPlainText.bind(this, cek_promise, plain_text)();\n\n  // Once we have all the promises, we can base64 encode all the pieces.\n  return Promise.all([encrypted_cek, enc_promise]).then(function(all) {\n    var encrypted_cek = all[0];\n    var data = all[1];\n    return data.header + "." +\n      Utils.Base64Url.encodeArray(encrypted_cek) + "." +\n      Utils.Base64Url.encodeArray(data.iv) + "." +\n      Utils.Base64Url.encodeArray(data.cipher) + "." +\n      Utils.Base64Url.encodeArray(data.tag);\n  });\n};\n\n/*-\n * Copyright 2015 Peculiar Ventures\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Handles signature verification.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent). Keep\n *                       in mind that decryption mutates the cryptographer.\n * @param message        a JWS message\n * @param keyfinder (optional) a function returning a Promise<CryptoKey> given\n *                             a key id\n *\n * @author Patrizio Bruno <patrizio@desertconsulting.net>\n */\nJoseJWS.Verifier = function (cryptographer, message, keyfinder) {\n\n  var that = this,\n    alg,\n    jwt,\n    aad,\n    header,\n    payload,\n    signatures,\n    protectedHeader,\n    jwtRx = /^([0-9a-z_\\-]+)\\.([0-9a-z_\\-]+)\\.([0-9a-z_\\-]+)$/i;\n\n  that.cryptographer = cryptographer;\n\n  alg = cryptographer.getContentSignAlgorithm();\n\n  that.cryptographer = new Jose.WebCryptographer();\n\n  if (Utils.isString(message)) {\n    if ((jwt = jwtRx.exec(message))) {\n      if (jwt.length != 4) {\n        throw new Error("wrong JWS compact serialization format");\n      }\n\n      message = {\n        protected: jwt[1],\n        payload: jwt[2],\n        signature: jwt[3]\n      };\n    } else {\n      message = JSON.parse(message);\n    }\n  } else if (typeof message != "object") {\n    throw new Error("data format not supported");\n  }\n\n  aad = message.protected;\n  header = message.header;\n  payload = message.payload;\n  signatures = message.signatures instanceof Array ? message.signatures.slice(0) : [];\n\n  signatures.forEach(function (sign) {\n    sign.aad = sign.protected;\n    sign.protected = JSON.parse(Utils.Base64Url.decode(sign.protected));\n  });\n\n  that.aad = aad;\n  protectedHeader = Utils.Base64Url.decode(aad);\n  try {\n    protectedHeader = JSON.parse(protectedHeader);\n  } catch (e) {\n  }\n\n  if (!protectedHeader && !header) {\n    throw new Error("at least one header is required");\n  }\n\n  if (!protectedHeader.alg) {\n    throw new Error("\'alg\' is a mandatory header");\n  }\n\n  if (protectedHeader.alg != alg) {\n    throw new Error("the alg header \'" + protectedHeader.alg + "\' doesn\'t match the requested algorithm \'" + alg + "\'");\n  }\n\n  if (protectedHeader && protectedHeader.typ && protectedHeader.typ != "JWT") {\n    throw new Error("typ \'" + protectedHeader.typ + "\' not supported");\n  }\n\n  if (message.signature) {\n    signatures.unshift({\n      aad: aad,\n      protected: protectedHeader,\n      header: header,\n      signature: message.signature\n    });\n  }\n\n  that.signatures = [];\n  for(var i = 0; i < signatures.length; i++) {\n    that.signatures[i] = JSON.parse(JSON.stringify(signatures[i]));\n    that.signatures[i].signature = Utils.arrayFromString(Utils.Base64Url.decode(signatures[i].signature));\n  }\n\n  that.payload = payload;\n\n  that.key_promises = {};\n  that.waiting_kid = 0;\n\n  if (keyfinder) {\n    that.keyfinder = keyfinder;\n  }\n};\n\n/**\n * Add supported recipients to verify multiple signatures\n *\n * @param rsa_key        public RSA key in json format. Parameters can be base64\n *                       encoded, strings or number (for \'e\').\n * @param key_id         a string identifying the rsa_key. OPTIONAL\n * @param alg            String signature algorithm. OPTIONAL\n * @returns Promise<string> a Promise of a key id\n */\nJoseJWS.Verifier.prototype.addRecipient = function (rsa_key, key_id, alg) {\n\n  var that = this,\n    kid_promise,\n    key_promise = Utils.isCryptoKey(rsa_key) ? new Promise(function (resolve) {\n      resolve(rsa_key);\n    }) : Jose.Utils.importRsaPublicKey(rsa_key, alg || that.cryptographer.getContentSignAlgorithm(), "verify");\n\n  if (key_id) {\n    kid_promise = new Promise(function (resolve) {\n      resolve(key_id);\n    });\n  } else if (Utils.isCryptoKey(rsa_key)) {\n    throw new Error("key_id is a mandatory argument when the key is a CryptoKey");\n  } else {\n    console.log("it\'s not safe to not pass a key_id");\n    kid_promise = Jose.WebCryptographer.keyId(rsa_key);\n  }\n\n  that.waiting_kid++;\n\n  return kid_promise.then(function (kid) {\n    that.key_promises[kid] = key_promise;\n    that.waiting_kid--;\n    return kid;\n  });\n};\n\n\n/*-\n * Copyright 2015 Peculiar Ventures\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Handles decryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent). Keep\n *                       in mind that decryption mutates the cryptographer.\n *\n * @author Patrizio Bruno <patrizio@desertconsulting.net>\n */\nJoseJWS.Signer = function(cryptographer) {\n  this.cryptographer = cryptographer;\n\n  this.key_promises = {};\n  this.waiting_kid = 0;\n  this.headers = {};\n  this.signer_aads = {};\n  this.signer_headers = {};\n};\n\n/**\n * Adds a signer to JoseJWS instance. It\'ll be the on of the signers of the resulting JWS.\n *\n * @param rsa_key        private RSA key in json format, Parameters can be base64\n *                       encoded, strings or number (for \'e\'). Or CryptoKey\n * @param key_id         a string identifying the rsa_key. OPTIONAL\n * @param aad            Object protected header\n * @param header         Object unprotected header\n */\nJoseJWS.Signer.prototype.addSigner = function(rsa_key, key_id, aad, header) {\n  var that = this;\n  var key_promise;\n  if (Utils.isCryptoKey(rsa_key)) {\n    key_promise = new Promise(function(resolve) {\n      resolve(rsa_key);\n    });\n  } else {\n    var alg;\n    if (aad && aad.alg) {\n      alg = aad.alg;\n    } else {\n      alg = that.cryptographer.getContentSignAlgorithm();\n    }\n    key_promise = Jose.Utils.importRsaPrivateKey(rsa_key, alg, "sign");\n  }\n\n  var kid_promise;\n  if (key_id) {\n    kid_promise = new Promise(function(resolve) {\n      resolve(key_id);\n    });\n  } else if (Utils.isCryptoKey(rsa_key)) {\n    throw new Error("key_id is a mandatory argument when the key is a CryptoKey");\n  } else {\n    kid_promise = Jose.WebCryptographer.keyId(rsa_key);\n  }\n\n  that.waiting_kid++;\n\n  return kid_promise.then(function(kid) {\n    that.key_promises[kid] = key_promise;\n    that.waiting_kid--;\n    if (aad) {\n      that.signer_aads[kid] = aad;\n    }\n    if (header) {\n      that.signer_headers[kid] = header;\n    }\n    return kid;\n  });\n};\n\n/**\n * Adds a signature to a JWS object\n * @param jws JWS Object to be signed or its representation\n * @param aad     Object protected header\n * @param header  Object unprotected header\n * @return Promise<String>\n */\nJoseJWS.Signer.prototype.addSignature = function(jws, aad, header) {\n  if (Utils.isString(jws)) {\n    jws = JSON.parse(jws);\n  }\n\n  if (jws.payload && Utils.isString(jws.payload) &&\n    jws.protected && Utils.isString(jws.protected) &&\n    jws.header && jws.header instanceof Object &&\n    jws.signature && Utils.isString(jws.signature)) {\n    return this.sign(JWS.fromObject(jws), aad, header);\n  } else {\n    throw new Error("JWS is not a valid JWS object");\n  }\n};\n\n/**\n * Computes signature.\n *\n * @param payload JWS Object or utf-8 string to be signed\n * @param aad     Object protected header\n * @param header  Object unprotected header\n * @return Promise<JWS>\n */\nJoseJWS.Signer.prototype.sign = function(payload, aad, header) {\n\n  var that = this;\n  var kids = [];\n\n  if (Object.keys(that.key_promises).length === 0) {\n    throw new Error("No signers defined. At least one is required to sign the JWS.");\n  }\n\n  if (that.waiting_kid) {\n    throw new Error("still generating key IDs");\n  }\n\n  function sign (message, protectedHeader, unprotectedHeader, rsa_key_promise, kid) {\n    var toBeSigned;\n\n    if (!protectedHeader) {\n      protectedHeader = {};\n    }\n\n    if (!protectedHeader.alg) {\n      protectedHeader.alg = that.cryptographer.getContentSignAlgorithm();\n      protectedHeader.typ = "JWT";\n    }\n\n    if (!protectedHeader.kid) {\n      protectedHeader.kid = kid;\n    }\n\n    if (Utils.isString(message)) {\n      toBeSigned = Utils.arrayFromUtf8String(message);\n    } else {\n      try {\n        toBeSigned = Utils.arrayish(message);\n      } catch (e) {\n        if (message instanceof JWS) {\n          toBeSigned = Utils.arrayFromString(Utils.Base64Url.decode(message.payload));\n        } else if (message instanceof Object) {\n          toBeSigned = Utils.arrayFromUtf8String(JSON.stringify(message));\n        } else {\n          throw new Error("cannot sign this message");\n        }\n      }\n    }\n\n    return that.cryptographer.sign(protectedHeader, toBeSigned, rsa_key_promise).then(function(signature) {\n      var jws = new JWS(protectedHeader, unprotectedHeader, toBeSigned, signature);\n      if (message instanceof JWS) {\n        delete jws.payload;\n        if (!message.signatures) {\n          message.signatures = [jws];\n        } else {\n          message.signatures.push(jws);\n        }\n        return message;\n      }\n      return jws;\n    });\n  }\n\n  function doSign (pl, ph, uh, kps, kids) {\n    if (kids.length) {\n      var k_id = kids.shift();\n      var rv = sign(pl, that.signer_aads[k_id] || ph, that.signer_headers[k_id] || uh, kps[k_id], k_id);\n      if (kids.length) {\n        rv = rv.then(function(jws) {\n          return doSign(jws, null, null, kps, kids);\n        });\n      }\n      return rv;\n    }\n  }\n\n  for(var kid in that.key_promises) {\n    if (that.key_promises.hasOwnProperty(kid)) {\n      kids.push(kid);\n    }\n  }\n  return doSign(payload, aad, header, that.key_promises, kids);\n};\n\n\n/**\n * Initialize a JWS object.\n *\n * @param protectedHeader protected header (JS object)\n * @param payload Uint8Array payload to be signed\n * @param signature ArrayBuffer signature of the payload\n * @param header unprotected header (JS object)\n *\n * @constructor\n */\nvar JWS = function(protectedHeader, header, payload, signature) {\n  this.header = header;\n  this.payload = Utils.Base64Url.encodeArray(payload);\n  if (signature) {\n    this.signature = Utils.Base64Url.encodeArray(signature);\n  }\n  this.protected = Utils.Base64Url.encode(JSON.stringify(protectedHeader));\n};\n\nJWS.fromObject = function(obj) {\n  var rv = new JWS(obj.protected, obj.header, obj.payload, null);\n  rv.signature = obj.signature;\n  rv.signatures = obj.signatures;\n  return rv;\n};\n\n/**\n * Serialize a JWS object using the JSON serialization format\n *\n * @returns {Object} a copy of this\n */\nJWS.prototype.JsonSerialize = function() {\n  return JSON.stringify(this);\n};\n\n/**\n * Serialize a JWS object using the Compact Serialization Format\n *\n * @returns {string} BASE64URL(UTF8(PROTECTED HEADER)).BASE64URL(PAYLOAD).BASE64URL(SIGNATURE)\n */\nJWS.prototype.CompactSerialize = function() {\n  return this.protected + \'.\' + this.payload + \'.\' + this.signature;\n};\n\n\n/**\n * Verifies a JWS signature\n *\n * @returns Promise<Array> a Promise of an array of objects { kid: string, verified: bool, payload?: string }\n *\n * payload is only populated and usable if verified is true\n */\nJoseJWS.Verifier.prototype.verify = function () {\n\n  var that = this,\n    signatures = that.signatures,\n    key_promises = that.key_promises,\n    keyfinder = that.keyfinder,\n    promises = [],\n    check = !!keyfinder || Object.keys(that.key_promises).length > 0;\n\n  if (!check) {\n    throw new Error("No recipients defined. At least one is required to verify the JWS.");\n  }\n\n  if (that.waiting_kid) {\n    throw new Error("still generating key IDs");\n  }\n\n  signatures.forEach(function (sig) {\n    var kid = sig.protected.kid;\n    if (keyfinder) {\n      key_promises[kid] = keyfinder(kid);\n    }\n    promises.push(that.cryptographer.verify(sig.aad, that.payload, sig.signature, key_promises[kid], kid)\n      .then(function (vr) {\n        if (vr.verified) {\n          vr.payload = Utils.Base64Url.decode(that.payload);\n        }\n        return vr;\n      }));\n  });\n  return Promise.all(promises);\n};\n\n\n\n\n\n\n\n\n\n/* eslint-disable */\n/**\n * Syntactic sugar for Visa VDCP use-case.\n * expects an RSA key as a JS data object with 2 required fields:\n * @param {!string} rsaKeyId (REQUIRED)\n * @param {!object} rsaKey (REQUIRED)\n *    Requires:\n *      - `n` attribute (modulus)\n *      - `e` attribute (publicExponent)\n * @param {?string} scheme (optional) default \'RSA-OAEP-256\'\n * @param {?API} cryptoProvider (optional) window.crypto, node-webcrypto-ossl, node-webcrypto-pkcs11 etc.\n */\nvar PANJWE = function(rsaKeyId, rsaKey, scheme, cryptoProvider) {\n  scheme = scheme || \'RSA-OAEP-256\';\n\n  if (cryptoProvider) {\n    Jose.setCrypto(cryptoProvider);\n  }\n\n  var cryptographer = new Jose.WebCryptographer();\n\n  // set values for scheme and content encryption algorithm. They will be added to header by JoseJWE.Encrypter.encrypt\n  cryptographer.setKeyEncryptionAlgorithm(scheme);\n  cryptographer.setContentEncryptionAlgorithm(\'A256GCM\');\n\n  var rsa_key = Jose.Utils.importRsaPublicKey(rsaKey, scheme);\n  var encrypter = new JoseJWE.Encrypter(cryptographer, rsa_key);\n  encrypter.addHeader(\'kid\', rsaKeyId);\n  encrypter.addHeader(\'typ\', \'JOSE\');\n\n  this.encrypter = encrypter;\n\n  // for testing, testing bundle includes decrypter mixins\n  if (JoseJWE.Decrypter) {\n    var private_rsa_key = Jose.Utils.importRsaPrivateKey(rsaKey, scheme);\n    var decrypter = new JoseJWE.Decrypter(cryptographer, private_rsa_key);\n    this.decrypter = decrypter;\n\n    /**\n     * encrypts text\n     * @param {!string} encryptedText string to decrypt\n     * @returns {Promise}\n     */\n    this.decrypt = function(encryptedText) {\n      return this.decrypter.decrypt(encryptedText);\n    };\n  }\n\n  /**\n   * sanity check\n   * @returns {object}\n   */\n  this.sanityCheck = function() {\n    return Jose.caniuse();\n  };\n\n  /**\n   * encrypts text\n   * @param {!string} cipherText string to encrypt\n   * @returns {Promise}\n   */\n  this.encrypt = function(cipherText) {\n    return this.encrypter.encrypt(cipherText)/* .then(res => {\n      this.verify().then(verifyRes => {\n        console.log(`verify result: ${JSON.stringify(verifyres)}`);\n        return res;\n      });\n    }); */\n  };\n};\n\nmodule.exports.PANJWE = PANJWE;\nexports.PANJWE = PANJWE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtFQUErRTtBQUMvRSxpRkFBaUY7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssNkJBQTZCO0FBQ2hELE1BQU07QUFDTixjQUFjLEtBQUssNkJBQTZCO0FBQ2hELE1BQU07QUFDTixjQUFjLEtBQUsscUJBQXFCLGlCQUFpQjtBQUN6RCxNQUFNO0FBQ04sY0FBYyxLQUFLLHFCQUFxQixpQkFBaUI7QUFDekQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQSxPQUFPO0FBQ1AsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvam9zZS92aXNhLWVuY3J5cHQuanM/M2E5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi1cbiAqIENvcHlyaWdodCAyMDE0IFNxdWFyZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBKb3NlID0ge307XG5cbi8qKlxuICogSmF2YXNjcmlwdCBPYmplY3QgU2lnbmluZyBhbmQgRW5jcnlwdGlvbiBsaWJyYXJ5LlxuICpcbiAqIEBhdXRob3IgQWxvayBNZW5naHJhamFuaSA8YWxva0BzcXVhcmV1cC5jb20+XG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIEpvc2VKV0Ugb2JqZWN0LlxuICovXG52YXIgSm9zZUpXRSA9IHt9O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgSm9zZUpXUyBvYmplY3QuXG4gKi9cbnZhciBKb3NlSldTID0ge307XG5cbi8qKlxuICogU2V0IGNyeXB0byBwcm92aWRlciB0byB1c2UgKHdpbmRvdy5jcnlwdG8sIG5vZGUtd2ViY3J5cHRvLW9zc2wsIG5vZGUtd2ViY3J5cHRvLXBrY3MxMSBldGMuKS5cbiAqL1xuZXhwb3J0cy5zZXRDcnlwdG8gPSBmdW5jdGlvbiAoY3ApIHtcbiAgSm9zZS5jcnlwdG8gPSBjcDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCB0byB0aGUgZ2xvYmFsIFwiY3J5cHRvXCIgdmFyaWFibGVcbiAqL1xuaWYgKHR5cGVvZihjcnlwdG8pICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLnNldENyeXB0byhjcnlwdG8pO1xufVxuXG4vKipcbiAqIFVzZSBOb2RlIHZlcnNpb25zIG9mIGF0b2IsIGJ0b2EgZnVuY3Rpb25zIG91dHNpZGUgdGhlIGJyb3dzZXJcbiAqL1xuaWYgKHR5cGVvZiBhdG9iICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgYXRvYiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHIsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gIH07XG59XG5cbmlmICh0eXBlb2YgYnRvYSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIGJ0b2EgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoc3RyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoc3RyLnRvU3RyaW5nKCksICdiaW5hcnknKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHdlIGhhdmUgYWxsIHRoZSByZXF1aXJlZCBBUElzLlxuICpcbiAqIEl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gdGFrZSBhIENyeXB0b2dyYXBoZXIgYW5kIGRlbGVnYXRlIHNvbWUgb2YgdGhlIGNoZWNrc1xuICogdG8gdGhlIGNyeXB0b2dyYXBoZXIuIEkgaG93ZXZlciB3YW50ZWQgdG8ga2VlcCB0aGluZ3Mgc2ltcGxlLCBzbyBJIHB1dCBhbGxcbiAqIHRoZSBjaGVja3MgaGVyZSBmb3Igbm93LlxuICpcbiAqIFRoaXMgbGlzdCBpcyBnZW5lcmF0ZWQgbWFudWFsbHkgYW5kIG5lZWRzIHRvIGJlIGtlcHQgdXAtdG8tZGF0ZS5cbiAqXG4gKiBDYXN1YWwgdGVzdGluZyBzaG93cyB0aGF0OlxuICogLSB0aGluZ3Mgd29yayBpbiBDaHJvbWUgNDAuMC4yMjE0LjExNVxuICogLSB0aGluZ3Mgd29yayBpbiBGaXJlZm94IDM1LjAuMVxuICogLSBTYWZhcmkgNy4xLjMgZG9lc24ndCBzdXBwb3J0IEpXSyBrZXlzLlxuICogLSBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IHN1cHBvcnQgUHJvbWlzZXMuXG4gKlxuICogTm90ZTogV2UgZG9uJ3QgY2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgc3BlY2lmaWMgY3J5cHRvIG9wZXJhdGlvbnMuXG4gKiAgICAgICBJLmUuIGl0J3MgcG9zc2libGUgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIHRydWUsIGJ1dCBlbmNyeXB0aW9uIG9yXG4gKiAgICAgICBkZWNyeXB0aW9uIHRvIHN1YnNlcXVlbnRseSBmYWlsIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhXG4gKiAgICAgICBnaXZlbiBlbmNyeXB0aW9uLCBkZWNyeXB0aW9uLCBrZXkgd3JhcHBpbmcsIGtleSB1bndyYXBwaW5nIG9yIGhtYWNcbiAqICAgICAgIG9wZXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuSm9zZS5jYW5pdXNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByID0gdHJ1ZTtcblxuICAvLyBQcm9taXNlcy9BKyAoaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8pXG4gIHIgPSByICYmICh0eXBlb2YgUHJvbWlzZSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIFByb21pc2UucmVqZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIFByb21pc2UuYWxsID09IFwiZnVuY3Rpb25cIik7XG5cbiAgLy8gQ3J5cHRvIChodHRwOi8vd3d3LnczLm9yZy9UUi9XZWJDcnlwdG9BUEkvKVxuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvID09IFwib2JqZWN0XCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZSA9PSBcIm9iamVjdFwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLmV4cG9ydEtleSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS53cmFwS2V5ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLnVud3JhcEtleSA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIEpvc2UuY3J5cHRvLnN1YnRsZS5lbmNyeXB0ID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgSm9zZS5jcnlwdG8uc3VidGxlLmRlY3J5cHQgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKb3NlLmNyeXB0by5zdWJ0bGUuc2lnbiA9PSBcImZ1bmN0aW9uXCIpO1xuXG4gIC8vIEFycmF5QnVmZmVyIChodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1hcnJheWJ1ZmZlci1jb25zdHJ1Y3RvcilcbiAgciA9IHIgJiYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PSBcImZ1bmN0aW9uXCIpO1xuICByID0gciAmJiAodHlwZW9mIFVpbnQ4QXJyYXkgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBVaW50OEFycmF5ID09IFwib2JqZWN0XCIpOyAvLyBTYWZhcmkgdXNlcyBcIm9iamVjdFwiXG4gIHIgPSByICYmICh0eXBlb2YgVWludDMyQXJyYXkgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBVaW50MzJBcnJheSA9PSBcIm9iamVjdFwiKTsgLy8gU2FmYXJpIHVzZXMgXCJvYmplY3RcIlxuICAvLyBza2lwcGluZyBVaW50MzJBcnJheS5wcm90b3R5cGUuYnVmZmVyIGJlY2F1c2UgaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXByb3BlcnRpZXMtb2YtdGhlLSV0eXBlZGFycmF5cHJvdG90eXBlJS1vYmplY3RcblxuICAvLyBKU09OIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMTIuMylcbiAgciA9IHIgJiYgKHR5cGVvZiBKU09OID09IFwib2JqZWN0XCIpO1xuICByID0gciAmJiAodHlwZW9mIEpTT04ucGFyc2UgPT0gXCJmdW5jdGlvblwiKTtcbiAgciA9IHIgJiYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIpO1xuXG4gIC8vIEJhc2U2NCAoaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvd2ViYXBwYXBpcy5odG1sI2RvbS13aW5kb3diYXNlNjQtYXRvYilcbiAgciA9IHIgJiYgKHR5cGVvZiBhdG9iID09IFwiZnVuY3Rpb25cIik7XG4gIHIgPSByICYmICh0eXBlb2YgYnRvYSA9PSBcImZ1bmN0aW9uXCIpO1xuXG4gIC8vIHNraXBwaW5nIEFycmF5IGZ1bmN0aW9ucyAobWFwLCBqb2luLCBwdXNoLCBsZW5ndGgsIGV0Yy4pXG4gIC8vIHNraXBwaW5nIFN0cmluZyBmdW5jdGlvbnMgKHNwbGl0LCBjaGFyQ29kZUF0LCBmcm9tQ2hhckNvZGUsIHJlcGxhY2UsIGV0Yy4pXG4gIC8vIHNraXBwaW5nIHJlZ2V4cC50ZXN0IGFuZCBwYXJzZUludFxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBGZWVsIGZyZWUgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbi5cbiAqL1xuSm9zZS5hc3NlcnQgPSBmdW5jdGlvbihleHByLCBtc2cpIHtcbiAgaWYgKCFleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuSm9zZSA9IEpvc2U7XG5leHBvcnRzLkpvc2VKV0UgPSBKb3NlSldFO1xuZXhwb3J0cy5Kb3NlSldTID0gSm9zZUpXUztcbi8qLVxuICogQ29weXJpZ2h0IDIwMTQgU3F1YXJlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUaGUgV2ViQ3J5cHRvZ3JhcGhlciB1c2VzIGh0dHA6Ly93d3cudzMub3JnL1RSL1dlYkNyeXB0b0FQSS8gdG8gcGVyZm9ybVxuICogdmFyaW91cyBjcnlwdG8gb3BlcmF0aW9ucy4gSW4gdGhlb3J5LCB0aGlzIHNob3VsZCBoZWxwIGJ1aWxkIHRoZSBsaWJyYXJ5IHdpdGhcbiAqIGRpZmZlcmVudCB1bmRlcmx5aW5nIGNyeXB0byBBUElzLiBJJ20gaG93ZXZlciB1bmNsZWFyIGlmIHdlJ2xsIHJ1biBpbnRvIGNvZGVcbiAqIGR1cGxpY2F0aW9uIG9yIGNhbGxiYWNrIHZzIFByb21pc2UgYmFzZWQgQVBJIGlzc3Vlcy5cbiAqL1xudmFyIFdlYkNyeXB0b2dyYXBoZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXRLZXlFbmNyeXB0aW9uQWxnb3JpdGhtKFwiUlNBLU9BRVBcIik7XG4gIHRoaXMuc2V0Q29udGVudEVuY3J5cHRpb25BbGdvcml0aG0oXCJBMjU2R0NNXCIpO1xuICB0aGlzLnNldENvbnRlbnRTaWduQWxnb3JpdGhtKFwiUlMyNTZcIik7XG59O1xuXG5Kb3NlLldlYkNyeXB0b2dyYXBoZXIgPSBXZWJDcnlwdG9ncmFwaGVyO1xuXG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBrZXkgZW5jcnlwdGlvbiBhbGdvcml0aG1cbiAqIEBwYXJhbSBhbGcgIHN0cmluZ1xuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5zZXRLZXlFbmNyeXB0aW9uQWxnb3JpdGhtID0gZnVuY3Rpb24oYWxnKSB7XG4gIHRoaXMua2V5X2VuY3J5cHRpb24gPSBnZXRDcnlwdG9Db25maWcoYWxnKTtcbn07XG5cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLmdldEtleUVuY3J5cHRpb25BbGdvcml0aG0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMua2V5X2VuY3J5cHRpb24uandlX25hbWU7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBjb250ZW50IGVuY3J5cHRpb24gYWxnb3JpdGhtXG4gKiBAcGFyYW0gYWxnICBzdHJpbmdcbiAqL1xuV2ViQ3J5cHRvZ3JhcGhlci5wcm90b3R5cGUuc2V0Q29udGVudEVuY3J5cHRpb25BbGdvcml0aG0gPSBmdW5jdGlvbihhbGcpIHtcbiAgdGhpcy5jb250ZW50X2VuY3J5cHRpb24gPSBnZXRDcnlwdG9Db25maWcoYWxnKTtcbn07XG5cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLmdldENvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbi5qd2VfbmFtZTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGNvbnRlbnQgc2lnbiBhbGdvcml0aG1cbiAqIEBwYXJhbSBhbGcgIHN0cmluZ1xuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5zZXRDb250ZW50U2lnbkFsZ29yaXRobSA9IGZ1bmN0aW9uKGFsZykge1xuICB0aGlzLmNvbnRlbnRfc2lnbiA9IGdldFNpZ25Db25maWcoYWxnKTtcbn07XG5cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLmdldENvbnRlbnRTaWduQWxnb3JpdGhtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRfc2lnbi5qd2FfbmFtZTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIElWLlxuICogVGhpcyBmdW5jdGlvbiBtYWlubHkgZXhpc3RzIHNvIHRoYXQgaXQgY2FuIGJlIG1vY2tlZCBmb3IgdGVzdGluZyBwdXJwb3NlLlxuICpcbiAqIEByZXR1cm4gVWludDhBcnJheSB3aXRoIHJhbmRvbSBieXRlc1xuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5jcmVhdGVJViA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXYgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXkodGhpcy5jb250ZW50X2VuY3J5cHRpb24uaXZfYnl0ZXMpKTtcbiAgcmV0dXJuIEpvc2UuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhpdik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSByYW5kb20gY29udGVudCBlbmNyeXB0aW9uIGtleS5cbiAqIFRoaXMgZnVuY3Rpb24gbWFpbmx5IGV4aXN0cyBzbyB0aGF0IGl0IGNhbiBiZSBtb2NrZWQgZm9yIHRlc3RpbmcgcHVycG9zZS5cbiAqXG4gKiBAcmV0dXJuIFByb21pc2U8Q3J5cHRvS2V5PlxuICovXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS5jcmVhdGVDZWsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhY2sgPSBnZXRDZWtXb3JrYXJvdW5kKHRoaXMuY29udGVudF9lbmNyeXB0aW9uKTtcbiAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShoYWNrLmlkLCB0cnVlLCBoYWNrLmVuY19vcCk7XG59O1xuXG5XZWJDcnlwdG9ncmFwaGVyLnByb3RvdHlwZS53cmFwQ2VrID0gZnVuY3Rpb24oY2VrLCBrZXkpIHtcbiAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS53cmFwS2V5KFwicmF3XCIsIGNlaywga2V5LCB0aGlzLmtleV9lbmNyeXB0aW9uLmlkKTtcbn07XG5cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLnVud3JhcENlayA9IGZ1bmN0aW9uKGNlaywga2V5KSB7XG4gIHZhciBoYWNrID0gZ2V0Q2VrV29ya2Fyb3VuZCh0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbik7XG4gIHZhciBleHRyYWN0YWJsZSA9ICh0aGlzLmNvbnRlbnRfZW5jcnlwdGlvbi5zcGVjaWZpY19jZWtfYnl0ZXMgPiAwKTtcbiAgdmFyIGtleV9lbmNyeXB0aW9uID0gdGhpcy5rZXlfZW5jcnlwdGlvbi5pZDtcblxuICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLnVud3JhcEtleShcInJhd1wiLCBjZWssIGtleSwga2V5X2VuY3J5cHRpb24sIGhhY2suaWQsIGV4dHJhY3RhYmxlLCBoYWNrLmRlY19vcCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxnb3JpdGhtIGFuZCBvcGVyYXRpb24gbmVlZGVkIHRvIGNyZWF0ZSBhIENFSy5cbiAqXG4gKiBJbiBzb21lIGNhc2VzLCBlLmcuIEExMjhDQkMtSFMyNTYsIHRoZSBDRUsgZ2V0cyBzcGxpdCBpbnRvIHR3byBrZXlzLiBUaGUgV2ViXG4gKiBDcnlwdG8gQVBJIGRvZXMgbm90IGFsbG93IHVzIHRvIGdlbmVyYXRlIGFuIGFyYml0cmFyeSBudW1iZXIgb2YgYnl0ZXMgYW5kXG4gKiB0aGVuIGNyZWF0ZSBhIENyeXB0b0tleSB3aXRob3V0IGFueSBhc3NvY2lhdGVkIGFsZ29yaXRobS4gV2UgdGhlcmVmb3JlIHBpZ2d5XG4gKiBiYWNrIG9uIEFFUy1DQlMgYW5kIEhNQUMgd2hpY2ggYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBDRUtzIG9mIHNpemUgMTYsIDMyLCA2NFxuICogYW5kIDEyOCBieXRlcy5cbiAqL1xudmFyIGdldENla1dvcmthcm91bmQgPSBmdW5jdGlvbihhbGcpIHtcbiAgdmFyIGxlbiA9IGFsZy5zcGVjaWZpY19jZWtfYnl0ZXM7XG4gIGlmIChsZW4pIHtcbiAgICBpZiAobGVuID09IDE2KSB7XG4gICAgICByZXR1cm4ge2lkOiB7bmFtZTogXCJBRVMtQ0JDXCIsIGxlbmd0aDogMTI4fSwgZW5jX29wOiBbXCJlbmNyeXB0XCJdLCBkZWNfb3A6IFtcImRlY3J5cHRcIl19O1xuICAgIH0gZWxzZSBpZiAobGVuID09IDMyKSB7XG4gICAgICByZXR1cm4ge2lkOiB7bmFtZTogXCJBRVMtQ0JDXCIsIGxlbmd0aDogMjU2fSwgZW5jX29wOiBbXCJlbmNyeXB0XCJdLCBkZWNfb3A6IFtcImRlY3J5cHRcIl19O1xuICAgIH0gZWxzZSBpZiAobGVuID09IDY0KSB7XG4gICAgICByZXR1cm4ge2lkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19LCBlbmNfb3A6IFtcInNpZ25cIl0sIGRlY19vcDogW1widmVyaWZ5XCJdfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PSAxMjgpIHtcbiAgICAgIHJldHVybiB7aWQ6IHtuYW1lOiBcIkhNQUNcIiwgaGFzaDoge25hbWU6IFwiU0hBLTM4NFwifX0sIGVuY19vcDogW1wic2lnblwiXSwgZGVjX29wOiBbXCJ2ZXJpZnlcIl19O1xuICAgIH0gZWxzZSB7XG4gICAgICBKb3NlLmFzc2VydChmYWxzZSwgXCJnZXRDZWtXb3JrYXJvdW5kOiBpbnZhbGlkIGxlblwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtpZDogYWxnLmlkLCBlbmNfb3A6IFtcImVuY3J5cHRcIl0sIGRlY19vcDogW1wiZGVjcnlwdFwiXX07XG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIHBsYWluX3RleHQgd2l0aCBjZWsuXG4gKlxuICogQHBhcmFtIGl2ICAgICAgICAgIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBhYWQgICAgICAgICBVaW50OEFycmF5XG4gKiBAcGFyYW0gY2VrX3Byb21pc2UgUHJvbWlzZTxDcnlwdG9LZXk+XG4gKiBAcGFyYW0gcGxhaW5fdGV4dCAgVWludDhBcnJheVxuICogQHJldHVybiBQcm9taXNlPGpzb24+XG4gKi9cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpdiwgYWFkLCBjZWtfcHJvbWlzZSwgcGxhaW5fdGV4dCkge1xuICB2YXIgY29uZmlnID0gdGhpcy5jb250ZW50X2VuY3J5cHRpb247XG4gIGlmIChpdi5sZW5ndGggIT0gY29uZmlnLml2X2J5dGVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKFwiaW52YWxpZCBJViBsZW5ndGhcIikpO1xuICB9XG4gIGlmIChjb25maWcuYXV0aC5hZWFkKSB7XG4gICAgdmFyIHRhZ19ieXRlcyA9IGNvbmZpZy5hdXRoLnRhZ19ieXRlcztcblxuICAgIHZhciBlbmMgPSB7XG4gICAgICBuYW1lOiBjb25maWcuaWQubmFtZSxcbiAgICAgIGl2OiBpdixcbiAgICAgIGFkZGl0aW9uYWxEYXRhOiBhYWQsXG4gICAgICB0YWdMZW5ndGg6IHRhZ19ieXRlcyAqIDhcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNla19wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2VrKSB7XG4gICAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmVuY3J5cHQoZW5jLCBjZWssIHBsYWluX3RleHQpLnRoZW4oZnVuY3Rpb24oY2lwaGVyX3RleHQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGNpcGhlcl90ZXh0LmJ5dGVMZW5ndGggLSB0YWdfYnl0ZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2lwaGVyOiBjaXBoZXJfdGV4dC5zbGljZSgwLCBvZmZzZXQpLFxuICAgICAgICAgIHRhZzogY2lwaGVyX3RleHQuc2xpY2Uob2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXMgPSBzcGxpdEtleShjb25maWcsIGNla19wcm9taXNlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICB2YXIgbWFjX2tleV9wcm9taXNlID0ga2V5c1swXTtcbiAgICB2YXIgZW5jX2tleV9wcm9taXNlID0ga2V5c1sxXTtcblxuICAgIC8vIEVuY3J5cHQgdGhlIHBsYWluIHRleHRcbiAgICB2YXIgY2lwaGVyX3RleHRfcHJvbWlzZSA9IGVuY19rZXlfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVuY19rZXkpIHtcbiAgICAgIHZhciBlbmMgPSB7XG4gICAgICAgIG5hbWU6IGNvbmZpZy5pZC5uYW1lLFxuICAgICAgICBpdjogaXZcbiAgICAgIH07XG4gICAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmVuY3J5cHQoZW5jLCBlbmNfa2V5LCBwbGFpbl90ZXh0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbXB1dGUgTUFDXG4gICAgdmFyIG1hY19wcm9taXNlID0gY2lwaGVyX3RleHRfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNpcGhlcl90ZXh0KSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkTWFjKFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1hY19rZXlfcHJvbWlzZSxcbiAgICAgICAgYWFkLFxuICAgICAgICBpdixcbiAgICAgICAgY2lwaGVyX3RleHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtjaXBoZXJfdGV4dF9wcm9taXNlLCBtYWNfcHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24oYWxsKSB7XG4gICAgICB2YXIgY2lwaGVyX3RleHQgPSBhbGxbMF07XG4gICAgICB2YXIgbWFjID0gYWxsWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lwaGVyOiBjaXBoZXJfdGV4dCxcbiAgICAgICAgdGFnOiBtYWNcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjcnlwdHMgY2lwaGVyX3RleHQgd2l0aCBjZWsuIFZhbGlkYXRlcyB0aGUgdGFnLlxuICpcbiAqIEBwYXJhbSBjZWtfcHJvbWlzZSAgICBQcm9taXNlPENyeXB0b0tleT5cbiAqIEBwYXJhbSBhYWQgcHJvdGVjdGVkIGhlYWRlclxuICogQHBhcmFtIGl2IElWXG4gKiBAcGFyYW0gY2lwaGVyX3RleHQgdGV4dCB0byBiZSBkZWNyeXB0ZWRcbiAqIEBwYXJhbSB0YWcgdG8gYmUgdmVyaWZpZWRcbiAqIEByZXR1cm4gUHJvbWlzZTxzdHJpbmc+XG4gKi9cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjZWtfcHJvbWlzZSwgYWFkLCBpdiwgY2lwaGVyX3RleHQsIHRhZykge1xuICAvKipcbiAgICogQ29tcGFyZXMgdHdvIFVpbnQ4QXJyYXlzIGluIGNvbnN0YW50IHRpbWUuXG4gICAqXG4gICAqIEByZXR1cm4gUHJvbWlzZTx2b2lkPlxuICAgKi9cbiAgdmFyIGNvbXBhcmUgPSBmdW5jdGlvbihjb25maWcsIG1hY19rZXlfcHJvbWlzZSwgYXJyMSwgYXJyMikge1xuICAgIEpvc2UuYXNzZXJ0KGFycjEgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBcImNvbXBhcmU6IGludmFsaWQgaW5wdXRcIik7XG4gICAgSm9zZS5hc3NlcnQoYXJyMiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIFwiY29tcGFyZTogaW52YWxpZCBpbnB1dFwiKTtcblxuICAgIHJldHVybiBtYWNfa2V5X3Byb21pc2UudGhlbihmdW5jdGlvbihtYWNfa2V5KSB7XG4gICAgICB2YXIgaGFzaDEgPSBKb3NlLmNyeXB0by5zdWJ0bGUuc2lnbihjb25maWcuYXV0aC5pZCwgbWFjX2tleSwgYXJyMSk7XG4gICAgICB2YXIgaGFzaDIgPSBKb3NlLmNyeXB0by5zdWJ0bGUuc2lnbihjb25maWcuYXV0aC5pZCwgbWFjX2tleSwgYXJyMik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2hhc2gxLCBoYXNoMl0pLnRoZW4oZnVuY3Rpb24oYWxsKSB7XG4gICAgICAgIHZhciBoYXNoMSA9IG5ldyBVaW50OEFycmF5KGFsbFswXSk7XG4gICAgICAgIHZhciBoYXNoMiA9IG5ldyBVaW50OEFycmF5KGFsbFsxXSk7XG4gICAgICAgIGlmIChoYXNoMS5sZW5ndGggIT0gaGFzaDIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcGFyZSBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNoMVtpXSAhPSBoYXNoMltpXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcGFyZSBmYWlsZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaXYubGVuZ3RoICE9IHRoaXMuY29udGVudF9lbmNyeXB0aW9uLml2X2J5dGVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKFwiZGVjcnlwdENpcGhlcnRleHQ6IGludmFsaWQgSVZcIikpO1xuICB9XG5cbiAgdmFyIGNvbmZpZyA9IHRoaXMuY29udGVudF9lbmNyeXB0aW9uO1xuICBpZiAoY29uZmlnLmF1dGguYWVhZCkge1xuICAgIHZhciBkZWMgPSB7XG4gICAgICBuYW1lOiBjb25maWcuaWQubmFtZSxcbiAgICAgIGl2OiBpdixcbiAgICAgIGFkZGl0aW9uYWxEYXRhOiBhYWQsXG4gICAgICB0YWdMZW5ndGg6IGNvbmZpZy5hdXRoLnRhZ19ieXRlcyAqIDhcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNla19wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2VrKSB7XG4gICAgICB2YXIgYnVmID0gVXRpbHMuYXJyYXlCdWZmZXJDb25jYXQoY2lwaGVyX3RleHQsIHRhZyk7XG4gICAgICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmRlY3J5cHQoZGVjLCBjZWssIGJ1Zik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXMgPSBzcGxpdEtleShjb25maWcsIGNla19wcm9taXNlLCBbXCJkZWNyeXB0XCJdKTtcbiAgICB2YXIgbWFjX2tleV9wcm9taXNlID0ga2V5c1swXTtcbiAgICB2YXIgZW5jX2tleV9wcm9taXNlID0ga2V5c1sxXTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSBNQUNcbiAgICB2YXIgbWFjX3Byb21pc2UgPSB0cnVuY2F0ZWRNYWMoXG4gICAgICBjb25maWcsXG4gICAgICBtYWNfa2V5X3Byb21pc2UsXG4gICAgICBhYWQsXG4gICAgICBpdixcbiAgICAgIGNpcGhlcl90ZXh0KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbZW5jX2tleV9wcm9taXNlLCBtYWNfcHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24oYWxsKSB7XG4gICAgICB2YXIgZW5jX2tleSA9IGFsbFswXTtcbiAgICAgIHZhciBtYWMgPSBhbGxbMV07XG5cbiAgICAgIHJldHVybiBjb21wYXJlKGNvbmZpZywgbWFjX2tleV9wcm9taXNlLCBuZXcgVWludDhBcnJheShtYWMpLCB0YWcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWMgPSB7XG4gICAgICAgICAgbmFtZTogY29uZmlnLmlkLm5hbWUsXG4gICAgICAgICAgaXY6IGl2XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuZGVjcnlwdChkZWMsIGVuY19rZXksIGNpcGhlcl90ZXh0KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRXJyb3IoXCJkZWNyeXB0Q2lwaGVydGV4dDogTUFDIGZhaWxlZC5cIikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2lnbnMgcGxhaW5fdGV4dC5cbiAqXG4gKiBAcGFyYW0gYWFkICAgICAgICAganNvblxuICogQHBhcmFtIHBheWxvYWQgICAgIFN0cmluZyBvciBqc29uXG4gKiBAcGFyYW0ga2V5X3Byb21pc2UgUHJvbWlzZTxDcnlwdG9LZXk+XG4gKiBAcmV0dXJuIFByb21pc2U8QXJyYXlCdWZmZXI+XG4gKi9cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihhYWQsIHBheWxvYWQsIGtleV9wcm9taXNlKSB7XG4gIHZhciBjb25maWcgPSB0aGlzLmNvbnRlbnRfc2lnbjtcblxuICBpZiAoYWFkLmFsZykge1xuICAgIGNvbmZpZyA9IGdldFNpZ25Db25maWcoYWFkLmFsZyk7XG4gIH1cblxuICAvLyBFbmNyeXB0IHRoZSBwbGFpbiB0ZXh0XG4gIHJldHVybiBrZXlfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuc2lnbihjb25maWcuaWQsIGtleSwgVXRpbHMuYXJyYXlGcm9tU3RyaW5nKFV0aWxzLkJhc2U2NFVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoYWFkKSkgKyAnLicgKyBVdGlscy5CYXNlNjRVcmwuZW5jb2RlQXJyYXkocGF5bG9hZCkpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBKV1MuXG4gKlxuICogQHBhcmFtIHBheWxvYWQgICAgIEJhc2U2NFVybCBlbmNvZGVkIHBheWxvYWRcbiAqIEBwYXJhbSBhYWQgICAgICAgICBTdHJpbmcgQmFzZTY0VXJsIGVuY29kZWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdGVjdGVkIEpXUyBoZWFkZXJcbiAqIEBwYXJhbSBzaWduYXR1cmUgICBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIHNpZ25hdHVyZVxuICogQHBhcmFtIGtleV9wcm9taXNlIFByb21pc2U8Q3J5cHRvS2V5PlxuICogQHBhcmFtIGtleV9pZCAgICAgIHZhbHVlIG9mIHRoZSBraWQgSm9zZUhlYWRlciwgaXQnbGwgYmUgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIHJlc3VsdCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZVxuICogQHJldHVybiBQcm9taXNlPGpzb24+XG4gKi9cbldlYkNyeXB0b2dyYXBoZXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKGFhZCwgcGF5bG9hZCwgc2lnbmF0dXJlLCBrZXlfcHJvbWlzZSwga2V5X2lkKSB7XG4gIHZhciBjb25maWcgPSB0aGlzLmNvbnRlbnRfc2lnbjtcblxuICByZXR1cm4ga2V5X3Byb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICBjb25maWcgPSBnZXRTaWduQ29uZmlnKGdldEp3YU5hbWVGb3JTaWduS2V5KGtleSkpO1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUudmVyaWZ5KGNvbmZpZy5pZCwga2V5LCBzaWduYXR1cmUsIFV0aWxzLmFycmF5RnJvbVN0cmluZyhhYWQgKyBcIi5cIiArIHBheWxvYWQpKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcmV0dXJuIHtraWQ6IGtleV9pZCwgdmVyaWZpZWQ6IHJlc307XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSm9zZS5XZWJDcnlwdG9ncmFwaGVyLmtleUlkID0gZnVuY3Rpb24ocnNhX2tleSkge1xuICByZXR1cm4gVXRpbHMuc2hhMjU2KHJzYV9rZXkubiArIFwiK1wiICsgcnNhX2tleS5kKTtcbn07XG5cbi8qKlxuICogU3BsaXRzIGEgQ0VLIGludG8gdHdvIHBpZWNlczogYSBNQUMga2V5IGFuZCBhbiBFTkMga2V5LlxuICpcbiAqIFRoaXMgY29kZSBpcyBzdHJ1Y3R1cmVkIGFyb3VuZCB0aGUgZmFjdCB0aGF0IHRoZSBjcnlwdG8gQVBJIGRvZXMgbm90IHByb3ZpZGVcbiAqIGEgd2F5IHRvIHZhbGlkYXRlIHRydW5jYXRlZCBNQUNzLiBUaGUgTUFDIGtleSBpcyB0aGVyZWZvcmUgYWx3YXlzIGltcG9ydGVkIHRvXG4gKiBzaWduIGRhdGEuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAodXNlZCBmb3Iga2V5IGxlbmd0aHMgJiBhbGdvcml0aG1zKVxuICogQHBhcmFtIGNla19wcm9taXNlIFByb21pc2U8Q3J5cHRvS2V5PiAgQ0VLIGtleSB0byBzcGxpdFxuICogQHBhcmFtIHB1cnBvc2UgQXJyYXk8U3RyaW5nPiB1c2FnZXMgb2YgdGhlIGltcG9ydGVkIGtleVxuICogQHJldHVybiBbUHJvbWlzZTxtYWMga2V5PiwgUHJvbWlzZTxlbmMga2V5Pl1cbiAqL1xudmFyIHNwbGl0S2V5ID0gZnVuY3Rpb24oY29uZmlnLCBjZWtfcHJvbWlzZSwgcHVycG9zZSkge1xuICAvLyBXZSBuZWVkIHRvIHNwbGl0IHRoZSBDRUsga2V5IGludG8gYSBNQUMgYW5kIEVOQyBrZXlzXG4gIHZhciBjZWtfYnl0ZXNfcHJvbWlzZSA9IGNla19wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2VrKSB7XG4gICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXCJyYXdcIiwgY2VrKTtcbiAgfSk7XG4gIHZhciBtYWNfa2V5X3Byb21pc2UgPSBjZWtfYnl0ZXNfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNla19ieXRlcykge1xuICAgIGlmIChjZWtfYnl0ZXMuYnl0ZUxlbmd0aCAqIDggIT0gY29uZmlnLmlkLmxlbmd0aCArIGNvbmZpZy5hdXRoLmtleV9ieXRlcyAqIDgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChFcnJvcihcImVuY3J5cHRQbGFpblRleHQ6IGluY29ycmVjdCBjZWsgbGVuZ3RoXCIpKTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gY2VrX2J5dGVzLnNsaWNlKDAsIGNvbmZpZy5hdXRoLmtleV9ieXRlcyk7XG4gICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgYnl0ZXMsIGNvbmZpZy5hdXRoLmlkLCBmYWxzZSwgW1wic2lnblwiXSk7XG4gIH0pO1xuICB2YXIgZW5jX2tleV9wcm9taXNlID0gY2VrX2J5dGVzX3Byb21pc2UudGhlbihmdW5jdGlvbihjZWtfYnl0ZXMpIHtcbiAgICBpZiAoY2VrX2J5dGVzLmJ5dGVMZW5ndGggKiA4ICE9IGNvbmZpZy5pZC5sZW5ndGggKyBjb25maWcuYXV0aC5rZXlfYnl0ZXMgKiA4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRXJyb3IoXCJlbmNyeXB0UGxhaW5UZXh0OiBpbmNvcnJlY3QgY2VrIGxlbmd0aFwiKSk7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IGNla19ieXRlcy5zbGljZShjb25maWcuYXV0aC5rZXlfYnl0ZXMpO1xuICAgIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGJ5dGVzLCBjb25maWcuaWQsIGZhbHNlLCBwdXJwb3NlKTtcbiAgfSk7XG4gIHJldHVybiBbbWFjX2tleV9wcm9taXNlLCBlbmNfa2V5X3Byb21pc2VdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgSm9zZSB3ZWIgYWxnb3JpdGhtcyBpbnRvIGRhdGEgd2hpY2ggaXNcbiAqIHVzZWZ1bCBmb3IgdGhlIFdlYiBDcnlwdG8gQVBJLlxuICpcbiAqIGxlbmd0aCA9IGluIGJpdHNcbiAqIGJ5dGVzID0gaW4gYnl0ZXNcbiAqL1xudmFyIGdldENyeXB0b0NvbmZpZyA9IGZ1bmN0aW9uKGFsZykge1xuICBzd2l0Y2ggKGFsZykge1xuICAgIC8vIEtleSBlbmNyeXB0aW9uXG4gICAgY2FzZSBcIlJTQS1PQUVQXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJSU0EtT0FFUFwiLFxuICAgICAgICBpZDoge25hbWU6IFwiUlNBLU9BRVBcIiwgaGFzaDoge25hbWU6IFwiU0hBLTFcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJSU0EtT0FFUC0yNTZcIjpcbiAgICAgIC8vIHJldHVybiB7XG4gICAgICAvLyAgIGp3ZV9uYW1lOiBcIlJTQS1PQUVQLTI1NlwiLFxuICAgICAgLy8gICBpZDoge25hbWU6IFwiUlNBLU9BRVAtMjU2XCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBPUklHSU5BTCBTUVVBUkUgSEVBREVSIENPTkZJR1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiUlNBLU9BRVAtMjU2XCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJSU0EtT0FFUFwiLCBoYXNoOiB7bmFtZTogXCJTSEEtMjU2XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiQTEyOEtXXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJBMTI4S1dcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkFFUy1LV1wiLCBsZW5ndGg6IDEyOH1cbiAgICAgIH07XG4gICAgY2FzZSBcIkEyNTZLV1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiQTI1NktXXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJBRVMtS1dcIiwgbGVuZ3RoOiAyNTZ9XG4gICAgICB9O1xuICAgIGNhc2UgXCJkaXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcImRpclwiXG4gICAgICB9O1xuXG4gICAgLy8gQ29udGVudCBlbmNyeXB0aW9uXG4gICAgY2FzZSBcIkExMjhDQkMtSFMyNTZcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcIkExMjhDQkMtSFMyNTZcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkFFUy1DQkNcIiwgbGVuZ3RoOiAxMjh9LFxuICAgICAgICBpdl9ieXRlczogMTYsXG4gICAgICAgIHNwZWNpZmljX2Nla19ieXRlczogMzIsXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBrZXlfYnl0ZXM6IDE2LFxuICAgICAgICAgIGlkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19LFxuICAgICAgICAgIHRydW5jYXRlZF9ieXRlczogMTZcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwiQTI1NkNCQy1IUzUxMlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandlX25hbWU6IFwiQTI1NkNCQy1IUzUxMlwiLFxuICAgICAgICBpZDoge25hbWU6IFwiQUVTLUNCQ1wiLCBsZW5ndGg6IDI1Nn0sXG4gICAgICAgIGl2X2J5dGVzOiAxNixcbiAgICAgICAgc3BlY2lmaWNfY2VrX2J5dGVzOiA2NCxcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIGtleV9ieXRlczogMzIsXG4gICAgICAgICAgaWQ6IHtuYW1lOiBcIkhNQUNcIiwgaGFzaDoge25hbWU6IFwiU0hBLTUxMlwifX0sXG4gICAgICAgICAgdHJ1bmNhdGVkX2J5dGVzOiAzMlxuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJBMTI4R0NNXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2VfbmFtZTogXCJBMTI4R0NNXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJBRVMtR0NNXCIsIGxlbmd0aDogMTI4fSxcbiAgICAgICAgaXZfYnl0ZXM6IDEyLFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgYWVhZDogdHJ1ZSxcbiAgICAgICAgICB0YWdfYnl0ZXM6IDE2XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgY2FzZSBcIkEyNTZHQ01cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3ZV9uYW1lOiBcIkEyNTZHQ01cIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkFFUy1HQ01cIiwgbGVuZ3RoOiAyNTZ9LFxuICAgICAgICBpdl9ieXRlczogMTIsXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBhZWFkOiB0cnVlLFxuICAgICAgICAgIHRhZ19ieXRlczogMTZcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlcyBhIHRydW5jYXRlZCBNQUMuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAgICAgICAgICAgICAgY29uZmlndXJhdGlvblxuICogQHBhcmFtIG1hY19rZXlfcHJvbWlzZSAgICAgUHJvbWlzZTxDcnlwdG9LZXk+ICBtYWMga2V5XG4gKiBAcGFyYW0gYWFkICAgICAgICAgICAgICAgICBVaW50OEFycmF5XG4gKiBAcGFyYW0gaXYgICAgICAgICAgICAgICAgICBVaW50OEFycmF5XG4gKiBAcGFyYW0gY2lwaGVyX3RleHQgICAgICAgICBVaW50OEFycmF5XG4gKiBAcmV0dXJuIFByb21pc2U8YnVmZmVyPiAgICB0cnVuY2F0ZWQgTUFDXG4gKi9cbnZhciB0cnVuY2F0ZWRNYWMgPSBmdW5jdGlvbihjb25maWcsIG1hY19rZXlfcHJvbWlzZSwgYWFkLCBpdiwgY2lwaGVyX3RleHQpIHtcbiAgcmV0dXJuIG1hY19rZXlfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKG1hY19rZXkpIHtcbiAgICB2YXIgYWwgPSBuZXcgVWludDhBcnJheShVdGlscy5hcnJheUZyb21JbnQzMihhYWQubGVuZ3RoICogOCkpO1xuICAgIHZhciBhbF9mdWxsID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgYWxfZnVsbC5zZXQoYWwsIDQpO1xuICAgIHZhciBidWYgPSBVdGlscy5hcnJheUJ1ZmZlckNvbmNhdChhYWQsIGl2LCBjaXBoZXJfdGV4dCwgYWxfZnVsbCk7XG4gICAgcmV0dXJuIEpvc2UuY3J5cHRvLnN1YnRsZS5zaWduKGNvbmZpZy5hdXRoLmlkLCBtYWNfa2V5LCBidWYpLnRoZW4oZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIHJldHVybiBieXRlcy5zbGljZSgwLCBjb25maWcuYXV0aC50cnVuY2F0ZWRfYnl0ZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIEpvc2Ugd2ViIGFsZ29yaXRobXMgaW50byBkYXRhIHdoaWNoIGlzXG4gKiB1c2VmdWwgZm9yIHRoZSBXZWIgQ3J5cHRvIEFQSS5cbiAqL1xudmFyIGdldFNpZ25Db25maWcgPSBmdW5jdGlvbihhbGcpIHtcblxuICBzd2l0Y2ggKGFsZykge1xuICAgIGNhc2UgXCJSUzI1NlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUlMyNTZcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQVNTQS1QS0NTMS12MV81XCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJSUzM4NFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUlMzODRcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQVNTQS1QS0NTMS12MV81XCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0zODRcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJSUzUxMlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUlM1MTJcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQVNTQS1QS0NTMS12MV81XCIsIGhhc2g6IHtuYW1lOiBcIlNIQS01MTJcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJQUzI1NlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUFMyNTZcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQS1QU1NcIiwgaGFzaDoge25hbWU6IFwiU0hBLTI1NlwifSwgc2FsdExlbmd0aDogMjB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJQUzM4NFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUFMzODRcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQS1QU1NcIiwgaGFzaDoge25hbWU6IFwiU0hBLTM4NFwifSwgc2FsdExlbmd0aDogMjB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJQUzUxMlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiUFM1MTJcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIlJTQS1QU1NcIiwgaGFzaDoge25hbWU6IFwiU0hBLTUxMlwifSwgc2FsdExlbmd0aDogMjB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJIUzI1NlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiSFMyNTZcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkhNQUNcIiwgaGFzaDoge25hbWU6IFwiU0hBLTI1NlwifX1cbiAgICAgIH07XG4gICAgY2FzZSBcIkhTMzg0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqd2FfbmFtZTogXCJIUzM4NFwiLFxuICAgICAgICBpZDoge25hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7bmFtZTogXCJTSEEtMzg0XCJ9fVxuICAgICAgfTtcbiAgICBjYXNlIFwiSFM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGp3YV9uYW1lOiBcIkhTNTEyXCIsXG4gICAgICAgIGlkOiB7bmFtZTogXCJITUFDXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS01MTJcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJFUzI1NlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiRVMyNTZcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkVDRFNBXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0yNTZcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJFUzM4NFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiRVMzODRcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkVDRFNBXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS0zODRcIn19XG4gICAgICB9O1xuICAgIGNhc2UgXCJFUzUxMlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgandhX25hbWU6IFwiRVM1MTJcIixcbiAgICAgICAgaWQ6IHtuYW1lOiBcIkVDRFNBXCIsIGhhc2g6IHtuYW1lOiBcIlNIQS01MTJcIn19XG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgSldBIG5hbWUgZm9yIGEgZ2l2ZW4gQ3J5cHRvS2V5XG4gKiBAcGFyYW0ga2V5IENyeXB0b0tleVxuICovXG52YXIgZ2V0SndhTmFtZUZvclNpZ25LZXkgPSBmdW5jdGlvbihrZXkpIHtcblxuICB2YXIgcnYgPSBcIlwiLFxuICAgIHNpZ25fYWxnbyA9IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICBoYXNoX2FsZ28gPSBrZXkuYWxnb3JpdGhtLmhhc2gubmFtZTtcblxuICBpZihzaWduX2FsZ28gPT0gXCJSU0FTU0EtUEtDUzEtdjFfNVwiKSB7XG4gICAgcnYgPSBcIlJcIjtcbiAgfSBlbHNlIGlmKHNpZ25fYWxnbyA9PSBcIlJTQS1QU1NcIikge1xuICAgIHJ2ID0gXCJQXCI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbi92ZXJpZnkgYWxnb3JpdGhtIFwiICsgc2lnbl9hbGdvKTtcbiAgfVxuXG4gIGlmKGhhc2hfYWxnby5pbmRleE9mKFwiU0hBLVwiKSA9PT0gMCkge1xuICAgIHJ2ICs9IFwiU1wiO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGhhc2ggYWxnb3JpdGhtIFwiICsgc2lnbl9hbGdvKTtcbiAgfVxuXG4gIHJ2ICs9IGhhc2hfYWxnby5zdWJzdHJpbmcoNCk7XG5cbiAgcmV0dXJuIHJ2O1xufTtcblxuLyoqXG4gKiBEZXJpdmVzIGtleSB1c2FnZSBmcm9tIGFsZ29yaXRobSdzIG5hbWVcbiAqXG4gKiBAcGFyYW0gYWxnIFN0cmluZyBhbGdvcml0aG0gbmFtZVxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBnZXRLZXlVc2FnZUJ5QWxnID0gZnVuY3Rpb24oYWxnKSB7XG5cbiAgc3dpdGNoIChhbGcpIHtcbiAgICAvLyBzaWduYXR1cmVcbiAgICBjYXNlIFwiUlMyNTZcIjpcbiAgICBjYXNlIFwiUlMzODRcIjpcbiAgICBjYXNlIFwiUlM1MTJcIjpcbiAgICBjYXNlIFwiUFMyNTZcIjpcbiAgICBjYXNlIFwiUFMzODRcIjpcbiAgICBjYXNlIFwiUFM1MTJcIjpcbiAgICBjYXNlIFwiSFMyNTZcIjpcbiAgICBjYXNlIFwiSFMzODRcIjpcbiAgICBjYXNlIFwiSFM1MTJcIjpcbiAgICBjYXNlIFwiRVMyNTZcIjpcbiAgICBjYXNlIFwiRVMzODRcIjpcbiAgICBjYXNlIFwiRVM1MTJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleTogXCJ2ZXJpZnlcIixcbiAgICAgICAgcHJpdmF0ZUtleTogXCJzaWduXCJcbiAgICAgIH07XG4gICAgLy8ga2V5IGVuY3J5cHRpb25cbiAgICBjYXNlIFwiUlNBLU9BRVBcIjpcbiAgICBjYXNlIFwiUlNBLU9BRVAtMjU2XCI6XG4gICAgY2FzZSBcIkExMjhLV1wiOlxuICAgIGNhc2UgXCJBMjU2S1dcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleTogXCJ3cmFwS2V5XCIsXG4gICAgICAgIHByaXZhdGVLZXk6IFwidW53cmFwS2V5XCJcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gIH1cbn07XG5cbi8vIFZpc2Etc3BlY2lmaWNcbm1vZHVsZS5leHBvcnRzID0gV2ViQ3J5cHRvZ3JhcGhlcjtcblxuLyotXG4gKiBDb3B5cmlnaHQgMjAxNCBTcXVhcmUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5Kb3NlLlV0aWxzID0ge307XG52YXIgVXRpbHMgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgb3V0cHV0IGZyb20gYG9wZW5zc2wgeDUwOSAtdGV4dGAgb3IgYG9wZW5zc2wgcnNhIC10ZXh0YCBpbnRvIGFcbiAqIENyeXB0b0tleSB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHdpdGggUlNBLU9BRVAuIEFsc28gYWNjZXB0cyAoYW5kIHZhbGlkYXRlcylcbiAqIEpXSyBrZXlzLlxuICpcbiAqIFRPRE86IHRoaXMgY29kZSBwcm9iYWJseSBiZWxvbmdzIGluIHRoZSB3ZWJjcnlwdG9ncmFwaGVyLlxuICpcbiAqIEBwYXJhbSByc2Ffa2V5ICBwdWJsaWMgUlNBIGtleSBpbiBqc29uIGZvcm1hdC4gUGFyYW1ldGVycyBjYW4gYmUgYmFzZTY0XG4gKiAgICAgICAgICAgICAgICAgZW5jb2RlZCwgc3RyaW5ncyBvciBudW1iZXIgKGZvciAnZScpLlxuICogQHBhcmFtIGFsZyAgICAgIFN0cmluZywgbmFtZSBvZiB0aGUgYWxnb3JpdGhtXG4gKiBAcmV0dXJuIFByb21pc2U8Q3J5cHRvS2V5PlxuICovXG5Kb3NlLlV0aWxzLmltcG9ydFJzYVB1YmxpY0tleSA9IGZ1bmN0aW9uKHJzYV9rZXksIGFsZykge1xuICB2YXIgandrO1xuICB2YXIgY29uZmlnO1xuICB2YXIgdXNhZ2UgPSBnZXRLZXlVc2FnZUJ5QWxnKGFsZyk7XG5cbiAgaWYgKHVzYWdlLnB1YmxpY0tleSA9PSBcIndyYXBLZXlcIikge1xuICAgIGlmICghcnNhX2tleS5hbGcpIHtcbiAgICAgIHJzYV9rZXkuYWxnID0gYWxnO1xuICAgIH1cbiAgICBqd2sgPSBVdGlscy5jb252ZXJ0UnNhS2V5KHJzYV9rZXksIFtcIm5cIiwgXCJlXCJdKTtcbiAgICBjb25maWcgPSBnZXRDcnlwdG9Db25maWcoYWxnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmsgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJzYV9rZXkpIHtcbiAgICAgIGlmIChyc2Ffa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJrW25hbWVdID0gcnNhX2tleVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJrLmFsZyAmJiBhbGcpIHtcbiAgICAgIHJrLmFsZyA9IGFsZztcbiAgICB9XG4gICAgY29uZmlnID0gZ2V0U2lnbkNvbmZpZyhyay5hbGcpO1xuICAgIGp3ayA9IFV0aWxzLmNvbnZlcnRSc2FLZXkocmssIFtcIm5cIiwgXCJlXCJdKTtcbiAgICBqd2suZXh0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcImp3a1wiLCBqd2ssIGNvbmZpZy5pZCwgZmFsc2UsIFt1c2FnZS5wdWJsaWNLZXldKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIG91dHB1dCBmcm9tIGBvcGVuc3NsIHg1MDkgLXRleHRgIG9yIGBvcGVuc3NsIHJzYSAtdGV4dGAgaW50byBhXG4gKiBDcnlwdG9LZXkgd2hpY2ggY2FuIHRoZW4gYmUgdXNlZCB3aXRoIFJTQS1PQUVQIGFuZCBSU0EuIEFsc28gYWNjZXB0cyAoYW5kIHZhbGlkYXRlcylcbiAqIEpXSyBrZXlzLlxuICpcbiAqIFRPRE86IHRoaXMgY29kZSBwcm9iYWJseSBiZWxvbmdzIGluIHRoZSB3ZWJjcnlwdG9ncmFwaGVyLlxuICpcbiAqIEBwYXJhbSByc2Ffa2V5ICBwcml2YXRlIFJTQSBrZXkgaW4ganNvbiBmb3JtYXQuIFBhcmFtZXRlcnMgY2FuIGJlIGJhc2U2NFxuICogICAgICAgICAgICAgICAgIGVuY29kZWQsIHN0cmluZ3Mgb3IgbnVtYmVyIChmb3IgJ2UnKS5cbiAqIEBwYXJhbSBhbGcgICAgICBTdHJpbmcsIG5hbWUgb2YgdGhlIGFsZ29yaXRobVxuICogQHJldHVybiBQcm9taXNlPENyeXB0b0tleT5cbiAqL1xuSm9zZS5VdGlscy5pbXBvcnRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhX2tleSwgYWxnKSB7XG4gIHZhciBqd2s7XG4gIHZhciBjb25maWc7XG4gIHZhciB1c2FnZSA9IGdldEtleVVzYWdlQnlBbGcoYWxnKTtcblxuICBpZiAodXNhZ2UucHJpdmF0ZUtleSA9PSBcInVud3JhcEtleVwiKSB7XG4gICAgaWYgKCFyc2Ffa2V5LmFsZykge1xuICAgICAgcnNhX2tleS5hbGcgPSBhbGc7XG4gICAgfVxuICAgIGp3ayA9IFV0aWxzLmNvbnZlcnRSc2FLZXkocnNhX2tleSwgW1wiblwiLCBcImVcIiwgXCJkXCIsIFwicFwiLCBcInFcIiwgXCJkcFwiLCBcImRxXCIsIFwicWlcIl0pO1xuICAgIGNvbmZpZyA9IGdldENyeXB0b0NvbmZpZyhhbGcpO1xuICB9IGVsc2Uge1xuICAgIHZhciByayA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gcnNhX2tleSkge1xuICAgICAgaWYgKHJzYV9rZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmtbbmFtZV0gPSByc2Ffa2V5W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25maWcgPSBnZXRTaWduQ29uZmlnKGFsZyk7XG4gICAgaWYgKCFyay5hbGcgJiYgYWxnKSB7XG4gICAgICByay5hbGcgPSBhbGc7XG4gICAgfVxuICAgIGp3ayA9IFV0aWxzLmNvbnZlcnRSc2FLZXkocmssIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdKTtcbiAgICBqd2suZXh0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gSm9zZS5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcImp3a1wiLCBqd2ssIGNvbmZpZy5pZCwgZmFsc2UsIFt1c2FnZS5wcml2YXRlS2V5XSk7XG59O1xuXG4vLyBQcml2YXRlIGZ1bmN0aW9uc1xuXG5VdGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gKCh0eXBlb2Yoc3RyKSA9PSBcInN0cmluZ1wiKSB8fCAoc3RyIGluc3RhbmNlb2YgU3RyaW5nKSk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5aXNoIChhbiBhcnJheSwgQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSlcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9yIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYXJyICBhcnJheWlzaFxuICogQHJldHVybiBhcnJheSBvciBVaW50OEFycmF5XG4gKi9cblV0aWxzLmFycmF5aXNoID0gZnVuY3Rpb24oYXJyKSB7XG4gIGlmIChhcnIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmIChhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIpO1xuICB9XG4gIEpvc2UuYXNzZXJ0KGZhbHNlLCBcImFycmF5aXNoOiBpbnZhbGlkIGlucHV0XCIpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gUlNBIGtleSBjb250YWlucyBhbGwgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMuIEFsc28gY2hlY2tzIHRoZWlyXG4gKiB0eXBlcy4gQ29udmVydHMgaGV4IGVuY29kZWQgc3RyaW5ncyAob3IgbnVtYmVycykgdG8gYmFzZTY0LlxuICpcbiAqIEBwYXJhbSByc2Ffa2V5ICAgICBSU0Ega2V5IGluIGpzb24gZm9ybWF0LiBQYXJhbWV0ZXJzIGNhbiBiZSBiYXNlNjQgZW5jb2RlZCxcbiAqICAgICAgICAgICAgICAgICAgICBzdHJpbmdzIG9yIG51bWJlciAoZm9yICdlJykuXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAgYXJyYXk8c3RyaW5nPlxuICogQHJldHVybiBqc29uXG4gKi9cblV0aWxzLmNvbnZlcnRSc2FLZXkgPSBmdW5jdGlvbihyc2Ffa2V5LCBwYXJhbWV0ZXJzKSB7XG4gIHZhciByID0ge307XG4gIHZhciBhbGc7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBoYXZlIGFsbCB0aGUgcGFyYW1ldGVyc1xuICB2YXIgbWlzc2luZyA9IFtdO1xuICBwYXJhbWV0ZXJzLm1hcChmdW5jdGlvbihwKXtpZiAodHlwZW9mKHJzYV9rZXlbcF0pID09IFwidW5kZWZpbmVkXCIpIHsgbWlzc2luZy5wdXNoKHApOyB9fSk7XG5cbiAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgIEpvc2UuYXNzZXJ0KGZhbHNlLCBcImNvbnZlcnRSc2FLZXk6IFdhcyBleHBlY3RpbmcgXCIgKyBtaXNzaW5nLmpvaW4oKSk7XG4gIH1cblxuICAvLyBrdHkgaXMgZWl0aGVyIG1pc3Npbmcgb3IgaXMgc2V0IHRvIFwiUlNBXCJcbiAgaWYgKHR5cGVvZihyc2Ffa2V5Lmt0eSkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEpvc2UuYXNzZXJ0KHJzYV9rZXkua3R5ID09IFwiUlNBXCIsIFwiY29udmVydFJzYUtleTogZXhwZWN0aW5nIHJzYV9rZXlbJ2t0eSddIHRvIGJlICdSU0EnXCIpO1xuICB9XG4gIHIua3R5ID0gXCJSU0FcIjtcblxuICB0cnkge1xuICAgIGdldFNpZ25Db25maWcocnNhX2tleS5hbGcpO1xuICAgIGFsZyA9IHJzYV9rZXkuYWxnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0cnkge1xuICAgICAgZ2V0Q3J5cHRvQ29uZmlnKHJzYV9rZXkuYWxnKTtcbiAgICAgIGFsZyA9IHJzYV9rZXkuYWxnO1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBKb3NlLmFzc2VydChhbGcsIFwiY29udmVydFJzYUtleTogZXhwZWN0aW5nIHJzYV9rZXlbJ2FsZyddIHRvIGhhdmUgYSB2YWxpZCB2YWx1ZVwiKTtcbiAgICB9XG4gIH1cbiAgci5hbGcgPSBhbGc7XG5cbiAgLy8gbm90ZTogd2UgcHVudCBvbiBjaGVja2luZyBrZXlfb3BzXG5cbiAgdmFyIGludEZyb21IZXggPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGUsIDE2KTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXJhbWV0ZXJzW2ldO1xuICAgIHZhciB2ID0gcnNhX2tleVtwXTtcbiAgICBpZiAocCA9PSBcImVcIikge1xuICAgICAgaWYgKHR5cGVvZih2KSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHYgPSBVdGlscy5CYXNlNjRVcmwuZW5jb2RlQXJyYXkoVXRpbHMuc3RyaXBMZWFkaW5nWmVyb3MoVXRpbHMuYXJyYXlGcm9tSW50MzIodikpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9eKFswLTlhLWZBLUZdezJ9OikrWzAtOWEtZkEtRl17Mn0kLy50ZXN0KHYpKSB7XG4gICAgICB2YXIgYXJyID0gdi5zcGxpdChcIjpcIikubWFwKGludEZyb21IZXgpO1xuICAgICAgdiA9IFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShVdGlscy5zdHJpcExlYWRpbmdaZXJvcyhhcnIpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZih2KSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICBKb3NlLmFzc2VydChmYWxzZSwgXCJjb252ZXJ0UnNhS2V5OiBleHBlY3RpbmcgcnNhX2tleVsnXCIgKyBwICsgXCInXSB0byBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgcltwXSA9IHY7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhc2NpaSBjb2Rlcy5cbiAqXG4gKiBAcGFyYW0gc3RyICBhc2NpaSBzdHJpbmdcbiAqIEByZXR1cm4gVWludDhBcnJheVxuICovXG5VdGlscy5hcnJheUZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgSm9zZS5hc3NlcnQoVXRpbHMuaXNTdHJpbmcoc3RyKSwgXCJhcnJheUZyb21TdHJpbmc6IGludmFsaWQgaW5wdXRcIik7XG4gIHZhciBhcnIgPSBzdHIuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgfSk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhcnIpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHV0Zi04IGNvZGVzLlxuICpcbiogQHBhcmFtIHN0ciAgdXRmLTggc3RyaW5nXG4gKiBAcmV0dXJuIFVpbnQ4QXJyYXlcbiAqL1xuVXRpbHMuYXJyYXlGcm9tVXRmOFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBKb3NlLmFzc2VydChVdGlscy5pc1N0cmluZyhzdHIpLCBcImFycmF5RnJvbVV0ZjhTdHJpbmc6IGludmFsaWQgaW5wdXRcIik7XG4gIC8vIGphdmFzY3JpcHQgcmVwcmVzZW50cyBzdHJpbmdzIGFzIHV0Zi0xNi4gSm9zZSBpbXBvc2VzIHRoZSB1c2Ugb2ZcbiAgLy8gdXRmLTgsIHNvIHdlIG5lZWQgdG8gY29udmVydCBmcm9tIG9uZSByZXByZXNlbnRhdGlvbiB0byB0aGUgb3RoZXIuXG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgcmV0dXJuIFV0aWxzLmFycmF5RnJvbVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBhc2NpaSBieXRlcyBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBhcnIgIGFycmF5aXNoXG4gKiBAcmV0dXJuIGFzY2lpIHN0cmluZ1xuICovXG5VdGlscy5zdHJpbmdGcm9tQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgYXJyID0gVXRpbHMuYXJyYXlpc2goYXJyKTtcbiAgdmFyIHIgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyW2ldKTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBhc2NpaSBieXRlcyBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBhcnIgIEFycmF5QnVmZmVyXG4gKiBAcmV0dXJuIGFzY2lpIHN0cmluZ1xuICovXG5VdGlscy51dGY4U3RyaW5nRnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIEpvc2UuYXNzZXJ0KGFyciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcInV0ZjhTdHJpbmdGcm9tQXJyYXk6IGludmFsaWQgaW5wdXRcIik7XG5cbiAgLy8gamF2YXNjcmlwdCByZXByZXNlbnRzIHN0cmluZ3MgYXMgdXRmLTE2LiBKb3NlIGltcG9zZXMgdGhlIHVzZSBvZlxuICAvLyB1dGYtOCwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGZyb20gb25lIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBvdGhlci5cbiAgdmFyIHIgPSBVdGlscy5zdHJpbmdGcm9tQXJyYXkoYXJyKTtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocikpO1xufTtcblxuLyoqXG4gKiBTdHJpcHMgbGVhZGluZyB6ZXJvIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBhcnIgIGFycmF5aXNoXG4gKiBAcmV0dXJuIGFycmF5XG4gKi9cblV0aWxzLnN0cmlwTGVhZGluZ1plcm9zID0gZnVuY3Rpb24oYXJyKSB7XG4gIGlmIChhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGFycik7XG4gIH1cbiAgdmFyIGlzX2xlYWRpbmdfemVybyA9IHRydWU7XG4gIHZhciByID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzX2xlYWRpbmdfemVybyAmJiBhcnJbaV0gPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpc19sZWFkaW5nX3plcm8gPSBmYWxzZTtcbiAgICByLnB1c2goYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgaW50byBhbiBhcnJheSBvZiA0IGJ5dGVzIChiaWcgZW5kaWFuKS5cbiAqXG4gKiBAcGFyYW0gaSAgbnVtYmVyXG4gKiBAcmV0dXJuIEFycmF5QnVmZmVyXG4gKi9cblV0aWxzLmFycmF5RnJvbUludDMyID0gZnVuY3Rpb24oaSkge1xuICBKb3NlLmFzc2VydCh0eXBlb2YoaSkgPT0gXCJudW1iZXJcIiwgXCJhcnJheUZyb21JbnQzMjogaW52YWxpZCBpbnB1dFwiKTtcbiAgSm9zZS5hc3NlcnQoaSA9PSBpIHwgMCwgXCJhcnJheUZyb21JbnQzMjogb3V0IG9mIHJhbmdlXCIpO1xuXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoW2ldKS5idWZmZXIpO1xuICB2YXIgciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgIHJbal0gPSBidWZbMyAtIGpdO1xuICB9XG4gIHJldHVybiByLmJ1ZmZlcjtcbn07XG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIGFycmF5aXNoZXMuXG4gKlxuICogQHBhcmFtIGFyZ3VtZW50cyB0d28gb3IgbW9yZSBhcnJheWlzaGVzXG4gKiBAcmV0dXJuIFVpbnQ4QXJyYXlcbiAqL1xuVXRpbHMuYXJyYXlCdWZmZXJDb25jYXQgPSBmdW5jdGlvbigvKiAuLi4gKi8pIHtcbiAgLy8gQ29tcHV0ZSB0b3RhbCBzaXplXG4gIHZhciBhcmdzID0gW107XG4gIHZhciB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKFV0aWxzLmFycmF5aXNoKGFyZ3VtZW50c1tpXSkpO1xuICAgIHRvdGFsICs9IGFyZ3NbaV0ubGVuZ3RoO1xuICB9XG4gIHZhciByID0gbmV3IFVpbnQ4QXJyYXkodG90YWwpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJnc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgcltvZmZzZXQrK10gPSBhcmdzW2ldW2pdO1xuICAgIH1cbiAgfVxuICBKb3NlLmFzc2VydChvZmZzZXQgPT0gdG90YWwsIFwiYXJyYXlCdWZmZXJDb25jYXQ6IHVuZXhwZWN0ZWQgb2Zmc2V0XCIpO1xuICByZXR1cm4gcjtcbn07XG5cblV0aWxzLkJhc2U2NFVybCA9IHt9O1xuXG4vKipcbiAqIEJhc2U2NFVybCBlbmNvZGVzIGEgc3RyaW5nIChubyB0cmFpbGluZyAnPScpXG4gKlxuICogQHBhcmFtIHN0ciAgc3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5VdGlscy5CYXNlNjRVcmwuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIEpvc2UuYXNzZXJ0KFV0aWxzLmlzU3RyaW5nKHN0ciksIFwiQmFzZTY0VXJsLmVuY29kZTogaW52YWxpZCBpbnB1dFwiKTtcbiAgcmV0dXJuIGJ0b2Eoc3RyKVxuICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIilcbiAgICAucmVwbGFjZSgvPSskLywgXCJcIik7XG59O1xuXG4vKipcbiAqIEJhc2U2NFVybCBlbmNvZGVzIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIGFyciBhcnJheSBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBzdHJpbmdcbiAqL1xuVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBVdGlscy5CYXNlNjRVcmwuZW5jb2RlKFV0aWxzLnN0cmluZ0Zyb21BcnJheShhcnIpKTtcbn07XG5cbi8qKlxuICogQmFzZTY0VXJsIGRlY29kZXMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyICBzdHJpbmdcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cblV0aWxzLkJhc2U2NFVybC5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgSm9zZS5hc3NlcnQoVXRpbHMuaXNTdHJpbmcoc3RyKSwgXCJCYXNlNjRVcmwuZGVjb2RlOiBpbnZhbGlkIGlucHV0XCIpO1xuICAvLyBhdG9iIGlzIG5pY2UgYW5kIGlnbm9yZXMgbWlzc2luZyAnPSdcbiAgcmV0dXJuIGF0b2Ioc3RyLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpKTtcbn07XG5cblV0aWxzLkJhc2U2NFVybC5kZWNvZGVBcnJheSA9IGZ1bmN0aW9uKHN0cikge1xuICBKb3NlLmFzc2VydChVdGlscy5pc1N0cmluZyhzdHIpLCBcIkJhc2U2NFVybC5kZWNvZGVBcnJheTogaW52YWxpZCBpbnB1dFwiKTtcbiAgcmV0dXJuIFV0aWxzLmFycmF5RnJvbVN0cmluZyhVdGlscy5CYXNlNjRVcmwuZGVjb2RlKHN0cikpO1xufTtcblxuVXRpbHMuc2hhMjU2ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIEJyb3dzZXIgZG9jcyBpbmRpY2F0ZSB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGNyeXB0by5zdWJ0bGUuZGlnZXN0IHRvIGJlIGFcbiAgLy8gRE9NU3RyaW5nLiBUaGlzIHdhcyBpbml0aWFsbHkgaW1wbGVtZW50ZWQgYXMgYW4gb2JqZWN0IGFuZCBjb250aW51ZXMgdG8gYmVcbiAgLy8gc3VwcG9ydGVkLCBzbyB3ZSBmYXZvciB0aGUgb2xkZXIgZm9ybSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIHJldHVybiBKb3NlLmNyeXB0by5zdWJ0bGUuZGlnZXN0KHtuYW1lOiBcIlNIQS0yNTZcIn0sIFV0aWxzLmFycmF5RnJvbVN0cmluZyhzdHIpKS50aGVuKGZ1bmN0aW9uKGhhc2gpIHtcbiAgICByZXR1cm4gVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KGhhc2gpO1xuICB9KTtcbn07XG5cblV0aWxzLmlzQ3J5cHRvS2V5ID0gZnVuY3Rpb24ocnNhX2tleSkge1xuICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGV4cG9zZSB0aGUgQ3J5cHRvS2V5IGFzIGFuIG9iamVjdCwgc28gd2UgbmVlZCB0byBjaGVja1xuICAvLyB0aGUgY29uc3RydWN0b3IncyBuYW1lLlxuICBpZiAocnNhX2tleS5jb25zdHJ1Y3Rvci5uYW1lID09ICdDcnlwdG9LZXknKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbiB0aGUgcHJlc2VuY2Ugb2YgbWluaWZpZXJzLCByZWx5aW5nIG9uIGNsYXNzIG5hbWVzIGNhbiBiZSBwcm9ibGVtYXRpYyxcbiAgLy8gc28gbGV0J3MgYWxzbyBhbGxvdyBvYmplY3RzIHRoYXQgaGF2ZSBhbiAnYWxnb3JpdGhtJyBwcm9wZXJ0eS5cbiAgaWYgKHJzYV9rZXkuaGFzT3duUHJvcGVydHkoJ2FsZ29yaXRobScpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzO1xuXG5cbi8qLVxuICogQ29weXJpZ2h0IDIwMTQgU3F1YXJlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBIYW5kbGVzIGVuY3J5cHRpb24uXG4gKlxuICogQHBhcmFtIGNyeXB0b2dyYXBoZXIgIGFuIGluc3RhbmNlIG9mIFdlYkNyeXB0b2dyYXBoZXIgKG9yIGVxdWl2YWxlbnQpLlxuICogQHBhcmFtIGtleV9wcm9taXNlICAgIFByb21pc2U8Q3J5cHRvS2V5PiwgZWl0aGVyIFJTQSBvciBzaGFyZWQga2V5XG4gKi9cbkpvc2VKV0UuRW5jcnlwdGVyID0gZnVuY3Rpb24oY3J5cHRvZ3JhcGhlciwga2V5X3Byb21pc2UpIHtcbiAgdGhpcy5jcnlwdG9ncmFwaGVyID0gY3J5cHRvZ3JhcGhlcjtcbiAgdGhpcy5rZXlfcHJvbWlzZSA9IGtleV9wcm9taXNlO1xuICB0aGlzLnVzZXJIZWFkZXJzID0ge307XG59O1xuXG4vKipcbiAqIEFkZHMgYSBrZXkvdmFsdWUgcGFpciB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBoZWFkZXIuXG4gKlxuICogVGhlIGRhdGEgbGl2ZXMgaW4gcGxhaW50ZXh0IChhbiBhdHRhY2tlciBjYW4gcmVhZCB0aGUgaGVhZGVyKSBidXQgaXMgdGFtcGVyXG4gKiBwcm9vZiAoYW4gYXR0YWNrZXIgY2Fubm90IG1vZGlmeSB0aGUgaGVhZGVyKS5cbiAqXG4gKiBOb3RlOiBzb21lIGhlYWRlcnMgaGF2ZSBzZW1hbnRpYyBpbXBsaWNhdGlvbnMuIEUuZy4gaWYgeW91IHNldCB0aGUgXCJ6aXBcIlxuICogaGVhZGVyLCB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBjb21wcmVzc2luZyBwbGFpbl90ZXh0IGJlZm9yZVxuICogY2FsbGluZyBlbmNyeXB0KCkuXG4gKlxuICogQHBhcmFtIGsgIFN0cmluZ1xuICogQHBhcmFtIHYgIFN0cmluZ1xuICovXG5Kb3NlSldFLkVuY3J5cHRlci5wcm90b3R5cGUuYWRkSGVhZGVyID0gZnVuY3Rpb24oaywgdikge1xuICB0aGlzLnVzZXJIZWFkZXJzW2tdID0gdjtcbn07XG5cbi8qKlxuICpcbiAqIFZpc2EtY3VzdG9tXG4gKiByZXR1cm5zIHRoZSBoZWFkZXIgdmFsdWVcbiAqIFxuICogQHBhcmFtIGsgIFN0cmluZ1xuICovXG5Kb3NlSldFLkVuY3J5cHRlci5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gdGhpcy51c2VySGVhZGVyc1trXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcGFyYW0gcGxhaW5fdGV4dCAgdXRmLTggc3RyaW5nXG4gKiBAcmV0dXJuIFByb21pc2U8U3RyaW5nPlxuICovXG5Kb3NlSldFLkVuY3J5cHRlci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWluX3RleHQpIHtcbiAgLyoqXG4gICAqIEVuY3J5cHRzIHBsYWluX3RleHQgd2l0aCBDRUsuXG4gICAqXG4gICAqIEBwYXJhbSBjZWtfcHJvbWlzZSAgUHJvbWlzZTxDcnlwdG9LZXk+XG4gICAqIEBwYXJhbSBwbGFpbl90ZXh0ICAgc3RyaW5nXG4gICAqIEByZXR1cm4gUHJvbWlzZTxqc29uPlxuICAgKi9cbiAgdmFyIGVuY3J5cHRQbGFpblRleHQgPSBmdW5jdGlvbihjZWtfcHJvbWlzZSwgcGxhaW5fdGV4dCkge1xuICAgIC8vIENyZWF0ZSBoZWFkZXJcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy51c2VySGVhZGVycykge1xuICAgICAgaGVhZGVyc1tpXSA9IHRoaXMudXNlckhlYWRlcnNbaV07XG4gICAgfVxuXG4gICAgaGVhZGVycy5hbGcgPSB0aGlzLmNyeXB0b2dyYXBoZXIuZ2V0S2V5RW5jcnlwdGlvbkFsZ29yaXRobSgpO1xuICAgIGhlYWRlcnMuZW5jID0gdGhpcy5jcnlwdG9ncmFwaGVyLmdldENvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtKCk7XG4gICAgdmFyIGp3ZV9wcm90ZWN0ZWRfaGVhZGVyID0gVXRpbHMuQmFzZTY0VXJsLmVuY29kZShKU09OLnN0cmluZ2lmeShoZWFkZXJzKSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIElWXG4gICAgdmFyIGl2ID0gdGhpcy5jcnlwdG9ncmFwaGVyLmNyZWF0ZUlWKCk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIEFBRFxuICAgIHZhciBhYWQgPSBVdGlscy5hcnJheUZyb21TdHJpbmcoandlX3Byb3RlY3RlZF9oZWFkZXIpO1xuICAgIHBsYWluX3RleHQgPSBVdGlscy5hcnJheUZyb21VdGY4U3RyaW5nKHBsYWluX3RleHQpO1xuXG4gICAgcmV0dXJuIHRoaXMuY3J5cHRvZ3JhcGhlci5lbmNyeXB0KGl2LCBhYWQsIGNla19wcm9taXNlLCBwbGFpbl90ZXh0KS50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHIuaGVhZGVyID0gandlX3Byb3RlY3RlZF9oZWFkZXI7XG4gICAgICByLml2ID0gaXY7XG4gICAgICByZXR1cm4gcjtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY2VrX3Byb21pc2UsIGVuY3J5cHRlZF9jZWs7XG5cbiAgaWYgKHRoaXMuY3J5cHRvZ3JhcGhlci5nZXRLZXlFbmNyeXB0aW9uQWxnb3JpdGhtKCkgPT0gXCJkaXJcIikge1xuICAgIC8vIHdpdGggZGlyZWN0IGVuY3J5cHRpb24sIHRoaXMua2V5X3Byb21pc2UgcHJvdmlkZXMgdGhlIGNla1xuICAgIC8vIGFuZCBlbmNyeXB0ZWRfY2VrIGlzIGVtcHR5XG4gICAgY2VrX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5rZXlfcHJvbWlzZSk7XG4gICAgZW5jcnlwdGVkX2NlayA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIENyZWF0ZSBhIENFSyBrZXlcbiAgICBjZWtfcHJvbWlzZSA9IHRoaXMuY3J5cHRvZ3JhcGhlci5jcmVhdGVDZWsoKTtcblxuICAgIC8vIEtleSAmIENlayBhbGxvd3MgdXMgdG8gY3JlYXRlIHRoZSBlbmNyeXB0ZWRfY2VrXG4gICAgZW5jcnlwdGVkX2NlayA9IFByb21pc2UuYWxsKFt0aGlzLmtleV9wcm9taXNlLCBjZWtfcHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKGFsbCkge1xuICAgICAgdmFyIGtleSA9IGFsbFswXTtcbiAgICAgIHZhciBjZWsgPSBhbGxbMV07XG4gICAgICByZXR1cm4gdGhpcy5jcnlwdG9ncmFwaGVyLndyYXBDZWsoY2VrLCBrZXkpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvLyBDZWsgYWxsb3dzIHVzIHRvIGVuY3J5cHkgdGhlIHBsYWluIHRleHRcbiAgdmFyIGVuY19wcm9taXNlID0gZW5jcnlwdFBsYWluVGV4dC5iaW5kKHRoaXMsIGNla19wcm9taXNlLCBwbGFpbl90ZXh0KSgpO1xuXG4gIC8vIE9uY2Ugd2UgaGF2ZSBhbGwgdGhlIHByb21pc2VzLCB3ZSBjYW4gYmFzZTY0IGVuY29kZSBhbGwgdGhlIHBpZWNlcy5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtlbmNyeXB0ZWRfY2VrLCBlbmNfcHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24oYWxsKSB7XG4gICAgdmFyIGVuY3J5cHRlZF9jZWsgPSBhbGxbMF07XG4gICAgdmFyIGRhdGEgPSBhbGxbMV07XG4gICAgcmV0dXJuIGRhdGEuaGVhZGVyICsgXCIuXCIgK1xuICAgICAgVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KGVuY3J5cHRlZF9jZWspICsgXCIuXCIgK1xuICAgICAgVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KGRhdGEuaXYpICsgXCIuXCIgK1xuICAgICAgVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KGRhdGEuY2lwaGVyKSArIFwiLlwiICtcbiAgICAgIFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShkYXRhLnRhZyk7XG4gIH0pO1xufTtcblxuLyotXG4gKiBDb3B5cmlnaHQgMjAxNSBQZWN1bGlhciBWZW50dXJlc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEhhbmRsZXMgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0gY3J5cHRvZ3JhcGhlciAgYW4gaW5zdGFuY2Ugb2YgV2ViQ3J5cHRvZ3JhcGhlciAob3IgZXF1aXZhbGVudCkuIEtlZXBcbiAqICAgICAgICAgICAgICAgICAgICAgICBpbiBtaW5kIHRoYXQgZGVjcnlwdGlvbiBtdXRhdGVzIHRoZSBjcnlwdG9ncmFwaGVyLlxuICogQHBhcmFtIG1lc3NhZ2UgICAgICAgIGEgSldTIG1lc3NhZ2VcbiAqIEBwYXJhbSBrZXlmaW5kZXIgKG9wdGlvbmFsKSBhIGZ1bmN0aW9uIHJldHVybmluZyBhIFByb21pc2U8Q3J5cHRvS2V5PiBnaXZlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEga2V5IGlkXG4gKlxuICogQGF1dGhvciBQYXRyaXppbyBCcnVubyA8cGF0cml6aW9AZGVzZXJ0Y29uc3VsdGluZy5uZXQ+XG4gKi9cbkpvc2VKV1MuVmVyaWZpZXIgPSBmdW5jdGlvbiAoY3J5cHRvZ3JhcGhlciwgbWVzc2FnZSwga2V5ZmluZGVyKSB7XG5cbiAgdmFyIHRoYXQgPSB0aGlzLFxuICAgIGFsZyxcbiAgICBqd3QsXG4gICAgYWFkLFxuICAgIGhlYWRlcixcbiAgICBwYXlsb2FkLFxuICAgIHNpZ25hdHVyZXMsXG4gICAgcHJvdGVjdGVkSGVhZGVyLFxuICAgIGp3dFJ4ID0gL14oWzAtOWEtel9cXC1dKylcXC4oWzAtOWEtel9cXC1dKylcXC4oWzAtOWEtel9cXC1dKykkL2k7XG5cbiAgdGhhdC5jcnlwdG9ncmFwaGVyID0gY3J5cHRvZ3JhcGhlcjtcblxuICBhbGcgPSBjcnlwdG9ncmFwaGVyLmdldENvbnRlbnRTaWduQWxnb3JpdGhtKCk7XG5cbiAgdGhhdC5jcnlwdG9ncmFwaGVyID0gbmV3IEpvc2UuV2ViQ3J5cHRvZ3JhcGhlcigpO1xuXG4gIGlmIChVdGlscy5pc1N0cmluZyhtZXNzYWdlKSkge1xuICAgIGlmICgoand0ID0gand0UnguZXhlYyhtZXNzYWdlKSkpIHtcbiAgICAgIGlmIChqd3QubGVuZ3RoICE9IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JvbmcgSldTIGNvbXBhY3Qgc2VyaWFsaXphdGlvbiBmb3JtYXRcIik7XG4gICAgICB9XG5cbiAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgIHByb3RlY3RlZDogand0WzFdLFxuICAgICAgICBwYXlsb2FkOiBqd3RbMl0sXG4gICAgICAgIHNpZ25hdHVyZTogand0WzNdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgIT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgZm9ybWF0IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cblxuICBhYWQgPSBtZXNzYWdlLnByb3RlY3RlZDtcbiAgaGVhZGVyID0gbWVzc2FnZS5oZWFkZXI7XG4gIHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gIHNpZ25hdHVyZXMgPSBtZXNzYWdlLnNpZ25hdHVyZXMgaW5zdGFuY2VvZiBBcnJheSA/IG1lc3NhZ2Uuc2lnbmF0dXJlcy5zbGljZSgwKSA6IFtdO1xuXG4gIHNpZ25hdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lnbikge1xuICAgIHNpZ24uYWFkID0gc2lnbi5wcm90ZWN0ZWQ7XG4gICAgc2lnbi5wcm90ZWN0ZWQgPSBKU09OLnBhcnNlKFV0aWxzLkJhc2U2NFVybC5kZWNvZGUoc2lnbi5wcm90ZWN0ZWQpKTtcbiAgfSk7XG5cbiAgdGhhdC5hYWQgPSBhYWQ7XG4gIHByb3RlY3RlZEhlYWRlciA9IFV0aWxzLkJhc2U2NFVybC5kZWNvZGUoYWFkKTtcbiAgdHJ5IHtcbiAgICBwcm90ZWN0ZWRIZWFkZXIgPSBKU09OLnBhcnNlKHByb3RlY3RlZEhlYWRlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIGlmICghcHJvdGVjdGVkSGVhZGVyICYmICFoZWFkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdCBsZWFzdCBvbmUgaGVhZGVyIGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgaWYgKCFwcm90ZWN0ZWRIZWFkZXIuYWxnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiJ2FsZycgaXMgYSBtYW5kYXRvcnkgaGVhZGVyXCIpO1xuICB9XG5cbiAgaWYgKHByb3RlY3RlZEhlYWRlci5hbGcgIT0gYWxnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIGFsZyBoZWFkZXIgJ1wiICsgcHJvdGVjdGVkSGVhZGVyLmFsZyArIFwiJyBkb2Vzbid0IG1hdGNoIHRoZSByZXF1ZXN0ZWQgYWxnb3JpdGhtICdcIiArIGFsZyArIFwiJ1wiKTtcbiAgfVxuXG4gIGlmIChwcm90ZWN0ZWRIZWFkZXIgJiYgcHJvdGVjdGVkSGVhZGVyLnR5cCAmJiBwcm90ZWN0ZWRIZWFkZXIudHlwICE9IFwiSldUXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXAgJ1wiICsgcHJvdGVjdGVkSGVhZGVyLnR5cCArIFwiJyBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlcy51bnNoaWZ0KHtcbiAgICAgIGFhZDogYWFkLFxuICAgICAgcHJvdGVjdGVkOiBwcm90ZWN0ZWRIZWFkZXIsXG4gICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgIHNpZ25hdHVyZTogbWVzc2FnZS5zaWduYXR1cmVcbiAgICB9KTtcbiAgfVxuXG4gIHRoYXQuc2lnbmF0dXJlcyA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoYXQuc2lnbmF0dXJlc1tpXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlc1tpXSkpO1xuICAgIHRoYXQuc2lnbmF0dXJlc1tpXS5zaWduYXR1cmUgPSBVdGlscy5hcnJheUZyb21TdHJpbmcoVXRpbHMuQmFzZTY0VXJsLmRlY29kZShzaWduYXR1cmVzW2ldLnNpZ25hdHVyZSkpO1xuICB9XG5cbiAgdGhhdC5wYXlsb2FkID0gcGF5bG9hZDtcblxuICB0aGF0LmtleV9wcm9taXNlcyA9IHt9O1xuICB0aGF0LndhaXRpbmdfa2lkID0gMDtcblxuICBpZiAoa2V5ZmluZGVyKSB7XG4gICAgdGhhdC5rZXlmaW5kZXIgPSBrZXlmaW5kZXI7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIHN1cHBvcnRlZCByZWNpcGllbnRzIHRvIHZlcmlmeSBtdWx0aXBsZSBzaWduYXR1cmVzXG4gKlxuICogQHBhcmFtIHJzYV9rZXkgICAgICAgIHB1YmxpYyBSU0Ega2V5IGluIGpzb24gZm9ybWF0LiBQYXJhbWV0ZXJzIGNhbiBiZSBiYXNlNjRcbiAqICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkLCBzdHJpbmdzIG9yIG51bWJlciAoZm9yICdlJykuXG4gKiBAcGFyYW0ga2V5X2lkICAgICAgICAgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHJzYV9rZXkuIE9QVElPTkFMXG4gKiBAcGFyYW0gYWxnICAgICAgICAgICAgU3RyaW5nIHNpZ25hdHVyZSBhbGdvcml0aG0uIE9QVElPTkFMXG4gKiBAcmV0dXJucyBQcm9taXNlPHN0cmluZz4gYSBQcm9taXNlIG9mIGEga2V5IGlkXG4gKi9cbkpvc2VKV1MuVmVyaWZpZXIucHJvdG90eXBlLmFkZFJlY2lwaWVudCA9IGZ1bmN0aW9uIChyc2Ffa2V5LCBrZXlfaWQsIGFsZykge1xuXG4gIHZhciB0aGF0ID0gdGhpcyxcbiAgICBraWRfcHJvbWlzZSxcbiAgICBrZXlfcHJvbWlzZSA9IFV0aWxzLmlzQ3J5cHRvS2V5KHJzYV9rZXkpID8gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUocnNhX2tleSk7XG4gICAgfSkgOiBKb3NlLlV0aWxzLmltcG9ydFJzYVB1YmxpY0tleShyc2Ffa2V5LCBhbGcgfHwgdGhhdC5jcnlwdG9ncmFwaGVyLmdldENvbnRlbnRTaWduQWxnb3JpdGhtKCksIFwidmVyaWZ5XCIpO1xuXG4gIGlmIChrZXlfaWQpIHtcbiAgICBraWRfcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGtleV9pZCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoVXRpbHMuaXNDcnlwdG9LZXkocnNhX2tleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlfaWQgaXMgYSBtYW5kYXRvcnkgYXJndW1lbnQgd2hlbiB0aGUga2V5IGlzIGEgQ3J5cHRvS2V5XCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwiaXQncyBub3Qgc2FmZSB0byBub3QgcGFzcyBhIGtleV9pZFwiKTtcbiAgICBraWRfcHJvbWlzZSA9IEpvc2UuV2ViQ3J5cHRvZ3JhcGhlci5rZXlJZChyc2Ffa2V5KTtcbiAgfVxuXG4gIHRoYXQud2FpdGluZ19raWQrKztcblxuICByZXR1cm4ga2lkX3Byb21pc2UudGhlbihmdW5jdGlvbiAoa2lkKSB7XG4gICAgdGhhdC5rZXlfcHJvbWlzZXNba2lkXSA9IGtleV9wcm9taXNlO1xuICAgIHRoYXQud2FpdGluZ19raWQtLTtcbiAgICByZXR1cm4ga2lkO1xuICB9KTtcbn07XG5cblxuLyotXG4gKiBDb3B5cmlnaHQgMjAxNSBQZWN1bGlhciBWZW50dXJlc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEhhbmRsZXMgZGVjcnlwdGlvbi5cbiAqXG4gKiBAcGFyYW0gY3J5cHRvZ3JhcGhlciAgYW4gaW5zdGFuY2Ugb2YgV2ViQ3J5cHRvZ3JhcGhlciAob3IgZXF1aXZhbGVudCkuIEtlZXBcbiAqICAgICAgICAgICAgICAgICAgICAgICBpbiBtaW5kIHRoYXQgZGVjcnlwdGlvbiBtdXRhdGVzIHRoZSBjcnlwdG9ncmFwaGVyLlxuICpcbiAqIEBhdXRob3IgUGF0cml6aW8gQnJ1bm8gPHBhdHJpemlvQGRlc2VydGNvbnN1bHRpbmcubmV0PlxuICovXG5Kb3NlSldTLlNpZ25lciA9IGZ1bmN0aW9uKGNyeXB0b2dyYXBoZXIpIHtcbiAgdGhpcy5jcnlwdG9ncmFwaGVyID0gY3J5cHRvZ3JhcGhlcjtcblxuICB0aGlzLmtleV9wcm9taXNlcyA9IHt9O1xuICB0aGlzLndhaXRpbmdfa2lkID0gMDtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMuc2lnbmVyX2FhZHMgPSB7fTtcbiAgdGhpcy5zaWduZXJfaGVhZGVycyA9IHt9O1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc2lnbmVyIHRvIEpvc2VKV1MgaW5zdGFuY2UuIEl0J2xsIGJlIHRoZSBvbiBvZiB0aGUgc2lnbmVycyBvZiB0aGUgcmVzdWx0aW5nIEpXUy5cbiAqXG4gKiBAcGFyYW0gcnNhX2tleSAgICAgICAgcHJpdmF0ZSBSU0Ega2V5IGluIGpzb24gZm9ybWF0LCBQYXJhbWV0ZXJzIGNhbiBiZSBiYXNlNjRcbiAqICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkLCBzdHJpbmdzIG9yIG51bWJlciAoZm9yICdlJykuIE9yIENyeXB0b0tleVxuICogQHBhcmFtIGtleV9pZCAgICAgICAgIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSByc2Ffa2V5LiBPUFRJT05BTFxuICogQHBhcmFtIGFhZCAgICAgICAgICAgIE9iamVjdCBwcm90ZWN0ZWQgaGVhZGVyXG4gKiBAcGFyYW0gaGVhZGVyICAgICAgICAgT2JqZWN0IHVucHJvdGVjdGVkIGhlYWRlclxuICovXG5Kb3NlSldTLlNpZ25lci5wcm90b3R5cGUuYWRkU2lnbmVyID0gZnVuY3Rpb24ocnNhX2tleSwga2V5X2lkLCBhYWQsIGhlYWRlcikge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlfcHJvbWlzZTtcbiAgaWYgKFV0aWxzLmlzQ3J5cHRvS2V5KHJzYV9rZXkpKSB7XG4gICAga2V5X3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHJzYV9rZXkpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbGc7XG4gICAgaWYgKGFhZCAmJiBhYWQuYWxnKSB7XG4gICAgICBhbGcgPSBhYWQuYWxnO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGcgPSB0aGF0LmNyeXB0b2dyYXBoZXIuZ2V0Q29udGVudFNpZ25BbGdvcml0aG0oKTtcbiAgICB9XG4gICAga2V5X3Byb21pc2UgPSBKb3NlLlV0aWxzLmltcG9ydFJzYVByaXZhdGVLZXkocnNhX2tleSwgYWxnLCBcInNpZ25cIik7XG4gIH1cblxuICB2YXIga2lkX3Byb21pc2U7XG4gIGlmIChrZXlfaWQpIHtcbiAgICBraWRfcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoa2V5X2lkKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChVdGlscy5pc0NyeXB0b0tleShyc2Ffa2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImtleV9pZCBpcyBhIG1hbmRhdG9yeSBhcmd1bWVudCB3aGVuIHRoZSBrZXkgaXMgYSBDcnlwdG9LZXlcIik7XG4gIH0gZWxzZSB7XG4gICAga2lkX3Byb21pc2UgPSBKb3NlLldlYkNyeXB0b2dyYXBoZXIua2V5SWQocnNhX2tleSk7XG4gIH1cblxuICB0aGF0LndhaXRpbmdfa2lkKys7XG5cbiAgcmV0dXJuIGtpZF9wcm9taXNlLnRoZW4oZnVuY3Rpb24oa2lkKSB7XG4gICAgdGhhdC5rZXlfcHJvbWlzZXNba2lkXSA9IGtleV9wcm9taXNlO1xuICAgIHRoYXQud2FpdGluZ19raWQtLTtcbiAgICBpZiAoYWFkKSB7XG4gICAgICB0aGF0LnNpZ25lcl9hYWRzW2tpZF0gPSBhYWQ7XG4gICAgfVxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIHRoYXQuc2lnbmVyX2hlYWRlcnNba2lkXSA9IGhlYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGtpZDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzaWduYXR1cmUgdG8gYSBKV1Mgb2JqZWN0XG4gKiBAcGFyYW0gandzIEpXUyBPYmplY3QgdG8gYmUgc2lnbmVkIG9yIGl0cyByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIGFhZCAgICAgT2JqZWN0IHByb3RlY3RlZCBoZWFkZXJcbiAqIEBwYXJhbSBoZWFkZXIgIE9iamVjdCB1bnByb3RlY3RlZCBoZWFkZXJcbiAqIEByZXR1cm4gUHJvbWlzZTxTdHJpbmc+XG4gKi9cbkpvc2VKV1MuU2lnbmVyLnByb3RvdHlwZS5hZGRTaWduYXR1cmUgPSBmdW5jdGlvbihqd3MsIGFhZCwgaGVhZGVyKSB7XG4gIGlmIChVdGlscy5pc1N0cmluZyhqd3MpKSB7XG4gICAgandzID0gSlNPTi5wYXJzZShqd3MpO1xuICB9XG5cbiAgaWYgKGp3cy5wYXlsb2FkICYmIFV0aWxzLmlzU3RyaW5nKGp3cy5wYXlsb2FkKSAmJlxuICAgIGp3cy5wcm90ZWN0ZWQgJiYgVXRpbHMuaXNTdHJpbmcoandzLnByb3RlY3RlZCkgJiZcbiAgICBqd3MuaGVhZGVyICYmIGp3cy5oZWFkZXIgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICBqd3Muc2lnbmF0dXJlICYmIFV0aWxzLmlzU3RyaW5nKGp3cy5zaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbihKV1MuZnJvbU9iamVjdChqd3MpLCBhYWQsIGhlYWRlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSldTIGlzIG5vdCBhIHZhbGlkIEpXUyBvYmplY3RcIik7XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkIEpXUyBPYmplY3Qgb3IgdXRmLTggc3RyaW5nIHRvIGJlIHNpZ25lZFxuICogQHBhcmFtIGFhZCAgICAgT2JqZWN0IHByb3RlY3RlZCBoZWFkZXJcbiAqIEBwYXJhbSBoZWFkZXIgIE9iamVjdCB1bnByb3RlY3RlZCBoZWFkZXJcbiAqIEByZXR1cm4gUHJvbWlzZTxKV1M+XG4gKi9cbkpvc2VKV1MuU2lnbmVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24ocGF5bG9hZCwgYWFkLCBoZWFkZXIpIHtcblxuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBraWRzID0gW107XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRoYXQua2V5X3Byb21pc2VzKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXJzIGRlZmluZWQuIEF0IGxlYXN0IG9uZSBpcyByZXF1aXJlZCB0byBzaWduIHRoZSBKV1MuXCIpO1xuICB9XG5cbiAgaWYgKHRoYXQud2FpdGluZ19raWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGlsbCBnZW5lcmF0aW5nIGtleSBJRHNcIik7XG4gIH1cblxuICBmdW5jdGlvbiBzaWduIChtZXNzYWdlLCBwcm90ZWN0ZWRIZWFkZXIsIHVucHJvdGVjdGVkSGVhZGVyLCByc2Ffa2V5X3Byb21pc2UsIGtpZCkge1xuICAgIHZhciB0b0JlU2lnbmVkO1xuXG4gICAgaWYgKCFwcm90ZWN0ZWRIZWFkZXIpIHtcbiAgICAgIHByb3RlY3RlZEhlYWRlciA9IHt9O1xuICAgIH1cblxuICAgIGlmICghcHJvdGVjdGVkSGVhZGVyLmFsZykge1xuICAgICAgcHJvdGVjdGVkSGVhZGVyLmFsZyA9IHRoYXQuY3J5cHRvZ3JhcGhlci5nZXRDb250ZW50U2lnbkFsZ29yaXRobSgpO1xuICAgICAgcHJvdGVjdGVkSGVhZGVyLnR5cCA9IFwiSldUXCI7XG4gICAgfVxuXG4gICAgaWYgKCFwcm90ZWN0ZWRIZWFkZXIua2lkKSB7XG4gICAgICBwcm90ZWN0ZWRIZWFkZXIua2lkID0ga2lkO1xuICAgIH1cblxuICAgIGlmIChVdGlscy5pc1N0cmluZyhtZXNzYWdlKSkge1xuICAgICAgdG9CZVNpZ25lZCA9IFV0aWxzLmFycmF5RnJvbVV0ZjhTdHJpbmcobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRvQmVTaWduZWQgPSBVdGlscy5hcnJheWlzaChtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBKV1MpIHtcbiAgICAgICAgICB0b0JlU2lnbmVkID0gVXRpbHMuYXJyYXlGcm9tU3RyaW5nKFV0aWxzLkJhc2U2NFVybC5kZWNvZGUobWVzc2FnZS5wYXlsb2FkKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHRvQmVTaWduZWQgPSBVdGlscy5hcnJheUZyb21VdGY4U3RyaW5nKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc2lnbiB0aGlzIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdC5jcnlwdG9ncmFwaGVyLnNpZ24ocHJvdGVjdGVkSGVhZGVyLCB0b0JlU2lnbmVkLCByc2Ffa2V5X3Byb21pc2UpLnRoZW4oZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgICB2YXIgandzID0gbmV3IEpXUyhwcm90ZWN0ZWRIZWFkZXIsIHVucHJvdGVjdGVkSGVhZGVyLCB0b0JlU2lnbmVkLCBzaWduYXR1cmUpO1xuICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBKV1MpIHtcbiAgICAgICAgZGVsZXRlIGp3cy5wYXlsb2FkO1xuICAgICAgICBpZiAoIW1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcyA9IFtqd3NdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcy5wdXNoKGp3cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gandzO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9TaWduIChwbCwgcGgsIHVoLCBrcHMsIGtpZHMpIHtcbiAgICBpZiAoa2lkcy5sZW5ndGgpIHtcbiAgICAgIHZhciBrX2lkID0ga2lkcy5zaGlmdCgpO1xuICAgICAgdmFyIHJ2ID0gc2lnbihwbCwgdGhhdC5zaWduZXJfYWFkc1trX2lkXSB8fCBwaCwgdGhhdC5zaWduZXJfaGVhZGVyc1trX2lkXSB8fCB1aCwga3BzW2tfaWRdLCBrX2lkKTtcbiAgICAgIGlmIChraWRzLmxlbmd0aCkge1xuICAgICAgICBydiA9IHJ2LnRoZW4oZnVuY3Rpb24oandzKSB7XG4gICAgICAgICAgcmV0dXJuIGRvU2lnbihqd3MsIG51bGwsIG51bGwsIGtwcywga2lkcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgfVxuXG4gIGZvcih2YXIga2lkIGluIHRoYXQua2V5X3Byb21pc2VzKSB7XG4gICAgaWYgKHRoYXQua2V5X3Byb21pc2VzLmhhc093blByb3BlcnR5KGtpZCkpIHtcbiAgICAgIGtpZHMucHVzaChraWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG9TaWduKHBheWxvYWQsIGFhZCwgaGVhZGVyLCB0aGF0LmtleV9wcm9taXNlcywga2lkcyk7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIEpXUyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByb3RlY3RlZEhlYWRlciBwcm90ZWN0ZWQgaGVhZGVyIChKUyBvYmplY3QpXG4gKiBAcGFyYW0gcGF5bG9hZCBVaW50OEFycmF5IHBheWxvYWQgdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0gc2lnbmF0dXJlIEFycmF5QnVmZmVyIHNpZ25hdHVyZSBvZiB0aGUgcGF5bG9hZFxuICogQHBhcmFtIGhlYWRlciB1bnByb3RlY3RlZCBoZWFkZXIgKEpTIG9iamVjdClcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpXUyA9IGZ1bmN0aW9uKHByb3RlY3RlZEhlYWRlciwgaGVhZGVyLCBwYXlsb2FkLCBzaWduYXR1cmUpIHtcbiAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gIHRoaXMucGF5bG9hZCA9IFV0aWxzLkJhc2U2NFVybC5lbmNvZGVBcnJheShwYXlsb2FkKTtcbiAgaWYgKHNpZ25hdHVyZSkge1xuICAgIHRoaXMuc2lnbmF0dXJlID0gVXRpbHMuQmFzZTY0VXJsLmVuY29kZUFycmF5KHNpZ25hdHVyZSk7XG4gIH1cbiAgdGhpcy5wcm90ZWN0ZWQgPSBVdGlscy5CYXNlNjRVcmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHByb3RlY3RlZEhlYWRlcikpO1xufTtcblxuSldTLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJ2ID0gbmV3IEpXUyhvYmoucHJvdGVjdGVkLCBvYmouaGVhZGVyLCBvYmoucGF5bG9hZCwgbnVsbCk7XG4gIHJ2LnNpZ25hdHVyZSA9IG9iai5zaWduYXR1cmU7XG4gIHJ2LnNpZ25hdHVyZXMgPSBvYmouc2lnbmF0dXJlcztcbiAgcmV0dXJuIHJ2O1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSBKV1Mgb2JqZWN0IHVzaW5nIHRoZSBKU09OIHNlcmlhbGl6YXRpb24gZm9ybWF0XG4gKlxuICogQHJldHVybnMge09iamVjdH0gYSBjb3B5IG9mIHRoaXNcbiAqL1xuSldTLnByb3RvdHlwZS5Kc29uU2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgSldTIG9iamVjdCB1c2luZyB0aGUgQ29tcGFjdCBTZXJpYWxpemF0aW9uIEZvcm1hdFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJBU0U2NFVSTChVVEY4KFBST1RFQ1RFRCBIRUFERVIpKS5CQVNFNjRVUkwoUEFZTE9BRCkuQkFTRTY0VVJMKFNJR05BVFVSRSlcbiAqL1xuSldTLnByb3RvdHlwZS5Db21wYWN0U2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByb3RlY3RlZCArICcuJyArIHRoaXMucGF5bG9hZCArICcuJyArIHRoaXMuc2lnbmF0dXJlO1xufTtcblxuXG4vKipcbiAqIFZlcmlmaWVzIGEgSldTIHNpZ25hdHVyZVxuICpcbiAqIEByZXR1cm5zIFByb21pc2U8QXJyYXk+IGEgUHJvbWlzZSBvZiBhbiBhcnJheSBvZiBvYmplY3RzIHsga2lkOiBzdHJpbmcsIHZlcmlmaWVkOiBib29sLCBwYXlsb2FkPzogc3RyaW5nIH1cbiAqXG4gKiBwYXlsb2FkIGlzIG9ubHkgcG9wdWxhdGVkIGFuZCB1c2FibGUgaWYgdmVyaWZpZWQgaXMgdHJ1ZVxuICovXG5Kb3NlSldTLlZlcmlmaWVyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRoYXQgPSB0aGlzLFxuICAgIHNpZ25hdHVyZXMgPSB0aGF0LnNpZ25hdHVyZXMsXG4gICAga2V5X3Byb21pc2VzID0gdGhhdC5rZXlfcHJvbWlzZXMsXG4gICAga2V5ZmluZGVyID0gdGhhdC5rZXlmaW5kZXIsXG4gICAgcHJvbWlzZXMgPSBbXSxcbiAgICBjaGVjayA9ICEha2V5ZmluZGVyIHx8IE9iamVjdC5rZXlzKHRoYXQua2V5X3Byb21pc2VzKS5sZW5ndGggPiAwO1xuXG4gIGlmICghY2hlY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNpcGllbnRzIGRlZmluZWQuIEF0IGxlYXN0IG9uZSBpcyByZXF1aXJlZCB0byB2ZXJpZnkgdGhlIEpXUy5cIik7XG4gIH1cblxuICBpZiAodGhhdC53YWl0aW5nX2tpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0aWxsIGdlbmVyYXRpbmcga2V5IElEc1wiKTtcbiAgfVxuXG4gIHNpZ25hdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGtpZCA9IHNpZy5wcm90ZWN0ZWQua2lkO1xuICAgIGlmIChrZXlmaW5kZXIpIHtcbiAgICAgIGtleV9wcm9taXNlc1traWRdID0ga2V5ZmluZGVyKGtpZCk7XG4gICAgfVxuICAgIHByb21pc2VzLnB1c2godGhhdC5jcnlwdG9ncmFwaGVyLnZlcmlmeShzaWcuYWFkLCB0aGF0LnBheWxvYWQsIHNpZy5zaWduYXR1cmUsIGtleV9wcm9taXNlc1traWRdLCBraWQpXG4gICAgICAudGhlbihmdW5jdGlvbiAodnIpIHtcbiAgICAgICAgaWYgKHZyLnZlcmlmaWVkKSB7XG4gICAgICAgICAgdnIucGF5bG9hZCA9IFV0aWxzLkJhc2U2NFVybC5kZWNvZGUodGhhdC5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdnI7XG4gICAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuXG5cblxuXG5cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgVmlzYSBWRENQIHVzZS1jYXNlLlxuICogZXhwZWN0cyBhbiBSU0Ega2V5IGFzIGEgSlMgZGF0YSBvYmplY3Qgd2l0aCAyIHJlcXVpcmVkIGZpZWxkczpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcnNhS2V5SWQgKFJFUVVJUkVEKVxuICogQHBhcmFtIHshb2JqZWN0fSByc2FLZXkgKFJFUVVJUkVEKVxuICogICAgUmVxdWlyZXM6XG4gKiAgICAgIC0gYG5gIGF0dHJpYnV0ZSAobW9kdWx1cylcbiAqICAgICAgLSBgZWAgYXR0cmlidXRlIChwdWJsaWNFeHBvbmVudClcbiAqIEBwYXJhbSB7P3N0cmluZ30gc2NoZW1lIChvcHRpb25hbCkgZGVmYXVsdCAnUlNBLU9BRVAtMjU2J1xuICogQHBhcmFtIHs/QVBJfSBjcnlwdG9Qcm92aWRlciAob3B0aW9uYWwpIHdpbmRvdy5jcnlwdG8sIG5vZGUtd2ViY3J5cHRvLW9zc2wsIG5vZGUtd2ViY3J5cHRvLXBrY3MxMSBldGMuXG4gKi9cbnZhciBQQU5KV0UgPSBmdW5jdGlvbihyc2FLZXlJZCwgcnNhS2V5LCBzY2hlbWUsIGNyeXB0b1Byb3ZpZGVyKSB7XG4gIHNjaGVtZSA9IHNjaGVtZSB8fCAnUlNBLU9BRVAtMjU2JztcblxuICBpZiAoY3J5cHRvUHJvdmlkZXIpIHtcbiAgICBKb3NlLnNldENyeXB0byhjcnlwdG9Qcm92aWRlcik7XG4gIH1cblxuICB2YXIgY3J5cHRvZ3JhcGhlciA9IG5ldyBKb3NlLldlYkNyeXB0b2dyYXBoZXIoKTtcblxuICAvLyBzZXQgdmFsdWVzIGZvciBzY2hlbWUgYW5kIGNvbnRlbnQgZW5jcnlwdGlvbiBhbGdvcml0aG0uIFRoZXkgd2lsbCBiZSBhZGRlZCB0byBoZWFkZXIgYnkgSm9zZUpXRS5FbmNyeXB0ZXIuZW5jcnlwdFxuICBjcnlwdG9ncmFwaGVyLnNldEtleUVuY3J5cHRpb25BbGdvcml0aG0oc2NoZW1lKTtcbiAgY3J5cHRvZ3JhcGhlci5zZXRDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobSgnQTI1NkdDTScpO1xuXG4gIHZhciByc2Ffa2V5ID0gSm9zZS5VdGlscy5pbXBvcnRSc2FQdWJsaWNLZXkocnNhS2V5LCBzY2hlbWUpO1xuICB2YXIgZW5jcnlwdGVyID0gbmV3IEpvc2VKV0UuRW5jcnlwdGVyKGNyeXB0b2dyYXBoZXIsIHJzYV9rZXkpO1xuICBlbmNyeXB0ZXIuYWRkSGVhZGVyKCdraWQnLCByc2FLZXlJZCk7XG4gIGVuY3J5cHRlci5hZGRIZWFkZXIoJ3R5cCcsICdKT1NFJyk7XG5cbiAgdGhpcy5lbmNyeXB0ZXIgPSBlbmNyeXB0ZXI7XG5cbiAgLy8gZm9yIHRlc3RpbmcsIHRlc3RpbmcgYnVuZGxlIGluY2x1ZGVzIGRlY3J5cHRlciBtaXhpbnNcbiAgaWYgKEpvc2VKV0UuRGVjcnlwdGVyKSB7XG4gICAgdmFyIHByaXZhdGVfcnNhX2tleSA9IEpvc2UuVXRpbHMuaW1wb3J0UnNhUHJpdmF0ZUtleShyc2FLZXksIHNjaGVtZSk7XG4gICAgdmFyIGRlY3J5cHRlciA9IG5ldyBKb3NlSldFLkRlY3J5cHRlcihjcnlwdG9ncmFwaGVyLCBwcml2YXRlX3JzYV9rZXkpO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gZGVjcnlwdGVyO1xuXG4gICAgLyoqXG4gICAgICogZW5jcnlwdHMgdGV4dFxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZW5jcnlwdGVkVGV4dCBzdHJpbmcgdG8gZGVjcnlwdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHRoaXMuZGVjcnlwdCA9IGZ1bmN0aW9uKGVuY3J5cHRlZFRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZFRleHQpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogc2FuaXR5IGNoZWNrXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICB0aGlzLnNhbml0eUNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEpvc2UuY2FuaXVzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBlbmNyeXB0cyB0ZXh0XG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY2lwaGVyVGV4dCBzdHJpbmcgdG8gZW5jcnlwdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHRoaXMuZW5jcnlwdCA9IGZ1bmN0aW9uKGNpcGhlclRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0ZXIuZW5jcnlwdChjaXBoZXJUZXh0KS8qIC50aGVuKHJlcyA9PiB7XG4gICAgICB0aGlzLnZlcmlmeSgpLnRoZW4odmVyaWZ5UmVzID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYHZlcmlmeSByZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkodmVyaWZ5cmVzKX1gKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0pOyAqL1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMuUEFOSldFID0gUEFOSldFO1xuZXhwb3J0cy5QQU5KV0UgPSBQQU5KV0U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},5:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n;// CONCATENATED MODULE: ./benchmark/js/helpers/utils.js\nconst cel = tag => document.createElement(tag);\nconst utils_gel = id => document.getElementById(id);\nconst gecn = cls => document.getElementsByClassName(cls);\nconst qs = cls => document.querySelector(cls);\nconst qsa = cls => document.querySelectorAll(cls);\n\n\nfunction extractHostname(url) {\n  var hostname;\n  if (url.indexOf(\"//\") > -1) {\n    hostname = url.split('/')[2];\n  }\n  else {\n    hostname = url.split('/')[0];\n  }\n  //find & remove port number\n  hostname = hostname.split(':')[0];\n  //find & remove \"?\"\n  hostname = hostname.split('?')[0];\n  return hostname;\n}\n\nconst catchErr = err => {\n  console.trace(`[ERROR CAUGHT]`, err);\n  const header = cel('div');\n  const pre = cel('pre');\n  const trace = cel('pre');\n  const ts = new Date().toLocaleString();\n  header.innerHTML = `[${ts}] error caught:`;\n  utils_gel('error_log').appendChild(header);\n  \n  if (err.stack) {\n    trace.innerHTML = err.stack;\n    utils_gel('error_log').appendChild(trace);\n  } else {\n    pre.classList.add('error');\n    pre.innerHTML = (typeof err === 'string') ? err : JSON.stringify(err, null, 2);\n    utils_gel('error_log').appendChild(pre);\n  }\n  return err;\n}\n\n\nfunction serializeObject(obj) {\n  if (!obj) {\n    return '';\n  }\n\n  var s = [];\n\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && obj[key].constructor === Array) {\n      obj[key].forEach(function (value) {\n        s.push(key + '=' + encodeURIComponent(value));\n      });\n    } else {\n      s.push(key + '=' + encodeURIComponent(obj[key]));\n    }\n  });\n\n  return s.join('&');\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/compliance-settings.js\n\n\nconst injectComplianceSettings = () => {\n  const terms = {\n    complianceType: \"TERMS_AND_CONDITIONS\",\n    uri: \"usa.visa.com/legal/checkout/terms-of-service.html\",\n  };\n  const privacy = {\n    complianceType: \"PRIVACY_POLICY\",\n    uri: \"usa.visa.com/legal/global-privacy-notice.html\",\n  };\n  const remember = {\n    complianceType: \"REMEMBER_ME\",\n    uri: \"visa.checkout.com/privacy\",\n  };\n\n  intentPayload.complianceSettings = {\n    complianceResources: [terms, privacy, remember]\n  };\n}\n\nconst removeComplianceSettings = () => {\n  intentPayload && delete intentPayload.complianceSettings;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/stubs/data.js\n\n\n\nlet data_initData;\nlet intentPayload;\n\nconst initDataRoot = {\n  srciTransactionId: \"replace me\",\n  // srciDpaId: \"DPAID\",\n  srcInitiatorId: \"[A-Fa-f0-9|A-Fa-f0-9]{8}\\\\-([A-Fa-f0-9|A-Fa-f0-9]{4}\\\\-){3}[A-Fa-f0-9|A-Fa-f0-9]{12}\",\n  dpaData: {\n    // srcDpaId: \"SRCDPAID\",\n    dpaPresentationName: \"Disney Online\",\n    dpaUri: \"http://www.disneyonline.com\"\n  },\n  dpaTransactionOptions: {\n    dpaLocale: \"US\",\n    dpaAcceptedBillingCountries: [\"US\",\"CA\"],\n    dpaAcceptedShippingCountries: [\"US\",\"CA\"],\n    dpaBillingPreference: \"FULL\",\n    dpaShippingPreference: \"FULL\",\n    consumerNameRequested: true,\n    consumerEmailAddressRequested: true,\n    consumerPhoneNumberRequested: true,\n    paymentOptions: {\n      dpaDynamicDataTtlMinutes: 2,\n      dynamicDataType: \"DYNAMIC_CARD_SECURITY_CODE\",\n      dpaPanRequested: false\n    },\n    reviewAction: \"continue\",\n    transactionType: \"PURCHASE\",\n    orderType: \"REAUTHORIZATION\",\n    payloadTypeIndicator: \"SUMMARY\",\n    transactionAmount: {\n      transactionAmount: \"99.95\",\n      transactionCurrencyCode: \"USD\"\n    },\n    merchantOrderId: \"28b1b61b-bbec-4637-b78f-33babc3b5187\",\n    merchantCategoryCode: \"3000\",\n    merchantCountryCode: \"US\",\n    threeDsPreference: \"NONE\",\n    threeDsInputData: {\n      requestorId: \"requestorId\",\n      acquirerId: \"acquirerId\",\n      acquirerMid: \"acquirerMid\"\n    },\n    customInputData:{\n      checkoutOrchestrator: \"merchant\",//\"TESTING\", // 'merchant' is integrated exp\n      dpaIntegrationType: \"PSP\"\n    }\n  }\n};\n\nconst userInfo = {\n  identityProvider: \"SRC\",\n  identityValue: \"senthilr@mailinator.com\",\n  OTP_performed: false,\n  cardList_performed: false,\n  type: \"EMAIL\"\n};\n\nconst intentPayloadRoot = {\n  srcCorrelationId: \"\",\n  srciTransactionId: \"\",\n  srcDigitalCardId: \"\",\n  encryptedCard: \"\",\n  idToken: \"\",\n  windowRef: \"\",\n  consumer:{\n    consumerIdentity: {\n      identityProvider: \"SRC\", \n      identityType: \"EMAIL_ADDRESS\",\n      identityValue: \"ashok.vbox28@mailinator.com\"\n    },\n    mobileNumber: {\n      phoneNumber: \"4153334444\",\n      countryCode: \"1\"\n    },\n    emailAddress: \"ashok.vbox28@mailinator.com\",\n    nationalIdentifier: \"USA\",\n    countryCode: \"US\",\n    languageCode: \"EN\",\n    firstName: \"PSP\",\n    lastName: \"Tester\",\n    fullName: \"Psp Tester\"\n  },\n  dpaTransactionOptions: {\n    dpaLocale: \"US\",\n    dpaAcceptedBillingCountries: [\"US\",\"CA\"],\n    dpaAcceptedShippingCountries: [\"US\",\"CA\"],\n    dpaBillingPreference: \"ALL\",\n    dpaShippingPreference: \"ALL\",\n    consumerNameRequested: true,\n    consumerEmailAddressRequested: true,\n    consumerPhoneNumberRequested: true,\n    paymentOptions: {\n      dpaDynamicDataTtlMinutes: 2,\n      dynamicDataType: \"TAVV\",\n      dpaPanRequested: false\n    },\n    reviewAction: \"continue\",\n    checkoutDescription: \"Sample checkout\",\n    transactionType: \"PURCHASE\",\n    orderType: \"REAUTHORIZATION\",\n    payloadTypeIndicator: \"SUMMARY\",\n    transactionAmount: {\n      transactionAmount: \"99.95\",\n      transactionCurrencyCode: \"USD\"\n    },\n    merchantOrderId: \"ABC12345\",\n    merchantCategoryCode: \"merchantCategoryCode\",\n    merchantCountryCode: \"US\",\n    threeDsInputData: {\n      requestorId: \"requestorId\",\n      acquirerId: \"acquirerId\",\n      acquirerMid: \"acquirerMid\"\n    },\n    customInputData:{\n      dpaIntegrationType:\"PSP\"\n    }\n  },\n  payloadTypeIndicatorCheckout: \"SUMMARY\", // FULL\n  recipientIdPayload: \"\",\n  assuranceData: {\n    verificationData:[{\n      verificationType: \"CARDHOLDER\",\n      verificationEntity: \"01\",\n      verificationMethod: \"01\",\n      verificationresponses: \"01\",\n      verificationResults: \"01\",\n      verificationTimestamp: \"1646416550\"\n    }]\n  },\n  srciActionCode: \"NEW_USER\" \n};\n\nlet srcProfiles = [];\n\nconst benchmark = {\n  init: 0,\n  isRecognized: 0,\n  identityLookup: 0,\n  initiateIdentityValidation: 0,\n  // UIUX_to_OTP: 0,\n  completeIdentityValidation: 0,\n  getSrcProfile: 0,\n  // UIUX_to_cardList: 0,\n  checkout: 0,\n  addCard: 0,\n  enrollUser: 0,\n  unbind: 0,\n};\n\nconst benchmarkState = {\n  sdkUrl: '',\n};\n\nconst resetFlow = () => {\n  console.info('RESET')\n  data_initData = Object.assign({}, initDataRoot);\n  intentPayload = Object.assign({}, intentPayloadRoot);\n  userInfo.OTP_performed = false;\n  userInfo.cardList_performed = false;\n  srcProfiles = [];\n};\n\n\nconst data_getIntentPayload = () => {\n  if (!intentPayload) {\n    intentPayload = Object.assign({}, intentPayloadRoot);\n  }\n\n  if (utils_gel('compliance_toggle').checked) {\n    injectComplianceSettings();\n  } else {\n    removeComplianceSettings();\n  }\n\n  return intentPayload;\n};\n\nconst setIntentPayload = payload => {\n  intentPayload = payload;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/email.js\n\n\n\n// To autofill the email in idlookup field\nfunction emailSetter(email) {\n  if (email) {\n    const em = utils_gel('emailInput');\n    em.value = email;\n\n    autoIdLookupEmailAddress(email);\n    autoFillEmailAddressInCheckoutApirequest(email);\n  }\n}\n\nfunction setHistoricalEmails() {\n  let emailHistorical = localStorage.getItem('email_historical');\n\n  if (emailHistorical) {\n    const history = utils_gel('email_historical');\n    emailHistorical = JSON.parse(emailHistorical);\n\n    // remove existing node\n    qsa('#email_historical option').forEach(node => {\n      node.parentNode.removeChild(node);\n    });\n\n    for (let i=0; i<emailHistorical.length; i++) {\n      let option = cel('option');\n      option.value = emailHistorical[i];\n      option.className = 'historical_email_option';\n      option.appendChild(document.createTextNode(emailHistorical[i]));\n\n      history.appendChild(option);\n    }\n  }\n}\n\n// update email in idLookup payload\nfunction autoIdLookupEmailAddress(email) {\n  let emailHistorical;\n\n  if (userInfo) {\n    userInfo.identityValue = email;\n    localStorage.setItem('email', email);\n\n    emailHistorical = localStorage.getItem('email_historical');\n\n    if (!emailHistorical) {\n      emailHistorical = [];\n    } else {\n      emailHistorical = JSON.parse(emailHistorical);\n    }\n\n    if (emailHistorical.indexOf(email) < 0) {\n      emailHistorical.push(email);\n      localStorage.setItem('email_historical', JSON.stringify(emailHistorical));\n      setHistoricalEmails();\n    }\n  }\n}\n\n// To autofill the email in checkout field\nfunction autoFillEmailAddressInCheckoutApirequest(email) {\n  const intentPayload = data_getIntentPayload();\n  \n  if (intentPayload) {\n    intentPayload.consumer.emailAddress = emailInput.value;\n    intentPayload.consumer.consumerIdentity.identityValue = emailInput.value;\n    intentPayload.consumer.mobileNumber.phoneNumber = '4153334444';\n  }\n}\n\n\nconst setEmailErrorMessage = (msg) => {\n  gel('email_error_message').innerHTML = msg;\n}\n\n// bootstrap\nutils_gel('emailInput').onblur = function populateEmail() {\n  const email = this.value;\n  emailSetter(email);\n}\nutils_gel('emailInput').onfocus = () => {\n  utils_gel('email_error_message').innerHTML = '';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/stubs/environment-keys.js\nconst environmentKeys = {\n  'QaPerf': {\n    srcInitiatorId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    panEncryptionId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'QaPerf_DockerEE': {\n    srcInitiatorId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    panEncryptionId: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'DEVWKSPCE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'QAWKSPCE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  \n  'Vbox444_Container': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  'Vbox671': {\n    srcInitiatorId: 'SWOEJX022ZPXXQD3S8YN11FD4oyBr5InbFWGnFxrFGXUDjN6I',\n    panEncryptionId: 'IPW4W1DX5D4N5E8LMAC6115la44Nu9zYob_bgrg5EUMksbgT4',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox28': {\n    srcInitiatorId: 'J6XDQQQZ5CDSSJK0462Y11v-YWWFJ4O8G-3nTFwIIDwmqBLMM',\n    panEncryptionId: 'J6XDQQQZ5CDSSJK0462Y11v-YWWFJ4O8G-3nTFwIIDwmqBLMM',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox441': {\n    srcInitiatorId: '32V3GLT7MFPQJXXZCOTD119LoKEpmlgPaIAiSeMJFQQ9mUg-4',\n    panEncryptionId: '32V3GLT7MFPQJXXZCOTD119LoKEpmlgPaIAiSeMJFQQ9mUg-4',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox442_Adyen': {\n    srcInitiatorId: '8YPW4SHDFX5VLZ8MLHDB218WlvAwM4z2Pg1r_DpZY8lNaibec',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox442': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_ExternalSrci': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_Adyen': {\n    srcInitiatorId: '8YPW4SHDFX5VLZ8MLHDB218WlvAwM4z2Pg1r_DpZY8lNaibec',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_PSP': {\n    srcInitiatorId: 'TC03UO784YYUIR3BANUG11WE2pQEWgr5PpuIVbUZFB_oZLOco',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox444_3DS': {\n    srcInitiatorId: '8YPW4SHDFX5VLZ8MLHDB218WlvAwM4z2Pg1r_DpZY8lNaibec',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: 'ab1a4e6f-956c-a793-721f-133336dc270'\n  },\n  'Vbox734': {\n    srcInitiatorId: 'KXL3FF1JNNZU0ORB0CDD11TQ5wPxPqdUH4c4k8PFKp7gFOzm8',\n    panEncryptionId: 'SYZ0E01PYHJ4ZSXYU8FH11c8IkQyrrwgHsh3rWjAFhOc1J-lE',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox734_PSP': {\n    srcInitiatorId: 'K02YEQRO0LLJBLK6XD0G11vP2Z_PwMKGR4qSeJW8TCQhJUdbk',\n    panEncryptionId: 'SYZ0E01PYHJ4ZSXYU8FH11c8IkQyrrwgHsh3rWjAFhOc1J-lE',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Vbox462': {\n    srcInitiatorId: 'IBZOZYMVSY9JYT6WJVL7111CUWmhc5egkwGjHgBD_kQto66S8',\n    panEncryptionId: 'IBZOZYMVSY9JYT6WJVL7111CUWmhc5egkwGjHgBD_kQto66S8',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'QAINT': {\n    srcInitiatorId: 'D257GCAOR3JGPTGACON811hN5odBtBaW0Z18OnXh3bhwFuH18',\n    panEncryptionId: 'D257GCAOR3JGPTGACON811hN5odBtBaW0Z18OnXh3bhwFuH18',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT': {\n    srcInitiatorId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    panEncryptionId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT_OCC': {\n    srcInitiatorId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    panEncryptionId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT_OCE': {\n    srcInitiatorId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    panEncryptionId: '3WQRGUSY6CESJS2KQSW811JXx9P1JLs2DrbOKqU9EXbfjreUo',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'CERT1': {\n    srcInitiatorId: 'B8VF3G544MK90PMQAG3I11nR-eWQmj3uhfs9dQXPEdjbmrpfo',\n    panEncryptionId: 'L9A8ACW4DCTK83U2T4SB11NhQpVkp7mAh9NtnN5ms0wYu7wo0',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'SandBox': {\n    srcInitiatorId: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM',\n    panEncryptionId: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM',\n    srciDpaId: 'matestdpa2',\n    srcDpaId: ''\n  },\n  'Vbox444_Container_DockerEE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: ''\n  },\n  'Qa_OpenShift': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  },\n  'Qa_DockerEE': {\n    srcInitiatorId: '3EY722QTUPZCY5X5A3IY21OLy4te0ZTO9KB3PJMW9ugdQ3ZAQ',\n    panEncryptionId: 'J5C09XBZA6G891K4FGG611NiZViO3l905GPqA088DCEBKklZk',\n    srciDpaId: 'DPAID',\n    srcDpaId: '07750595-fcc1-0d2e-7388-11c5769e0201'\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-keys.ts\n\n\nvar getFromLocalStorage = function (key) {\n    var values = localStorage.getItem(key);\n    if (values) {\n        return JSON.parse(values);\n    }\n    return {};\n};\nvar getEnvironmentKeys = function () {\n    return getFromLocalStorage('environmentKeys');\n};\nvar getEncryptionKeys = function () {\n    return getFromLocalStorage('keys');\n};\nvar getEnvironment = function (key) {\n    var envKeys = (environmentKeys) ? environmentKeys : getEnvironmentKeys();\n    var genericKey = key.replace(/SDKv[0-9].*$/i, '').trim();\n    if (envKeys[genericKey]) {\n        return envKeys[genericKey];\n    }\n    return null;\n};\nvar getMerchantApiKey = function () {\n    if (initData.srcInitiatorId)\n        return initData.srcInitiatorId;\n    return null;\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/generate-sdk-list.js\n\n\nconst envs = {\n  // \"--- Pick\": \"\",\n  QaPerf_DockerEE: \"https://src-qaperfb.k8s-np-cls1-p.trusted.visa.com\",\n  QAWKSPCE: \"https://b2cp-vco-qab.oce-np-sm-ddp-p-en.trusted.visa.com\",\n  DEVWKSPCE: 'https://b2cp-vco-devwkspceb.oce-np-sm-ddp-p-en.trusted.visa.com', // DockerEE\n  SandBox: \"https://sandbox.secure.checkout.visa.com\",\n\n  CERT: \"https://cert.secure.checkout.visa.com\",\n  CERT_OCC: \"https://occ-cert.secure.checkout.visa.com\",\n  CERT_OCE: \"https://oce-cert.secure.checkout.visa.com\",\n  // QaPerf: \"https://perf.qa.secure.checkout.visa.com\",\n  // CERT1: \"https://cert1.secure.checkout.visa.com\",\n  // ICL: \"https://demo.icl.visa.com\",\n  // QAINT: \"https://int.qa.secure.checkout.visa.com\",\n  Vbox444_ExternalSrci: \"https://vbox444.secure.checkout.visa.com\",\n};\n\n\nconst buildSdkPicker = () => {\n  const sdkSelector_v2_integrated = utils_gel('sdk_picker_v3');\n  const storedSdk = localStorage.getItem('sdk');\n\n  for (let k in envs) {\n    const option_v3 = cel('option');\n    option_v3.setAttribute('value', `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visaSdk.js?v2`)\n    option_v3.innerHTML = `${k} INTEGRATED`;\n    option_v3.selected = storedSdk === `${envs[k]}/checkout-widget/resources/js/src-i-adapter/visaSdk.js?v2`;\n    sdkSelector_v2_integrated.appendChild(option_v3);\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/can-use-test-cards-api.js\nconst canUseTestCardApi = () => {\n  switch (window.location.hostname) {\n    // case 'localhost':\n    case 'cnojima.github.io':\n      return false;\n  }\n\n  return true;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/components/card-bin-selector/index.js\n\n\n\nconst defaultBin = '414718';\nconst bins = {\n  '-- 400552 (non-tokenizable?)': '400552',\n  '-- 420767 (tokenizable)': '420767',\n  '-- 414718 (tokenizable)': '414718'\n};\n\nconst handleBinSelection = e => {\n  localStorage.setItem('binRange', e.target.value);\n}\n\nconst initBinSelector = () => {\n  const binRange = localStorage.getItem('binRange');\n  const select = utils_gel('bin_range');\n\n  for (let k in bins) {\n    const option = document.createElement('option');\n    option.value = bins[k];\n    option.label = k;\n\n    if (binRange && binRange === bins[k]) {\n      option.selected = true;\n    } else if (!binRange && bins[k] === defaultBin) {\n      option.selected = true;\n    }\n\n    select.appendChild(option);\n  }\n\n  select.addEventListener('change', handleBinSelection);\n\n  if (canUseTestCardApi()) {\n    utils_gel('bin_selector').style.display = 'block';\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/uuid.js\n\n\n\n// Method to generate random UUID\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n// To autofill UUID on every page refresh\nfunction autoFillUUID(key) {\n  const intentPayload = data_getIntentPayload();\n  const srciTransactionId = uuidv4();\n  const env = getEnvironment(key);\n  data_initData.srciTransactionId = srciTransactionId;\n  intentPayload.srciTransactionId = srciTransactionId;\n\n  const bad = ['srcDpaId', 'panEncryptionId'];\n  for (let k in env) {\n    if (bad.indexOf(k) === -1)\n      data_initData[k] = env[k];\n  }\n}\n\nconst autoFillUUIDAutomation = () => {\n  const intentPayload = getIntentPayload();\n  const srciTransactionId = uuidv4();\n  let dpaId = localStorage.getItem('srciDpaId');\n\n  if (!dpaId) {\n    console.warn(' --- srcDpaId not set - using default DPAID');\n    dpaId = 'DPAID';\n  }\n\n  initData.srciTransactionId = srciTransactionId;\n  intentPayload.srciTransactionId = srciTransactionId;\n  initData['srcInitiatorId'] = localStorage.getItem('initiatorId');\n  initData['srciDpaId'] = dpaId;\n\n  delete initData['apikey'];\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/reset-ui.js\n\n\n\n\n\nconst targets = [\n  'init_complete', 'is_recognized_complete', 'auth_complete', 'get_src_profile_complete', 'checkout_complete', 'unbind_complete'\n];\n\nconst resetUi = () => {\n  window.otp_listener = false;\n\n  targets.forEach(id => {\n    utils_gel(id).checked = false;\n    utils_gel(`${id}_timing`).innerHTML = '';\n  });\n\n  Array(qsa('.messaging')).forEach(el => {\n    el.innerHTML = '';\n  });\n\n  utils_gel('auth_breakdown').innerHTML = '';\n  utils_gel('error_log').innerHTML = '';\n  utils_gel('benchmark_data').value = '';\n  utils_gel('otp_entry').style.display = 'none';\n  utils_gel('pass_fail').innerHTML = '';\n  utils_gel('pass_fail').classList.remove('pass', 'fail');\n\n  for (let k in benchmark) {\n    benchmark[k] = 0;\n  }\n\n  // BIN selector\n  if (canUseTestCardApi()) {\n    utils_gel('bin_selector').style.display = 'block';\n  }\n\n  // compliance cb\n  if (utils_gel('compliance_toggle').checked) {\n    console.log('...injectComplianceSettings');\n    injectComplianceSettings();\n  } else {\n    console.log('...removeComplianceSettings');\n    removeComplianceSettings();\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/validate-start-options.ts\n\n\nvar validate = function () {\n    // manual, don't use helpers here\n    var flowType = qs('input[name=\"flow_selector\"]:checked');\n    if (!flowType) {\n        catchErr('Select a Flow to start.');\n        return false;\n    }\n    // edge-cases, no localStorage values set\n    var sdkUrl = utils_gel('sdk_picker_v3');\n    var email = utils_gel('emailInput');\n    var returningFlow = utils_gel('returning_flow');\n    var panJson = utils_gel('pan_json');\n    if (!localStorage.getItem('sdk') && sdkUrl) {\n        localStorage.setItem('sdk', sdkUrl.value);\n    }\n    if (!localStorage.getItem('email') && email) {\n        if (email) {\n            localStorage.setItem('email', email.value);\n        }\n    }\n    if (returningFlow.checked === false &&\n        !canUseTestCardApi() && panJson.value === '') {\n        catchErr('Please generate a test card before proceeding.');\n        return false;\n    }\n    return true;\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/async/init.js\n\n\n\n\n\nasync function init(adapter, startTime) {\n  console.log('[INIT] start');\n  // const apikey = getMerchantApiKey();\n  // if (apikey) {\n  //   initData.apikey = apikey;\n  // }\n\n  console.log('[INIT_DATA]', data_initData);\n\n  await adapter.init(data_initData).then((response) => {\n    const endTime = Date.now();\n    benchmark.init = endTime - startTime;\n    console.log(`[init] ttaken: ${(benchmark.init)}ms`, response);\n\n    if (!Object.keys(response).length) {\n      utils_gel('init_complete').checked = true;\n      utils_gel('init_complete_timing').innerHTML = `${(benchmark.init)}ms`;\n    } else if (response.error) {\n      setPassFail('FAIL');\n      throw new Error(JSON.stringify(response, null, 2));\n    } else {\n      console.error('init failed, check console');\n    }\n\n    return response;\n  }).catch(catchErr);\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/is-recognized.js\n\n\n\n\n\nasync function isRecognized(adapter) {\n  console.log('[RECOGNIZE] start');\n  const startTime = Date.now();\n\n  let token;\n  const response = await adapter.isRecognized().catch(catchErr);\n  const endTime = Date.now();\n\n  benchmark.isRecognized = endTime - startTime;\n\n  utils_gel('is_recognized_complete').checked = true;\n  utils_gel('is_recognized_complete_timing').innerHTML = `${benchmark.isRecognized}ms`;\n\n  if (response.idTokens) {\n    token = response.idTokens[0];\n  } else if (response.recognized === false) {\n    utils_gel('is_recognized_complete_timing').innerHTML = `${benchmark.isRecognized}ms (unrecognized)`;\n  } else if (response.error) {\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(response, null, 2));\n  }\n\n  console.log(`[recognized] ttaken: ${(benchmark.isRecognized)}ms`);\n  return token;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-root-domain.js\n/*\n  cannot import util from visa-sdk; copied util over for now\n*/\n\n\n// This dummy URL is updated by a deploy script based on the environment. E.g.\n// when deploying to production, CI replaces dev.www.v.me with\n// secure.checkout.visa.com, but when deploying to cert, it will be\n// cert.secure.checkout.visa.com.\nconst STATIC_ROOT_DOMAIN = 'https://dev.www.v.me';\n\nconst sdkScriptRegex =\n  /^https:\\/\\/[\\w-\\.]+\\.?\\.visa\\.com\\/checkout\\-widget\\/resources\\/js\\/src-i-adapter\\/visa[\\-sS]{1,2}dk\\.js/;\n\nfunction getSDKScriptEl() {\n  const scripts = document.querySelectorAll('script');\n\n  for (const script of scripts) {\n    if (script.src.match(sdkScriptRegex)) {\n      return script;\n    }\n  }\n\n  return null;\n}\n\nconst assetsMap = {\n  '//assets.secure.checkout.visa.com': '//secure.checkout.visa.com',\n  '//cert-assets.secure.checkout.visa.com': '//cert.secure.checkout.visa.com',\n  '//sandbox-assets.secure.checkout.visa.com': '//sandbox.secure.checkout.visa.com'\n};\n\nfunction mapAssetsUrl(url) {\n  const assetDomains = Object.keys(assetsMap);\n\n  for (const assetDomain of assetDomains) {\n    if (url.indexOf(assetDomain) !== -1) {\n      return url.replace(assetDomain, assetsMap[assetDomain]);\n    }\n  }\n\n  return url;\n}\n\n// Root domain is updated by a deploy script based on the environment. E.g.\n// when deploying to production, CI replaces dev.www.v.me with\n// secure.checkout.visa.com, but when deploying to cert, CI uses\n// cert.secure.checkout.visa.com.\nconst dummyUrlHash = 'aHR0cHM6Ly9kZXYud3d3LnYubWU'; // btoa('https://dev.www.v.me')\nconst wasDummyUrlReplaced = STATIC_ROOT_DOMAIN !== window.atob(dummyUrlHash);\n\nfunction getRootDomain() {\n  if (wasDummyUrlReplaced) {\n    return STATIC_ROOT_DOMAIN;\n  }\n\n  // In container deployments, the dummy url may not have been replaced. In this\n  // case we need to determine the environment url from the visaSdk.js script tag.\n\n  const sdkScriptEl = getSDKScriptEl();\n\n  if (sdkScriptEl) {\n    return mapAssetsUrl(sdkScriptEl.src.split('/', 3).join('/'));\n  }\n\n  // Default to the prod URL for any abnormal integration.\n  return 'https://secure.checkout.visa.com';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/load-sdk.js\n\n\n\nconst loadSdk = (sdkUrl, callback) => {\n  const loadStart = Date.now();\n  let sdkMount = getSDKScriptEl();\n  let tag;\n\n  if (sdkMount) {\n    console.info('>>>> removing <script /> tag from prior load');\n    sdkMount.parentNode.removeChild(sdkMount);\n  }\n\n  tag = document.createElement(\"script\");\n  tag.src = sdkUrl;\n  tag.type = 'text/javascript';\n  tag.async = false;\n  tag.onload = () => {\n    callback(loadStart).catch(err => {\n      utils_gel('error_log').innerHTML = err;\n    });\n  }\n\n  const head = document.getElementsByTagName(\"head\")[0];\n  (head || document.body).appendChild(tag);\n}\n\n/* harmony default export */ const load_sdk = (loadSdk);\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/update-benchmarks.js\n\n\n\nlet startTime;\n\nconst setStartTime = () => startTime = Date.now();\n\nconst updateBenchmarks = () => utils_gel('benchmark_data').value = JSON.stringify(benchmark, null, 2);\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/fetch.js\nconst genId = () => Math.random().toString(36).substring(7);\nconst systemCorrelationId = `1_1492561111_766_48_${genId()}_CHECKOUT-WIDGET`;\nconst systemSessionId = `vme_qa_001${genId()}`;\n\nvar fetchReq = function (options) {\n  const {\n    url,\n    body,\n    method,\n    headers\n  } = options;\n  headers['X-CORRELATION-ID'] = systemCorrelationId;\n  headers['dfpSessionId'] = systemSessionId;\n  headers['X-THMID'] = systemSessionId;\n\n  const contentType = headers['Content-Type'];\n  let finalBody = {};\n\n  if (contentType && contentType.includes('x-www-form-urlencoded')) {\n    finalBody = fetch_serializeObject(body);\n  } else {\n    finalBody = JSON.stringify(body);\n  }\n  return fetch(\n      url,\n      Object.assign({}, {\n        body: finalBody,\n        credentials: 'same-origin',\n        headers: headers,\n        method\n      })\n    )\n    .then(res => handleJsonResponse(res))\n    .then(data => data)\n    .catch(error => {return error});\n};\n\nfunction fetch_uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nfunction handleJsonResponse(res) {\n  const headers = {};\n  res.headers.forEach(function (v, k) {\n    headers[k] = v;\n  });\n  // console.log('headers - ' + JSON.stringify(headers));\n  return (\n    res\n    .json()\n    .then(function (data) {\n      console.log('data', data);\n      return {\n        data: data,\n        headers: headers\n      }\n    })\n    .catch(function () {\n      return {\n        headers: headers\n      }\n    }))\n};\n\n\nfunction fetch_serializeObject(obj) {\n  if (!obj) {\n    return '';\n  }\n\n  var s = [];\n\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && obj[key].constructor === Array) {\n      obj[key].forEach(function (value) {\n        s.push(key + '=' + encodeURIComponent(value));\n      });\n    } else {\n      s.push(key + '=' + encodeURIComponent(obj[key]));\n    }\n  });\n\n  return s.join('&');\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-otp.js\n\n\n\n\n\nlet isQAPerf = false;\nconst useProxy = true;\n\nasync function getOTP(email) {\n  console.info('@getOTP - attempting to retrieve OTP code via API');\n\n  isQAPerf = localStorage.getItem('sdk').indexOf('qaperf') > -1;\n\n  if (isQAPerf) {\n    const res = await fetch(`/id?email=${email}`).then(handleJsonResponse);\n\n    if (res.data.uuid) {\n      // sha256 hash of UUID + email\n      // no transpile of node code, leverage simple API\n      const hash = await fetch(`/sha?s=${res.data.uuid}${email.toLowerCase()}`).then(handleJsonResponse);\n      // base64 encode shasum\n      try {\n        const encrypted = btoa(hash.data.sha256);\n        const otpBody = await fetch(`/otp?encrypted=${encrypted}`).then(handleJsonResponse);\n// console.log('otp', otpBody);Q\n\n        if (otpBody.data.otpValue) {\n          console.log(`got OTP value [${otpBody.data.otpValue}]`);\n          return otpBody.data.otpValue;\n        }\n      } catch (err) {\n        setPassFail('FAIL');\n        throw new Error(err);\n      }\n\n      setPassFail('FAIL');\n      throw new Error(`OTP fetch failed`);\n    }\n  } else {\n    let token;\n    const proxy = `${window.location.protocol}//${window.location.hostname}:${window.location.port}/proxy`;\n    const url = 'https://vbox671.secure.checkout.visa.com/srcsdktester/generateOtp';\n  \n    const environment = extractHostname(benchmarkState.sdkUrl);\n    // console.log(\"Environment:\", environment);\n  \n    // Make indirect call to get OTP\n    const options = {\n      method: 'GET',\n      url: useProxy ? `${proxy}?url=${url}` : url,\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json; charset=UTF-8',\n        'envn': environment,\n        'email': email,\n      }\n    };\n\n    const result = await fetchReq(options).catch(err => {\n      console.error('getOTP error:', err);\n    });\n    if (result.data.otpValue) {\n      return result.data.otpValue;\n    } else {\n      console.warn(`could not autoget OTP code from [${url}]`);\n    }\n  }\n\n  return null;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/can-use-otp-api.js\n\nconst canUseOtpApi = () => {\n  const hostname = window.location.hostname;\n  const sdkUrl = localStorage.getItem('sdk');\n\n  switch(true) {\n    case (hostname.indexOf('github') > -1):\n    case (hostname.indexOf('heroku') > -1):\n    case (sdkUrl && sdkUrl.indexOf('qaperf') > -1):\n    case (hostname.indexOf('localhost') > -1):\n    case (hostname.indexOf('127.0.0.1') > -1):\n      return false;\n  }\n\n  return true;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/auth-flow.js\n\n\n\n\n\n\n\nlet auth_flow_isQAPerf;\n\nwindow.otp_listener = false;\n\n\n\nasync function submitOtp(otpCode) {\n  console.info('---- submitOtp');\n  const completeIdentityValidationStart = Date.now();\n  const res = await completeIdentityValidation(window.c2p_adapter, {\n    validationData: otpCode\n  }).catch(catchErr);\n  benchmark.completeIdentityValidation = Date.now() - completeIdentityValidationStart;\n\n  utils_gel('auth_complete').checked = true;\n  utils_gel('auth_complete_timing').innerHTML = `${(benchmark.identityLookup + benchmark.initiateIdentityValidation + benchmark.completeIdentityValidation) / 1000}s`;\n  utils_gel('auth_breakdown').innerHTML = `[ identityLookup: ${benchmark.identityLookup}ms ]<br/>[ initiateIdentityValidation: ${benchmark.initiateIdentityValidation}ms ]<br/>[ completeIdentityValidation: ${benchmark.completeIdentityValidation}ms ]`;\n\n  console.log(`/probe`, res);\n  return res;\n}\n\nasync function completeIdentityValidation(adapter, code) {\n  console.log(\"@completeIdentityValidation - Validation Data => \", code);\n  const response = await adapter.completeIdentityValidation(code).catch(catchErr);\n  console.log(`---- completeIdentityValidation - response`, response);\n\n  if (response.error) {\n    return null;\n  } else if (response['reason']) {\n    console.log('Unable to verify OTP: %o', response);\n  } else {\n    console.log('Response from Verify OTP: %o', response);\n  }\n  return response;\n}\n\nasync function initiateIdentityValidation(adapter) {\n  console.log('@initiateIdentityValidation');\n  return await adapter.initiateIdentityValidation().then((response) => {\n    console.log(`response from initiateIdentyValidation`, response);\n    if (response['reason']) {\n      setPassFail('FAIL');\n      throw new Error('Unable to initialize Identity validation, error: %o', response);\n    }\n    return response;\n  }).catch(catchErr);\n}\n\n\n\nasync function authFlow(afterAuth, updateBenchmarks) {\n  console.log('[AUTH_FLOW] start');\n  let otpCode;\n  const email = localStorage.getItem('email');\n\n  // idLookup\n  const identityLookupStart = Date.now();\n\n  console.log('-- starting async identityLookup');\n  const res = await window.c2p_adapter.identityLookup({\n    identityProvider: \"SRC\",\n    identityValue: email,\n    type: \"EMAIL\"\n  }).catch(catchErr);\n  console.log('-- identityLookup return', res);\n\n  benchmark.identityLookup = Date.now() - identityLookupStart;\n  updateBenchmarks();\n\n  if (res.error) {\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(res, null, 2));\n  } else if (res.consumerPresent || res.accessToken) {\n    // reissuance\n    console.log('--- reissuance');\n    const initiateIdentityValidationStart = Date.now();\n    const res = await initiateIdentityValidation(window.c2p_adapter).catch(catchErr);\n    benchmark.initiateIdentityValidation = Date.now() - initiateIdentityValidationStart;\n    benchmark.UIUX_to_OTP = Date.now() - startTime;\n    userInfo.OTP_performed = true;\n    updateBenchmarks();\n\n    if (res.error) {\n      setPassFail('FAIL');\n      throw new Error(JSON.stringify(res, null, 2));\n    } else if (res !== false) {\n      if (canUseOtpApi() === false) {\n        if (window.otp_listener === false) {\n          console.log('instantiating manual OTP form')\n          window.otp_listener = true;\n\n          async function handler(e) {\n            const otp = utils_gel('otp_value').value;\n            console.log(`OTP submitted [${otp}]`);\n\n            if (otp) {\n              const res = await submitOtp(otp).catch(catchErr);\n              updateBenchmarks();\n\n              if (res) {\n                // visa-sdk > 23.07.00 no longer returns idToken?\n                const token = res?.idToken || undefined;\n                await afterAuth(window.c2p_adapter, token).catch(catchErr);\n                // return res;\n              }\n            } else {\n              catchErr('No OTP value detected.')\n            }\n          };\n\n          const globalHandler = async e => {\n            if (e.srcElement.id === 'otp_submit') {\n              await handler(e);\n            }\n          }\n\n          // show OTP field + button\n          window._manual_otp = true;\n          utils_gel('otp_entry').style.display = 'block';\n          document.addEventListener('click', globalHandler);\n        }\n        return 'manual';\n      } else {\n        console.log('--- automatic OTP shown');\n        otpCode = await getOTP(email);\n\n        // manually enter for sandbox+\n        if (!otpCode) {\n          console.log('--- prompt OTP shown');\n          otpCode = await prompt('Enter OTP');\n        }\n        return submitOtp(otpCode);\n      }\n    }\n  }\n\n  console.info('[AUTH_FLOW] consumer not present');\n  return res;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/checkout.js\n\n\n\n\n\n\nasync function checkout(adapter) {\n  const intentPayload = data_getIntentPayload();\n  console.log('[CHECKOUT] start');\n  const email = utils_gel('emailInput').value;\n  autoFillEmailAddressInCheckoutApirequest(email);\n\n  console.log('-- intent payload', intentPayload);\n  const enrollStartTime = Date.now();\n  const response = await adapter.checkout(intentPayload);\n  const enrollEndTime = Date.now();\n\n  benchmark.checkout = enrollEndTime - enrollStartTime;\n\n  if (userInfo.cardList_performed === false && userInfo.OTP_performed === false) {\n    benchmark.UIUX_enrollNewUser = Date.now() - startTime;\n  }\n\n  console.log(`[checkout] ttaken: ${(benchmark.checkout)}ms`);\n  \n  if (response.error || response['reason']) {\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(response, null, 2));\n  } else {\n    utils_gel('checkout_complete').checked = true;\n    utils_gel('checkout_complete_timing').innerHTML = `${(benchmark.checkout)}ms`;\n  }\n  return response;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/get-src-profile.js\n\n\n\n\n\n\nasync function getSrcProfile(adapter, authToken) {\n  console.log('[GET_SRC_PROFILE] start');\n  const intentPayload = data_getIntentPayload();\n\n  const gspStartTime = Date.now();\n  const response = await adapter.getSrcProfile(authToken);\n  const gspEndTime = Date.now();\n  benchmark.getSrcProfile = gspEndTime - gspStartTime;\n  userInfo.cardList_performed = true;\n\n  if (userInfo.OTP_performed === false) {\n    // only mark TTFI for CL if OTP has not been sent/submitted\n    benchmark.UIUX_to_cardList = Date.now() - startTime;\n  }\n  console.log(`[getSrcProfile] ttaken: ${(benchmark.getSrcProfile)}ms`);\n\n  if (response.error) {\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(response, null, 2));\n  } else if (response['reason']) {\n    console.warn('Unable to get card list: %o', response);\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(response, null, 2));\n  } else {\n    utils_gel('get_src_profile_complete').checked = true;\n    utils_gel('get_src_profile_complete_timing').innerHTML = `${(benchmark.getSrcProfile)}ms`;\n  }\n\n  response.profiles.forEach(profile => srcProfiles.push(profile));\n\n  // set first card\n  try {\n    intentPayload.srcDigitalCardId = srcProfiles[0].maskedCards[0].srcDigitalCardId;\n  } catch (ex) {\n    console.warn('SRC Profile contained no cards');\n    // throw new Error('profile masked card missing srcDigitalCardId', JSON.stringify(srcProfiles, null, 2));\n  }\n  intentPayload.idToken = srcProfiles[0].idToken;\n  intentPayload.srcCorrelationId = response.srcCorrelationId;\n  intentPayload.profiles = srcProfiles;\n\n  return response;\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/async/unbind.js\n\n\n\n\n\nconst unbind = async (adapter, token) => {\n  if (token) {\n    console.log('[UNBIND]');\n    const start = Date.now();\n    const response = await adapter.unbindAppInstance({});\n    const end = Date.now();\n\n    benchmark.unbind = end - start;\n\n    if (response.error) {\n      setPassFail('FAIL');\n      throw new Error(JSON.stringify(response, null, 2));\n    } else {\n      utils_gel('unbind_complete').checked = true;\n      utils_gel('unbind_complete_timing').innerHTML = `${benchmark.unbind}ms`;\n\n      console.log('Unbind result received from Visa SRC System');\n//      console.log('Response Data', JSON.stringify(response));\n    }\n    updateBenchmarks();\n    return response;\n  }\n\n  return;\n}\n\n// EXTERNAL MODULE: ./benchmark/js/jose/visa-encrypt.js\nvar visa_encrypt = __webpack_require__(1);\n;// CONCATENATED MODULE: ./benchmark/js/stubs/pan-encryption-keys.js\nconst keys = {\n  sandbox: {\n    // kid: \"1bdab3cc\",\n    kid: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM', // APIkey/srcInitiatorId\n    publicKey: {\n      e: 65537,\n      n: \"00:b1:93:c8:ba:c0:df:ef:24:27:9e:10:64:53:d9:ae:d7:85:4e:3b:70:ab:ba:2d:db:ee:b0:1f:d8:a6:1e:a1:b5:11:99:70:35:ed:bd:49:5f:d8:e0:d0:27:7e:be:0a:66:bb:24:eb:c4:15:12:73:ee:1b:d3:e5:0f:81:2c:06:16:a3:d6:52:9c:74:f0:4c:6a:af:03:c3:3a:f1:68:8c:1a:2e:db:09:72:ab:c6:dc:cb:45:2c:f8:17:de:0b:34:84:e6:53:15:75:25:d3:5d:75:dc:36:ab:be:a9:bd:b6:8c:20:82:24:02:e9:c6:c0:2b:b1:ba:0c:39:7b:0b:79:d8:77:33:85:cd:43:95:c6:02:d4:5f:ed:bf:be:b9:36:39:0e:bf:4a:2d:8c:94:bd:92:80:9d:8d:38:30:a2:4f:10:ee:78:62:22:05:33:90:d3:02:13:4e:9a:cd:3c:f6:37:4c:77:1f:94:44:82:89:8c:f5:36:f9:1a:47:1b:5b:bc:2c:21:b4:db:c4:53:22:93:ec:35:b4:5a:9e:e4:b9:4c:06:3f:ce:5c:43:81:bd:61:28:9d:fa:61:b6:44:34:72:e0:f4:f5:d3:06:17:4e:32:55:3d:d0:34:cb:95:f7:1b:2d:36:be:0f:b0:e0:96:30:1a:58:2b:af:cc:b3:da:1b\"\n    }\n  },\n  qa_perf: {\n    // kid: 'a74e23ee',\n    // kid: 'UBHBN6UGSOK1XYQTZPNU11yrza5YNoasOQ2Aolmal9BqU3GK4',\n    // kid: '7HKFOSV9G52FPO4VGB9211lO1Y3E5OP_TufMQmyCjWJKy1N64',\n    // kid: 'FFK8WJ6YIKY70NCAQTKZ11uW71NHdKODq9DlKX5SYpSM63xAY',\n    kid: 'L6MLA3P263NC8AFUJGW411x9qo7NVCUjL92sElZ3vdIlsSny0',\n    publicKey: {\n      e: 65537,\n      // n: 'cf:c4:da:e6:c5:f2:57:44:e3:32:91:e3:18:a1:87:fd:3b:be:f2:aa:67:d4:13:7c:cd:56:ba:11:fb:8f:67:78:24:cf:c0:65:54:32:8a:ad:d6:11:9e:3a:f3:39:1d:fd:c1:9c:34:45:62:e8:cb:24:62:df:8a:5e:ff:b2:f6:8a:3a:5c:66:3f:bd:5e:a9:1d:73:56:8f:bf:d7:10:ce:9b:0f:3f:7a:cf:4d:18:b0:0f:9b:cd:29:c6:6a:06:fc:37:0a:f7:bd:49:7d:f1:b7:8e:7f:aa:9d:17:69:1f:ff:b5:cd:a6:26:48:40:03:ba:54:7a:54:44:02:55:a4:f5:ad:25:95:02:76:45:e0:82:35:70:0e:49:71:f3:71:71:c9:14:79:7d:ae:1a:ef:99:c9:d1:86:9b:20:11:0e:6a:eb:7a:64:ca:fc:a2:69:ae:fa:bd:e6:b0:dd:96:03:f2:e1:c5:a0:c4:bf:a9:7c:41:c5:c6:9b:10:8f:e8:86:08:7f:3f:1d:69:ee:78:3f:fc:52:ac:5c:a2:51:76:4b:38:6e:39:80:7f:b9:24:67:63:9e:e9:e6:89:96:39:08:ff:2b:11:15:0e:f7:e1:e8:c7:ed:a0:a3:2b:02:71:6b:05:d8:fc:85:5a:e8:c3:4a:3e:0b:83:04:4a:65:ee:23:4e:a7'\n      // n: '00c6ec2af74e96d0890d3a50cfbb8050544f86059c525df7c583103a7e1339d8dbac81dd0650f83fa3e68b1f1c677e10db87f71222dac33817709edb0d1c4acdfbb2cb1d9d67484e91f6688ae9c3f78c4f58a8062ca533f88ac39dc883222ace89776e1cbb8ed139b96d0c3e7a3a4e530bbb0220e72d092410eaf0951e0094fc822898182f5ae983bf44cb136fc3b3bb9b95fdc48f66812b135c5e9d1605ef99634ac12b9908c2c5dc2eba5c2a73e77f0032b595aa36c536ae74a13a6171eb0ccf76314aed66dda6b1c9f692b8b92bee250e9114c93d169b9cac1ad10ca2d1b79371d3ddf4a698a2b40217e43cc4285cbfe9de8d1e9c20b14cb6a37129f92f7e4d',\n      n: '00:c6:ec:2a:f7:4e:96:d0:89:0d:3a:50:cf:bb:80:50:54:4f:86:05:9c:52:5d:f7:c5:83:10:3a:7e:13:39:d8:db:ac:81:dd:06:50:f8:3f:a3:e6:8b:1f:1c:67:7e:10:db:87:f7:12:22:da:c3:38:17:70:9e:db:0d:1c:4a:cd:fb:b2:cb:1d:9d:67:48:4e:91:f6:68:8a:e9:c3:f7:8c:4f:58:a8:06:2c:a5:33:f8:8a:c3:9d:c8:83:22:2a:ce:89:77:6e:1c:bb:8e:d1:39:b9:6d:0c:3e:7a:3a:4e:53:0b:bb:02:20:e7:2d:09:24:10:ea:f0:95:1e:00:94:fc:82:28:98:18:2f:5a:e9:83:bf:44:cb:13:6f:c3:b3:bb:9b:95:fd:c4:8f:66:81:2b:13:5c:5e:9d:16:05:ef:99:63:4a:c1:2b:99:08:c2:c5:dc:2e:ba:5c:2a:73:e7:7f:00:32:b5:95:aa:36:c5:36:ae:74:a1:3a:61:71:eb:0c:cf:76:31:4a:ed:66:dd:a6:b1:c9:f6:92:b8:b9:2b:ee:25:0e:91:14:c9:3d:16:9b:9c:ac:1a:d1:0c:a2:d1:b7:93:71:d3:dd:f4:a6:98:a2:b4:02:17:e4:3c:c4:28:5c:bf:e9:de:8d:1e:9c:20:b1:4c:b6:a3:71:29:f9:2f:7e:4d'\n    }\n  },\n  qa_perf_OLD: {\n    // kid: 'a74e23ee',\n    kid: 'UBHBN6UGSOK1XYQTZPNU11yrza5YNoasOQ2Aolmal9BqU3GK4',\n    publicKey: {\n      e: 0x010001,\n      n: 'cfc4dae6c5f25744e33291e318a187fd3bbef2aa67d4137ccd56ba11fb8f677824cfc06554328aadd6119e3af3391dfdc19c344562e8cb2462df8a5effb2f68a3a5c663fbd5ea91d73568fbfd710ce9b0f3f7acf4d18b00f9bcd29c66a06fc370af7bd497df1b78e7faa9d17691fffb5cda626484003ba547a54440255a4f5ad2595027645e08235700e4971f37171c914797dae1aef99c9d1869b20110e6aeb7a64cafca269aefabde6b0dd9603f2e1c5a0c4bfa97c41c5c69b108fe886087f3f1d69ee783ffc52ac5ca251764b386e39807fb92467639ee9e689963908ff2b11150ef7e1e8c7eda0a32b02716b05d8fc855ae8c34a3e0b83044a65ee234ea7'\n      //n: 'cf:c4:da:e6:c5:f2:57:44:e3:32:91:e3:18:a1:87:fd:3b:be:f2:aa:67:d4:13:7c:cd:56:ba:11:fb:8f:67:78:24:cf:c0:65:54:32:8a:ad:d6:11:9e:3a:f3:39:1d:fd:c1:9c:34:45:62:e8:cb:24:62:df:8a:5e:ff:b2:f6:8a:3a:5c:66:3f:bd:5e:a9:1d:73:56:8f:bf:d7:10:ce:9b:0f:3f:7a:cf:4d:18:b0:0f:9b:cd:29:c6:6a:06:fc:37:0a:f7:bd:49:7d:f1:b7:8e:7f:aa:9d:17:69:1f:ff:b5:cd:a6:26:48:40:03:ba:54:7a:54:44:02:55:a4:f5:ad:25:95:02:76:45:e0:82:35:70:0e:49:71:f3:71:71:c9:14:79:7d:ae:1a:ef:99:c9:d1:86:9b:20:11:0e:6a:eb:7a:64:ca:fc:a2:69:ae:fa:bd:e6:b0:dd:96:03:f2:e1:c5:a0:c4:bf:a9:7c:41:c5:c6:9b:10:8f:e8:86:08:7f:3f:1d:69:ee:78:3f:fc:52:ac:5c:a2:51:76:4b:38:6e:39:80:7f:b9:24:67:63:9e:e9:e6:89:96:39:08:ff:2b:11:15:0e:f7:e1:e8:c7:ed:a0:a3:2b:02:71:6b:05:d8:fc:85:5a:e8:c3:4a:3e:0b:83:04:4a:65:ee:23:4e:a7'\n    }\n  },\n  production: {\n    kid: \"JHA10LAKEFG0T7CIBS1O14Chn6lq3cdOxq-Wwqa62ZUwKvnm4\",\n    publicKey: {\n      e: 65537,\n      n: \"00:90:fb:a3:c1:52:63:7a:f2:3f:a1:e6:70:66:80:36:5a:3b:7d:e0:31:5c:32:f4:42:69:bf:22:46:21:06:ac:67:ca:5a:d3:42:c1:06:24:ca:5c:ae:46:80:7a:d7:97:18:9b:60:55:6e:fa:0a:1f:c6:32:bf:46:82:dd:dc:1a:87:a5:26:39:d2:6c:ce:62:f4:a5:5f:dc:6f:1f:ed:5f:35:a0:62:0d:ec:60:db:29:d2:c0:71:50:57:10:d4:0e:83:55:bc:8e:c7:12:5b:9a:7c:25:1c:61:39:7e:4b:b3:26:bf:aa:aa:e9:77:46:cc:2c:08:6f:af:3e:b8:7f:fb:ed:bf:45:28:a9:6b:d9:55:af:d8:2f:7c:8e:00:6c:50:01:2d:3a:8a:7a:da:34:ad:63:db:20:12:9d:85:c1:90:ec:93:0f:c7:3a:bc:db:7f:4a:3d:46:5f:4b:23:6e:78:07:1d:2f:ec:87:00:38:b7:2f:65:52:cd:d1:7b:b5:2e:ec:8b:7b:9e:fc:81:68:5c:3a:5b:82:0b:05:c6:f1:2d:ef:d5:25:04:33:81:b1:a8:1c:fe:6b:3d:fd:9b:18:94:96:8a:09:3f:19:8f:08:5a:90:ca:3f:f9:97:5c:f7:b9:ae:75:58:f5:8f:3d:bf:2f:99:78:97:fc:e2:6c:5e:6b:8b\"\n    }\n  },\n  development: {\n    kid: \"IPW4W1DX5D4N5E8LMAC6115la44Nu9zYob_bgrg5EUMksbgT4\",\n    publicKey: {\n      e: 65537,\n      n: \"00:ba:7e:ed:8a:98:e9:99:fb:bb:0d:d8:bf:b3:89:4c:13:74:93:67:0c:02:c9:e8:32:8d:42:2c:5a:fd:ac:cb:67:0e:c9:4b:2e:73:65:7a:1a:d2:45:6c:b8:28:d7:06:ac:1d:8b:0d:1b:88:96:22:35:c1:6f:5f:95:c7:09:0a:d5:fd:92:be:65:fc:36:14:ed:4a:60:5f:f3:bc:b9:20:a5:7e:cb:9c:35:c4:ef:09:26:78:3c:19:3e:d2:a2:9b:dd:b4:15:63:b2:a6:49:21:94:15:e4:37:d4:1e:e0:d9:f1:79:e7:01:a7:56:83:3b:37:59:be:9e:57:e8:9c:a8:84:2b:49:dd:5d:3d:04:37:fd:09:5f:59:93:20:f6:01:d2:d2:1a:57:1d:aa:6f:58:5c:ec:e2:df:77:ae:02:bf:9e:f3:bb:4e:e9:90:60:99:64:08:a4:84:71:c0:19:f0:ee:64:39:89:6d:bc:34:bf:03:f0:2e:69:8a:78:6d:20:9a:15:8f:64:b6:ee:5d:1a:4d:5b:2c:c9:87:a1:41:ee:92:f3:b4:56:24:35:73:53:e1:8c:4b:91:d6:f1:9f:31:6d:c8:a5:50:12:bf:d8:c1:a3:61:7f:4f:a5:6a:5b:98:91:94:68:bf:8f:49:5f:d5:e3:62:a1:a5:cc:98:7d:91:bb\"\n    }\n  },\n  cert: {\n    \"kid\": \"bb917d98\",\n    \"name\": \"qa-cbp-rsa-enc-csr-1\",\n    \"publicKey\": {\n      \"e\": 65537,\n      \"n\": \"00:ba:7e:ed:8a:98:e9:99:fb:bb:0d:d8:bf:b3:89:4c:13:74:93:67:0c:02:c9:e8:32:8d:42:2c:5a:fd:ac:cb:67:0e:c9:4b:2e:73:65:7a:1a:d2:45:6c:b8:28:d7:06:ac:1d:8b:0d:1b:88:96:22:35:c1:6f:5f:95:c7:09:0a:d5:fd:92:be:65:fc:36:14:ed:4a:60:5f:f3:bc:b9:20:a5:7e:cb:9c:35:c4:ef:09:26:78:3c:19:3e:d2:a2:9b:dd:b4:15:63:b2:a6:49:21:94:15:e4:37:d4:1e:e0:d9:f1:79:e7:01:a7:56:83:3b:37:59:be:9e:57:e8:9c:a8:84:2b:49:dd:5d:3d:04:37:fd:09:5f:59:93:20:f6:01:d2:d2:1a:57:1d:aa:6f:58:5c:ec:e2:df:77:ae:02:bf:9e:f3:bb:4e:e9:90:60:99:64:08:a4:84:71:c0:19:f0:ee:64:39:89:6d:bc:34:bf:03:f0:2e:69:8a:78:6d:20:9a:15:8f:64:b6:ee:5d:1a:4d:5b:2c:c9:87:a1:41:ee:92:f3:b4:56:24:35:73:53:e1:8c:4b:91:d6:f1:9f:31:6d:c8:a5:50:12:bf:d8:c1:a3:61:7f:4f:a5:6a:5b:98:91:94:68:bf:8f:49:5f:d5:e3:62:a1:a5:cc:98:7d:91:bb\"\n    }\n  },\n  // cert: {\n  //   kid: \"IPW4W1DX5D4N5E8LMAC6115la44Nu9zYob_bgrg5EUMksbgT4\",\n  //   publicKey: {\n  //     e: 65537,\n  //     n: \"1u29h6v2bcwNqCDatnQm6T4S_vKfXO-Hsp26abg9N9D-ENKKt3cQRQH8Pq6SeI74Y6VtWSYGo2bpK1p9dWXKHep-a9L6ugxO3UhilFFE_ZosL0KKOdALn4V-GWvIUPc7FittBn__IWS99eP1NJdtu89WH4MbCuSGbKjmmoak35GxC5cJTe858nVyTM7OqyHH52rDxpD3csl7GSgA56RHdoZMABkf3hH2men3DOji8l36gZaCPqlHKc6MP4b5RxP-uGaVNaxSd16PsZ15is8__EgQAK_PXP4mWUFGbEYFu-5NUhjmwngsywjc0HT9UncczvgePtKOh0ves49oFqQDMw\"\n  //   }\n  // },\n  sandbox: {\n    // kid: \"1bdab3cc\",\n    kid: 'V6YPL0DFJ2V56HIH6Q3F133fbZWyAyIHjWVSecx6KMF6iTHGM',\n    publicKey: {\n      e: 65537,\n      n: \"00:b1:93:c8:ba:c0:df:ef:24:27:9e:10:64:53:d9:ae:d7:85:4e:3b:70:ab:ba:2d:db:ee:b0:1f:d8:a6:1e:a1:b5:11:99:70:35:ed:bd:49:5f:d8:e0:d0:27:7e:be:0a:66:bb:24:eb:c4:15:12:73:ee:1b:d3:e5:0f:81:2c:06:16:a3:d6:52:9c:74:f0:4c:6a:af:03:c3:3a:f1:68:8c:1a:2e:db:09:72:ab:c6:dc:cb:45:2c:f8:17:de:0b:34:84:e6:53:15:75:25:d3:5d:75:dc:36:ab:be:a9:bd:b6:8c:20:82:24:02:e9:c6:c0:2b:b1:ba:0c:39:7b:0b:79:d8:77:33:85:cd:43:95:c6:02:d4:5f:ed:bf:be:b9:36:39:0e:bf:4a:2d:8c:94:bd:92:80:9d:8d:38:30:a2:4f:10:ee:78:62:22:05:33:90:d3:02:13:4e:9a:cd:3c:f6:37:4c:77:1f:94:44:82:89:8c:f5:36:f9:1a:47:1b:5b:bc:2c:21:b4:db:c4:53:22:93:ec:35:b4:5a:9e:e4:b9:4c:06:3f:ce:5c:43:81:bd:61:28:9d:fa:61:b6:44:34:72:e0:f4:f5:d3:06:17:4e:32:55:3d:d0:34:cb:95:f7:1b:2d:36:be:0f:b0:e0:96:30:1a:58:2b:af:cc:b3:da:1b\"\n    }\n  },\n  amex: {\n    kid: \"src-amex-card-enc-01\",\n    publicKey: {\n      e: 65537,\n      n: \"98:16:bc:c4:d7:1c:0a:25:a5:33:07:d9:05:89:ca:79:4c:b8:e0:9b:b0:fd:a7:4e:5b:76:d3:0b:46:3b:17:3a:04:ab:a7:ee:08:f0:a2:c5:7f:cd:18:39:98:93:ec:f8:f9:25:6a:96:3d:bf:20:b5:66:4b:72:3c:60:ef:cd:45:75:64:c8:fc:0f:17:48:d9:b6:9e:8f:4d:de:97:82:d4:4f:d5:cc:eb:97:fb:f2:3f:4b:ab:40:63:17:cc:09:33:c6:9d:05:3e:28:c3:b5:d6:c5:0f:72:0d:3d:c7:fe:e5:ed:7b:26:57:f6:44:5e:98:ce:a8:31:85:1b:56:ca:bc:33:66:58:66:0e:11:50:6d:6f:55:ac:f2:ee:5e:d0:1b:61:99:94:9c:14:27:08:6a:ac:c6:5b:5f:95:4f:ab:cc:8c:31:f5:b5:70:8b:b9:6c:b5:22:cc:6c:bf:22:00:3b:d1:1b:59:6b:50:b2:f9:1f:4c:94:93:75:f2:d4:39:70:7e:18:9d:04:0c:e3:9a:69:3f:89:d3:43:d1:64:b6:a6:59:7f:bf:1f:5b:f9:21:9a:be:53:85:75:ad:60:5c:fb:09:f6:f9:b7:a7:fd:e9:35:a7:5d:fe:04:77:12:55:5f:0e:f5:90:ca:01:59:fd:18:ec:0b:35:05:58:d6:a9:06:b6:af:18:90:60:06:7e:f2:b5:92:43:77:ec:9e:54:84:6d:47:50:04:18:18:f9:b0:1e:7a:d5:c5:37:ee:f1:f1:b3:a1:ef:f3:aa:db:d1:d1:d8:0d:26:a6:1f:7b:1a:fe:a1:76:9d:d9:94:48:df:56:10:2b:7d:28:35:a1:f0:47:11:af:6b:f7:db:ae:7b:99:c1:80:d7:05:bc:22:d5:6c:3f:8c:41:bd:75:f4:2d:db:40:84:0e:5c:ae:fa:70:40:97:49:b5:d1:b1:f3:e1:81:81:4d:6e:1a:32:6d:4f:6b:e1:70:63:b2:32:40:b5:28:72:c4:00:99:33:e5:76:8d\"\n    }\n  },\n  masterCard: {\n    kid: \"149123-src-fpan-encryption\",\n    publicKey: {\n      e: 65537,\n      n: \"vt4nDSPStTlM1NNcycvIqUf4x14I4jiTqMTKPjGtay0yfa1vByNChmuppDwET5gGGlpL8ccj3YVsBi9_bWoe_appkPwhxd7wR9RywV3zmWuMIhMwlk0lnHAML65nsHVM3oEpEvCfAPs1NXltTyfjnkgFENI3tHqtwdtM8eP02pp0jvW69fybvyVhLzXwSOgJntjtjRV7hQr5led_jWb5zzXI48OVTT_F9iinDdtX5y3E-if5WtGZUFETb_tZFZYnMLaLlHwvb6Zkr84RSwwsMf2nAL_4zP2UahMwzamhBoOSaqyxGxEq67Hr1U8zAC5hl9D8NbgSwpWxsODUrHx9rw\"\n    }\n  },\n  discover: {\n    kid: \"NTdkMDA1YTVjM2UyOTkzMmFiZDdmMWE0Y2IyZGE4NTMyNmNjNTVmZDM1ZGRkMDE0NmFjN2FiYzgyYjc4OWQ1NAo\",\n    publicKey: {\n      e: 65537,\n      n: \"00:9b:52:d4:cf:a2:74:bf:c6:f2:58:aa:0b:9c:59:39:88:dd:02:3c:d0:23:5f:32:1a:8c:3b:af:2f:9e:d1:ad:63:0a:d1:7c:dd:fc:a5:69:4a:86:6c:a9:35:e2:d5:35:40:1a:6d:12:d8:5e:f2:a7:06:f1:83:14:13:b8:67:d5:12:02:e2:b7:c0:e1:83:c9:fd:72:d9:23:08:22:67:15:fc:e4:cc:59:0d:51:aa:08:21:53:37:99:9d:6d:13:8a:33:8a:66:87:82:b7:c5:71:5c:7d:51:4b:8e:0d:0a:35:9f:d1:f2:76:41:f0:1f:92:05:3c:68:5a:a0:28:52:66:f3:4f:e2:0d:58:93:45:b9:68:84:71:b8:67:84:92:49:e6:ed:49:d4:4e:9b:00:4b:b8:77:f0:60:e7:ca:9c:73:85:79:0c:f3:be:9d:47:65:8a:d6:75:15:c1:1a:b1:c0:03:bc:d2:d3:65:32:ea:46:97:3a:1f:67:46:36:d3:95:7b:f3:c5:da:02:5a:d9:aa:d7:04:03:1d:ab:e8:43:05:02:cf:ba:1a:35:f9:f1:15:59:6c:60:aa:a9:80:02:65:18:01:2e:5c:92:81:a2:b2:43:62:38:25:b7:72:d0:8f:4d:f4:5e:f9:16:ed:5b:7d:74:83:75:fa:1e:c3:28:f5:05\"\n    }\n  }\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/encrypt-card.js\n\n\n\n\n\n// external, scrubbed sites\nconst encryptionKeys = (keys) ? keys : getEncryptionKeys();\n\nconst getRsaKeyFromDomain = () => {\n  const domain = getRootDomain();\n  console.log(`-- detected ${domain} from visa sdk url`);\n\n  switch (true) {\n    case 'https://secure.checkout.visa.com':\n      return encryptionKeys.production;\n    case domain.indexOf('qaperf') > -1:\n      return encryptionKeys.qa_perf;\n    case domain.indexOf('cert.') > -1:\n      console.log('using cert enc encryptionKeys');\n      return encryptionKeys.cert;\n    case domain.indexOf('sandbox.') > -1:\n      console.log('using sbx enc encryptionKeys');\n      return encryptionKeys.sandbox;\n    default:\n      return encryptionKeys.cert;\n  }\n}\n\nconst PANJWE_visa = async (s) => {\n  const { publicKey, kid } = getRsaKeyFromDomain();\n  console.info(`[PANJWE] kid: ${kid}`);\n  console.info('[PANJWE] publicKey: ', publicKey);\n  const crypt = new visa_encrypt.PANJWE(kid, publicKey);\n  return crypt.encrypt(s);\n}\n\n/* harmony default export */ const encrypt_card = (async (cardDataObject) => await PANJWE_visa(JSON.stringify(cardDataObject)));\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-visa-card.js\n\n\n\n\n\nconst handleCardData = async cardData => {\n  const ret = { cardData: null, encryptedCard: null };\n  const d = cardData.pan || cardData.data?.pan || cardData.data;\n  const expDateArray = d.ExpirationDate.split('/');\n  const vcoCard = {\n    card : {\n      cardSecurityCode: d.Cvv2Value,\n      cardholderFullName: d.CardholderName || \"SRC SDK\",\n      panExpirationMonth: parseInt(expDateArray[0]),\n      panExpirationYear: parseInt('20' + expDateArray[1]),\n      primaryAccountNumber: d.PrimaryAccountNumber,\n      cardholderFirstName: \"TestTool\",\n      cardholderLastName: \"SampleData\",\n      paymentAccountReference: \"\",\n\n      billingAddress: {\n        addressId: \"\",\n        name: \"\",\n        line1: d.AddressStreet,\n        line2: d.AddressStreet2,\n        line3: d.AddressStreet3,\n        city: d.City,\n        state: d.State,\n        countryCode: d.Country,\n        zip: d.AddressPostalCode,\n        createTime: \"\",\n        lastUsedTime: \"\",\n      }\n    }\n  };\n\n  console.log('object to encrypt: ', vcoCard);\n  ret.encryptedCard = await encrypt_card(vcoCard);\n  console.log(ret);\n  return ret;\n}\n\n/* harmony default export */ const get_visa_card = (async () => {\n  const binRange = utils_gel('bin_range').value;\n  const cardData = await fetch(`/cards?bin=${binRange}`).then(handleJsonResponse);\n  return await handleCardData(cardData);\n});\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/get-visa-card-manual.js\n\n\n\nconst encryptManualCardEntry = async () => {\n  const s = utils_gel('pan_json').value;\n  let pan;\n\n  try {\n    pan = JSON.parse(s);\n    return await handleCardData(pan);\n  } catch (e) {\n    catchErr('manual PAN JSON parse failed.');\n    return { encryptedCard: null }\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/after-auth.js\n\n\n\n\n\n\n\n\n\n\n\nasync function afterAuthNewUser(adapter, label) {\n  const intentPayload = data_getIntentPayload();\n  console.info(`[ADD_CARD] ${label || 'new user + enroll'}`);\n\n  if (canUseTestCardApi()) {\n    intentPayload.encryptedCard = (await get_visa_card()).encryptedCard;\n  } else {\n    intentPayload.encryptedCard = (await encryptManualCardEntry()).encryptedCard;\n  }\n  // console.log('intent payload after getVisaCard: ', intentPayload);\n\n  if (intentPayload.srcDigitalCardId) {\n    console.info('card already assigned, undefining intentPayload.srcDigitalCardId')\n    intentPayload.srcDigitalCardId = undefined;\n  }\n\n  console.info(`[CHECKOUT] ${label || 'new user + enroll'}`);\n  const checkoutSuccess = await checkout(adapter).catch(catchErr);\n\n  if (!checkoutSuccess || checkoutSuccess.error) {\n    console.error(`checkout error detected: `, checkoutSuccess);\n    setPassFail('FAIL');\n    throw new Error(JSON.stringify(checkoutSuccess));\n  } else {\n    updateBenchmarks();\n  }\n\n  if (checkoutSuccess && checkoutSuccess.unbindAppInstance) {\n    await unbind(adapter, checkoutSuccess).catch(catchErr);\n  }\n  setPassFail('PASS');\n}\n\n\nasync function afterAuthReturning(adapter, token) {\n  console.info('[CARD_LIST]');\n  // getSrcProfile\n  const srcProfiles = await getSrcProfile(adapter, token).catch(catchErr);\n  updateBenchmarks();\n\n  console.log(\"------\", srcProfiles);\n\n  if (srcProfiles.error) {\n    setPassFail('FAIL');\n    // throw new Error(srcProfiles.error);\n    console.warn(srcProfiles.error);\n  }\n\n  const preferAddCard = utils_gel('add_card_flow').checked;\n\n  // checkout\n  if (\n    false === preferAddCard &&\n    srcProfiles &&\n    !srcProfiles.error &&\n    srcProfiles.profiles[0].maskedCards.length > 0\n  ) {\n    console.info('[CHECKOUT] returning user');\n    const checkoutSuccess = await checkout(adapter).catch(catchErr);\n\n    if (!checkoutSuccess || checkoutSuccess.error) {\n      console.error(`checkout error detected: `, checkoutSuccess);\n      setPassFail('FAIL');\n      throw new Error(JSON.stringify(checkoutSuccess));\n    } else {\n      updateBenchmarks();\n    }\n\n    if (checkoutSuccess && checkoutSuccess.unbindAppInstance) {\n      await unbind(adapter, checkoutSuccess).catch(catchErr);\n    }\n    setPassFail('PASS');\n  } else {\n    afterAuthNewUser(adapter, 'returning user add card');\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/returning.js\n\n\n\n\n\nconst returningFlow = async (accessToken) => {\n  await afterAuthReturning(window.c2p_adapter, accessToken);\n\n  utils_gel('critical_apis').innerHTML = `Critical API timings: ${(benchmark.init + benchmark.isRecognized + benchmark.getSrcProfile) / 1000}s`;\n  utils_gel('checkout_apis').innerHTML = `Checkout API timings: ${(benchmark.checkout + benchmark.unbind) / 1000}s`;\n  updateBenchmarks();\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/load-sdk.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n\n\nvar loadSdkBenchmark = function (sdkUrl) {\n    setStartTime();\n    var loadStart = Date.now();\n    load_sdk(sdkUrl, function () { return __awaiter(void 0, void 0, void 0, function () {\n        var accessToken, consumerPresent, vcoAdapter, adapter;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    vcoAdapter = window.vAdapters.VisaSRCI;\n                    adapter = new vcoAdapter();\n                    window.c2p_adapter = adapter;\n                    // init\n                    return [4 /*yield*/, init(adapter, loadStart).catch(catchErr)];\n                case 1:\n                    // init\n                    _a.sent();\n                    updateBenchmarks();\n                    return [4 /*yield*/, isRecognized(adapter).catch(catchErr)];\n                case 2:\n                    // isRecognized\n                    accessToken = _a.sent();\n                    updateBenchmarks();\n                    if (!!accessToken) return [3 /*break*/, 13];\n                    console.info(\"recognize 204 - no access token\");\n                    return [4 /*yield*/, authFlow(afterAuthReturning, updateBenchmarks).catch(catchErr)];\n                case 3:\n                    consumerPresent = _a.sent();\n                    updateBenchmarks();\n                    if (!consumerPresent) return [3 /*break*/, 11];\n                    if (!(consumerPresent === 'manual')) return [3 /*break*/, 4];\n                    console.log(' --- awaiting manual OTP entry');\n                    return [3 /*break*/, 10];\n                case 4:\n                    if (!(consumerPresent.consumerPresent === false)) return [3 /*break*/, 6];\n                    return [4 /*yield*/, afterAuthNewUser(adapter)];\n                case 5:\n                    _a.sent();\n                    return [3 /*break*/, 10];\n                case 6:\n                    if (!consumerPresent.idToken) return [3 /*break*/, 8];\n                    return [4 /*yield*/, afterAuthReturning(adapter, consumerPresent.idToken)];\n                case 7:\n                    _a.sent();\n                    return [3 /*break*/, 10];\n                case 8: return [4 /*yield*/, afterAuthReturning(adapter)];\n                case 9:\n                    _a.sent();\n                    _a.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    setPassFail('FAIL');\n                    throw new Error('authFlow failure detected');\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    console.log('[ReturningRecognized] got accessToken', accessToken);\n                    returningFlow(accessToken);\n                    _a.label = 14;\n                case 14: return [2 /*return*/];\n            }\n        });\n    }); });\n};\n\n;// CONCATENATED MODULE: ./benchmark/js/flows/start-benchmark.js\n\n\n\n\n\n\n/**\n * Called in context of \"GO\" button\n * `this` is HTMLSelectElement id: \"sdk_picker_v3\"\n */\nconst startBenchmark = function() {\n  resetUi();\n  resetFlow();\n\n  if (validate()) {\n    const sdkUrl = this.value;\n    const key = this.options[this.selectedIndex].innerHTML.trim();\n    // update initData from env config\n    autoFillUUID(key);\n\n    if (sdkUrl) {\n      console.log(`Benchmark using [${sdkUrl}]`);\n      benchmarkState.sdkUrl = sdkUrl;\n      localStorage.setItem('sdk', sdkUrl);\n      loadSdkBenchmark(sdkUrl, key);\n    }\n  }\n};\n\n/* harmony default export */ const start_benchmark = (startBenchmark);\n\n;// CONCATENATED MODULE: ./benchmark/js/components/sdk-selector/index.js\n\n\n\nconst bindSdkGo = () => {\n  const goButton = utils_gel('go_v3');\n  \n  if (goButton) {\n    goButton.onclick = () => {\n      start_benchmark.call(utils_gel('sdk_picker_v3'));\n    };\n  }\n}\n\nconst handleSdkSelection = e => {\n  if (e.target.classList.contains('sdk-picker')) {\n    localStorage.setItem('sdk', e.target.value);\n    utils_gel('config_url').value = e.target.value;\n  }\n};\n\nconst bindSdkSelection = () => {\n  document.addEventListener('change', handleSdkSelection);\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/components/toggle/index.js\n\n\n\nconst toggleHandler = async e => {\n  if (e.target.className.indexOf('toggle-header') > -1) {\n    e.target.parentNode.classList.toggle(\"open\");\n    e.stopPropagation();\n  }\n}\n\nif (!canUseTestCardApi()) {\n  utils_gel('pan_entry').style.display = 'block';\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/helpers/generate-email-address.js\n\n\n// export default () => `${uuidv4()}@mailinator.com`;\n/* harmony default export */ const generate_email_address = (() => `c2p_${Date.now()}@mailinator.com`);\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/bind-compliance.js\n\n\n\nconst bindComplianceToggle = () => {\n  utils_gel('compliance_toggle').addEventListener('change', e => {\n    if (e.target.checked) {\n      injectComplianceSettings();\n      localStorage.setItem('setCompliance', 'on');\n    } else {\n      removeComplianceSettings();\n      localStorage.setItem('setCompliance', 'off');\n    }\n  });\n\n  if (localStorage.getItem('setCompliance') === 'on') {\n    utils_gel('compliance_toggle').checked = true;\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/ui/event-handlers.js\n\n\n\n\n\n\n\n\n\n\nlet automateTimeout;\nlet automateClickTimeout;\nlet timerInterval;\n\ndocument.body.addEventListener('click', e => {\n  try {\n    toggleHandler(e);\n  } catch (e) {\n    catchErr(e);\n  }\n});\n\n\nconst setPassFail = status => {\n  const e = new CustomEvent('passfail', { bubbles: true, detail: status });\n  utils_gel('pass_fail').dispatchEvent(e);\n}\nconst handlePassFail = e => {\n  utils_gel('pass_fail').innerHTML = e.detail;\n  utils_gel('pass_fail').classList.add((e.detail === 'PASS') ? 'pass' : 'fail');\n}\ndocument.body.addEventListener('passfail', handlePassFail);\n\n\nconst handleBubbledChangeEvents = async e => {\n  switch (e.target.id) {\n    case 'add_card_flow':\n    case 'returning_flow':\n      localStorage.setItem('flow_selector', e.target.value);\n      break;\n\n    case 'automate':\n      let timerValue = 30000;\n      if (e.target.checked === true) {\n        localStorage.setItem('automate', 'true');\n        automateClickTimeout = setTimeout(() => {\n          utils_gel('go_v3').click();\n        }, 1000);\n        automateTimeout = setTimeout(() => {\n          window.location.reload();\n        }, timerValue);\n        let displayTimer = timerValue / 1000;\n        timerInterval = setInterval(() => {\n          displayTimer -= 1;\n          utils_gel('timer').innerHTML = `${displayTimer}s until refresh`;\n        }, 1000);\n        document.body.className = 'disable-ui';\n      } else {\n        localStorage.setItem('automate', 'false');\n        clearTimeout(automateClickTimeout);\n        clearTimeout(automateTimeout);\n        clearInterval(timerInterval);\n        utils_gel('timer').innerHTML = ``;\n        document.body.className = '';\n      }\n      break;\n  }\n}\n\n\n\n\nconst handleConfigArea = () => {\n  utils_gel('config').innerHTML = JSON.stringify(data_initData, null, 2);\n};\n\nconst attachEventHandlers = () => {\n  const lsEmail = localStorage.getItem('email');\n  const automate = localStorage.getItem('automate');\n  const userType = localStorage.getItem('user_flow_selector');\n  const flowType = localStorage.getItem('flow_selector');\n  \n  bindComplianceToggle();\n  bindSdkGo();\n  bindSdkSelection();\n\n  initBinSelector();\n\n\n  // multiselect\n  document.addEventListener('click', e => {\n    if (e.target.tagName === 'OPTION' && e.target.className === 'historical_email_option') {\n      e.target.value && emailSetter(e.target.value);\n    }\n  });\n  \n  // dropdown\n  document.addEventListener('change', e => {\n    if (e.target.tagName === 'SELECT' && e.target.id === 'email_historical') {\n      e.target.value && emailSetter(e.target.value);\n    }\n  });\n\n  // new user\n  utils_gel('new_user').addEventListener('click', () => {\n    const newEmail = generate_email_address();\n    localStorage.setItem('email', newEmail);\n    utils_gel('emailInput').value = newEmail;\n  });\n\n  document.addEventListener('change', e => {\n    handleBubbledChangeEvents(e);\n  });\n\n  if (lsEmail) {\n    emailSetter(lsEmail);\n  }\n\n  if (automate === 'true') {\n    // console.log('automate is true');\n    const cb = utils_gel('automate');\n    cb && (cb.checked = true);\n    const evt = new Event('change', {\n      bubbles: true\n    });\n    cb.dispatchEvent(evt);\n  }\n\n  handleConfigArea();\n\n  if (userType) {\n    qs(`input[value=\"${userType}\"]`) && (qs(`input[value=\"${userType}\"]`).checked = true);\n  }\n  if (flowType) {\n    qs(`input[value=\"${flowType}\"]`) && (qs(`input[value=\"${flowType}\"]`).checked = true);\n  }\n}\n\n;// CONCATENATED MODULE: ./benchmark/js/index.ts\n\n\n\n\n\nattachEventHandlers();\nbuildSdkPicker();\nsetHistoricalEmails();\nif (location.hostname.indexOf('visa.com') < 0 &&\n    location.hostname.indexOf('localhost') < 0) {\n    var encKeys = getEncryptionKeys();\n    var envKeys = getEnvironmentKeys();\n    if (!(encKeys === null || encKeys === void 0 ? void 0 : encKeys.sandbox) || !(envKeys === null || envKeys === void 0 ? void 0 : envKeys.SandBox)) {\n        utils_gel('main').style.display = 'none';\n        utils_gel('need_metadata').style.display = 'block';\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxRQUFRO0FBQ2QsSUFBSSxzQkFBc0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUCx3QkFBd0IscUJBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxTQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBRztBQUNILEVBQUUsU0FBRztBQUNMOzs7QUNwRk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QkFBb0I7QUFDdEIsRUFBRSxTQUFTO0FBQ1gsRUFBRSxnQkFBZ0I7O0FBRWxCLEVBQUUsZUFBZTs7O0FBR2pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRSxTQUFHO0FBQ0wscUJBQXFCLHNCQUFvQjtBQUN6QztBQUNBLElBQUksU0FBRztBQUNQLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxJQUFJLFdBQVc7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxFQUFFLGlCQUFpQixTQUFTLFNBQVMsRUFBRSxpQkFBaUIsU0FBUztBQUNyRTtBQUNBO0FBQ0EsSUFBSSxFQUFFLGlCQUFpQixTQUFTLFNBQVMsRUFBRSxpQkFBaUIsU0FBUztBQUNyRTtBQUNBOzs7QUN4SXlEO0FBQ2hCO0FBQ2tDO0FBQ2hCO0FBQ0Q7QUFDMUQsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLFFBQVEsU0FBRztBQUNYLFFBQVEsU0FBRztBQUNYO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvdXRpbHMuanM/M2FiNiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvY29tcGxpYW5jZS1zZXR0aW5ncy5qcz8xOGIyIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvc3R1YnMvZGF0YS5qcz8zMTZjIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9lbWFpbC5qcz9kYjBlIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvc3R1YnMvZW52aXJvbm1lbnQta2V5cy5qcz84NDVhIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9nZXQta2V5cy50cz8xZWM5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvdWkvZ2VuZXJhdGUtc2RrLWxpc3QuanM/ZDBmYSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvY2FuLXVzZS10ZXN0LWNhcmRzLWFwaS5qcz83Yjc5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvY29tcG9uZW50cy9jYXJkLWJpbi1zZWxlY3Rvci9pbmRleC5qcz80N2I0Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy91dWlkLmpzPzIxMDMiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy91aS9yZXNldC11aS5qcz9hNDJlIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy92YWxpZGF0ZS1zdGFydC1vcHRpb25zLnRzPzkzN2YiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9hc3luYy9pbml0LmpzP2NkMmEiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9hc3luYy9pcy1yZWNvZ25pemVkLmpzP2YxMzciLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2dldC1yb290LWRvbWFpbi5qcz80ZTg2Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvbG9hZC1zZGsuanM/MTFiYyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvdXBkYXRlLWJlbmNobWFya3MuanM/MjJmNSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvZmV0Y2guanM/ZjI2NyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2hlbHBlcnMvZ2V0LW90cC5qcz9jYTg5Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9jYW4tdXNlLW90cC1hcGkuanM/NGNhNiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2Zsb3dzL2F1dGgtZmxvdy5qcz8yMDRmIiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvY2hlY2tvdXQuanM/Y2FhYyIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2FzeW5jL2dldC1zcmMtcHJvZmlsZS5qcz9iMzA3Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvYXN5bmMvdW5iaW5kLmpzPzljZjUiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9zdHVicy9wYW4tZW5jcnlwdGlvbi1rZXlzLmpzPzRiNTYiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2VuY3J5cHQtY2FyZC5qcz8yNTg0Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9nZXQtdmlzYS1jYXJkLmpzPzhhOTMiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9oZWxwZXJzL2dldC12aXNhLWNhcmQtbWFudWFsLmpzP2U5YTIiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9mbG93cy9hZnRlci1hdXRoLmpzPzU0M2MiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9mbG93cy9yZXR1cm5pbmcuanM/NDI1YiIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2Zsb3dzL2xvYWQtc2RrLnRzPzFiYWMiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9mbG93cy9zdGFydC1iZW5jaG1hcmsuanM/NTAwMCIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL2NvbXBvbmVudHMvc2RrLXNlbGVjdG9yL2luZGV4LmpzPzc0MzEiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9jb21wb25lbnRzL3RvZ2dsZS9pbmRleC5qcz82ZDU3Iiwid2VicGFjazovL3NyYy1iZW5jaG1hcmsvLi9iZW5jaG1hcmsvanMvaGVscGVycy9nZW5lcmF0ZS1lbWFpbC1hZGRyZXNzLmpzPzFlZDIiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy91aS9iaW5kLWNvbXBsaWFuY2UuanM/NDk3OSIsIndlYnBhY2s6Ly9zcmMtYmVuY2htYXJrLy4vYmVuY2htYXJrL2pzL3VpL2V2ZW50LWhhbmRsZXJzLmpzPzYwYmEiLCJ3ZWJwYWNrOi8vc3JjLWJlbmNobWFyay8uL2JlbmNobWFyay9qcy9pbmRleC50cz84YWE5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjZWwgPSB0YWcgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuZXhwb3J0IGNvbnN0IGdlbCA9IGlkID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbmV4cG9ydCBjb25zdCBnZWNuID0gY2xzID0+IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xzKTtcbmV4cG9ydCBjb25zdCBxcyA9IGNscyA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNscyk7XG5leHBvcnQgY29uc3QgcXNhID0gY2xzID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2xzKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEhvc3RuYW1lKHVybCkge1xuICB2YXIgaG9zdG5hbWU7XG4gIGlmICh1cmwuaW5kZXhPZihcIi8vXCIpID4gLTEpIHtcbiAgICBob3N0bmFtZSA9IHVybC5zcGxpdCgnLycpWzJdO1xuICB9XG4gIGVsc2Uge1xuICAgIGhvc3RuYW1lID0gdXJsLnNwbGl0KCcvJylbMF07XG4gIH1cbiAgLy9maW5kICYgcmVtb3ZlIHBvcnQgbnVtYmVyXG4gIGhvc3RuYW1lID0gaG9zdG5hbWUuc3BsaXQoJzonKVswXTtcbiAgLy9maW5kICYgcmVtb3ZlIFwiP1wiXG4gIGhvc3RuYW1lID0gaG9zdG5hbWUuc3BsaXQoJz8nKVswXTtcbiAgcmV0dXJuIGhvc3RuYW1lO1xufVxuXG5leHBvcnQgY29uc3QgY2F0Y2hFcnIgPSBlcnIgPT4ge1xuICBjb25zb2xlLnRyYWNlKGBbRVJST1IgQ0FVR0hUXWAsIGVycik7XG4gIGNvbnN0IGhlYWRlciA9IGNlbCgnZGl2Jyk7XG4gIGNvbnN0IHByZSA9IGNlbCgncHJlJyk7XG4gIGNvbnN0IHRyYWNlID0gY2VsKCdwcmUnKTtcbiAgY29uc3QgdHMgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCk7XG4gIGhlYWRlci5pbm5lckhUTUwgPSBgWyR7dHN9XSBlcnJvciBjYXVnaHQ6YDtcbiAgZ2VsKCdlcnJvcl9sb2cnKS5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICBcbiAgaWYgKGVyci5zdGFjaykge1xuICAgIHRyYWNlLmlubmVySFRNTCA9IGVyci5zdGFjaztcbiAgICBnZWwoJ2Vycm9yX2xvZycpLmFwcGVuZENoaWxkKHRyYWNlKTtcbiAgfSBlbHNlIHtcbiAgICBwcmUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICBwcmUuaW5uZXJIVE1MID0gKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSA/IGVyciA6IEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMik7XG4gICAgZ2VsKCdlcnJvcl9sb2cnKS5hcHBlbmRDaGlsZChwcmUpO1xuICB9XG4gIHJldHVybiBlcnI7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmopIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgcyA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG9ialtrZXldICYmIG9ialtrZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgb2JqW2tleV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzLmpvaW4oJyYnKTtcbn07XG4iLCJpbXBvcnQgeyBpbnRlbnRQYXlsb2FkIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5cbmV4cG9ydCBjb25zdCBpbmplY3RDb21wbGlhbmNlU2V0dGluZ3MgPSAoKSA9PiB7XG4gIGNvbnN0IHRlcm1zID0ge1xuICAgIGNvbXBsaWFuY2VUeXBlOiBcIlRFUk1TX0FORF9DT05ESVRJT05TXCIsXG4gICAgdXJpOiBcInVzYS52aXNhLmNvbS9sZWdhbC9jaGVja291dC90ZXJtcy1vZi1zZXJ2aWNlLmh0bWxcIixcbiAgfTtcbiAgY29uc3QgcHJpdmFjeSA9IHtcbiAgICBjb21wbGlhbmNlVHlwZTogXCJQUklWQUNZX1BPTElDWVwiLFxuICAgIHVyaTogXCJ1c2EudmlzYS5jb20vbGVnYWwvZ2xvYmFsLXByaXZhY3ktbm90aWNlLmh0bWxcIixcbiAgfTtcbiAgY29uc3QgcmVtZW1iZXIgPSB7XG4gICAgY29tcGxpYW5jZVR5cGU6IFwiUkVNRU1CRVJfTUVcIixcbiAgICB1cmk6IFwidmlzYS5jaGVja291dC5jb20vcHJpdmFjeVwiLFxuICB9O1xuXG4gIGludGVudFBheWxvYWQuY29tcGxpYW5jZVNldHRpbmdzID0ge1xuICAgIGNvbXBsaWFuY2VSZXNvdXJjZXM6IFt0ZXJtcywgcHJpdmFjeSwgcmVtZW1iZXJdXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MgPSAoKSA9PiB7XG4gIGludGVudFBheWxvYWQgJiYgZGVsZXRlIGludGVudFBheWxvYWQuY29tcGxpYW5jZVNldHRpbmdzO1xufVxuIiwiaW1wb3J0IHsgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzLCByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MgfSBmcm9tICcuLi9oZWxwZXJzL2NvbXBsaWFuY2Utc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vaGVscGVycy91dGlscyc7XG5cbmV4cG9ydCBsZXQgaW5pdERhdGE7XG5leHBvcnQgbGV0IGludGVudFBheWxvYWQ7XG5cbmV4cG9ydCBjb25zdCBpbml0RGF0YVJvb3QgPSB7XG4gIHNyY2lUcmFuc2FjdGlvbklkOiBcInJlcGxhY2UgbWVcIixcbiAgLy8gc3JjaURwYUlkOiBcIkRQQUlEXCIsXG4gIHNyY0luaXRpYXRvcklkOiBcIltBLUZhLWYwLTl8QS1GYS1mMC05XXs4fVxcXFwtKFtBLUZhLWYwLTl8QS1GYS1mMC05XXs0fVxcXFwtKXszfVtBLUZhLWYwLTl8QS1GYS1mMC05XXsxMn1cIixcbiAgZHBhRGF0YToge1xuICAgIC8vIHNyY0RwYUlkOiBcIlNSQ0RQQUlEXCIsXG4gICAgZHBhUHJlc2VudGF0aW9uTmFtZTogXCJEaXNuZXkgT25saW5lXCIsXG4gICAgZHBhVXJpOiBcImh0dHA6Ly93d3cuZGlzbmV5b25saW5lLmNvbVwiXG4gIH0sXG4gIGRwYVRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIGRwYUxvY2FsZTogXCJVU1wiLFxuICAgIGRwYUFjY2VwdGVkQmlsbGluZ0NvdW50cmllczogW1wiVVNcIixcIkNBXCJdLFxuICAgIGRwYUFjY2VwdGVkU2hpcHBpbmdDb3VudHJpZXM6IFtcIlVTXCIsXCJDQVwiXSxcbiAgICBkcGFCaWxsaW5nUHJlZmVyZW5jZTogXCJGVUxMXCIsXG4gICAgZHBhU2hpcHBpbmdQcmVmZXJlbmNlOiBcIkZVTExcIixcbiAgICBjb25zdW1lck5hbWVSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJFbWFpbEFkZHJlc3NSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJQaG9uZU51bWJlclJlcXVlc3RlZDogdHJ1ZSxcbiAgICBwYXltZW50T3B0aW9uczoge1xuICAgICAgZHBhRHluYW1pY0RhdGFUdGxNaW51dGVzOiAyLFxuICAgICAgZHluYW1pY0RhdGFUeXBlOiBcIkRZTkFNSUNfQ0FSRF9TRUNVUklUWV9DT0RFXCIsXG4gICAgICBkcGFQYW5SZXF1ZXN0ZWQ6IGZhbHNlXG4gICAgfSxcbiAgICByZXZpZXdBY3Rpb246IFwiY29udGludWVcIixcbiAgICB0cmFuc2FjdGlvblR5cGU6IFwiUFVSQ0hBU0VcIixcbiAgICBvcmRlclR5cGU6IFwiUkVBVVRIT1JJWkFUSU9OXCIsXG4gICAgcGF5bG9hZFR5cGVJbmRpY2F0b3I6IFwiU1VNTUFSWVwiLFxuICAgIHRyYW5zYWN0aW9uQW1vdW50OiB7XG4gICAgICB0cmFuc2FjdGlvbkFtb3VudDogXCI5OS45NVwiLFxuICAgICAgdHJhbnNhY3Rpb25DdXJyZW5jeUNvZGU6IFwiVVNEXCJcbiAgICB9LFxuICAgIG1lcmNoYW50T3JkZXJJZDogXCIyOGIxYjYxYi1iYmVjLTQ2MzctYjc4Zi0zM2JhYmMzYjUxODdcIixcbiAgICBtZXJjaGFudENhdGVnb3J5Q29kZTogXCIzMDAwXCIsXG4gICAgbWVyY2hhbnRDb3VudHJ5Q29kZTogXCJVU1wiLFxuICAgIHRocmVlRHNQcmVmZXJlbmNlOiBcIk5PTkVcIixcbiAgICB0aHJlZURzSW5wdXREYXRhOiB7XG4gICAgICByZXF1ZXN0b3JJZDogXCJyZXF1ZXN0b3JJZFwiLFxuICAgICAgYWNxdWlyZXJJZDogXCJhY3F1aXJlcklkXCIsXG4gICAgICBhY3F1aXJlck1pZDogXCJhY3F1aXJlck1pZFwiXG4gICAgfSxcbiAgICBjdXN0b21JbnB1dERhdGE6e1xuICAgICAgY2hlY2tvdXRPcmNoZXN0cmF0b3I6IFwibWVyY2hhbnRcIiwvL1wiVEVTVElOR1wiLCAvLyAnbWVyY2hhbnQnIGlzIGludGVncmF0ZWQgZXhwXG4gICAgICBkcGFJbnRlZ3JhdGlvblR5cGU6IFwiUFNQXCJcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1c2VySW5mbyA9IHtcbiAgaWRlbnRpdHlQcm92aWRlcjogXCJTUkNcIixcbiAgaWRlbnRpdHlWYWx1ZTogXCJzZW50aGlsckBtYWlsaW5hdG9yLmNvbVwiLFxuICBPVFBfcGVyZm9ybWVkOiBmYWxzZSxcbiAgY2FyZExpc3RfcGVyZm9ybWVkOiBmYWxzZSxcbiAgdHlwZTogXCJFTUFJTFwiXG59O1xuXG5leHBvcnQgY29uc3QgaW50ZW50UGF5bG9hZFJvb3QgPSB7XG4gIHNyY0NvcnJlbGF0aW9uSWQ6IFwiXCIsXG4gIHNyY2lUcmFuc2FjdGlvbklkOiBcIlwiLFxuICBzcmNEaWdpdGFsQ2FyZElkOiBcIlwiLFxuICBlbmNyeXB0ZWRDYXJkOiBcIlwiLFxuICBpZFRva2VuOiBcIlwiLFxuICB3aW5kb3dSZWY6IFwiXCIsXG4gIGNvbnN1bWVyOntcbiAgICBjb25zdW1lcklkZW50aXR5OiB7XG4gICAgICBpZGVudGl0eVByb3ZpZGVyOiBcIlNSQ1wiLCBcbiAgICAgIGlkZW50aXR5VHlwZTogXCJFTUFJTF9BRERSRVNTXCIsXG4gICAgICBpZGVudGl0eVZhbHVlOiBcImFzaG9rLnZib3gyOEBtYWlsaW5hdG9yLmNvbVwiXG4gICAgfSxcbiAgICBtb2JpbGVOdW1iZXI6IHtcbiAgICAgIHBob25lTnVtYmVyOiBcIjQxNTMzMzQ0NDRcIixcbiAgICAgIGNvdW50cnlDb2RlOiBcIjFcIlxuICAgIH0sXG4gICAgZW1haWxBZGRyZXNzOiBcImFzaG9rLnZib3gyOEBtYWlsaW5hdG9yLmNvbVwiLFxuICAgIG5hdGlvbmFsSWRlbnRpZmllcjogXCJVU0FcIixcbiAgICBjb3VudHJ5Q29kZTogXCJVU1wiLFxuICAgIGxhbmd1YWdlQ29kZTogXCJFTlwiLFxuICAgIGZpcnN0TmFtZTogXCJQU1BcIixcbiAgICBsYXN0TmFtZTogXCJUZXN0ZXJcIixcbiAgICBmdWxsTmFtZTogXCJQc3AgVGVzdGVyXCJcbiAgfSxcbiAgZHBhVHJhbnNhY3Rpb25PcHRpb25zOiB7XG4gICAgZHBhTG9jYWxlOiBcIlVTXCIsXG4gICAgZHBhQWNjZXB0ZWRCaWxsaW5nQ291bnRyaWVzOiBbXCJVU1wiLFwiQ0FcIl0sXG4gICAgZHBhQWNjZXB0ZWRTaGlwcGluZ0NvdW50cmllczogW1wiVVNcIixcIkNBXCJdLFxuICAgIGRwYUJpbGxpbmdQcmVmZXJlbmNlOiBcIkFMTFwiLFxuICAgIGRwYVNoaXBwaW5nUHJlZmVyZW5jZTogXCJBTExcIixcbiAgICBjb25zdW1lck5hbWVSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJFbWFpbEFkZHJlc3NSZXF1ZXN0ZWQ6IHRydWUsXG4gICAgY29uc3VtZXJQaG9uZU51bWJlclJlcXVlc3RlZDogdHJ1ZSxcbiAgICBwYXltZW50T3B0aW9uczoge1xuICAgICAgZHBhRHluYW1pY0RhdGFUdGxNaW51dGVzOiAyLFxuICAgICAgZHluYW1pY0RhdGFUeXBlOiBcIlRBVlZcIixcbiAgICAgIGRwYVBhblJlcXVlc3RlZDogZmFsc2VcbiAgICB9LFxuICAgIHJldmlld0FjdGlvbjogXCJjb250aW51ZVwiLFxuICAgIGNoZWNrb3V0RGVzY3JpcHRpb246IFwiU2FtcGxlIGNoZWNrb3V0XCIsXG4gICAgdHJhbnNhY3Rpb25UeXBlOiBcIlBVUkNIQVNFXCIsXG4gICAgb3JkZXJUeXBlOiBcIlJFQVVUSE9SSVpBVElPTlwiLFxuICAgIHBheWxvYWRUeXBlSW5kaWNhdG9yOiBcIlNVTU1BUllcIixcbiAgICB0cmFuc2FjdGlvbkFtb3VudDoge1xuICAgICAgdHJhbnNhY3Rpb25BbW91bnQ6IFwiOTkuOTVcIixcbiAgICAgIHRyYW5zYWN0aW9uQ3VycmVuY3lDb2RlOiBcIlVTRFwiXG4gICAgfSxcbiAgICBtZXJjaGFudE9yZGVySWQ6IFwiQUJDMTIzNDVcIixcbiAgICBtZXJjaGFudENhdGVnb3J5Q29kZTogXCJtZXJjaGFudENhdGVnb3J5Q29kZVwiLFxuICAgIG1lcmNoYW50Q291bnRyeUNvZGU6IFwiVVNcIixcbiAgICB0aHJlZURzSW5wdXREYXRhOiB7XG4gICAgICByZXF1ZXN0b3JJZDogXCJyZXF1ZXN0b3JJZFwiLFxuICAgICAgYWNxdWlyZXJJZDogXCJhY3F1aXJlcklkXCIsXG4gICAgICBhY3F1aXJlck1pZDogXCJhY3F1aXJlck1pZFwiXG4gICAgfSxcbiAgICBjdXN0b21JbnB1dERhdGE6e1xuICAgICAgZHBhSW50ZWdyYXRpb25UeXBlOlwiUFNQXCJcbiAgICB9XG4gIH0sXG4gIHBheWxvYWRUeXBlSW5kaWNhdG9yQ2hlY2tvdXQ6IFwiU1VNTUFSWVwiLCAvLyBGVUxMXG4gIHJlY2lwaWVudElkUGF5bG9hZDogXCJcIixcbiAgYXNzdXJhbmNlRGF0YToge1xuICAgIHZlcmlmaWNhdGlvbkRhdGE6W3tcbiAgICAgIHZlcmlmaWNhdGlvblR5cGU6IFwiQ0FSREhPTERFUlwiLFxuICAgICAgdmVyaWZpY2F0aW9uRW50aXR5OiBcIjAxXCIsXG4gICAgICB2ZXJpZmljYXRpb25NZXRob2Q6IFwiMDFcIixcbiAgICAgIHZlcmlmaWNhdGlvbnJlc3BvbnNlczogXCIwMVwiLFxuICAgICAgdmVyaWZpY2F0aW9uUmVzdWx0czogXCIwMVwiLFxuICAgICAgdmVyaWZpY2F0aW9uVGltZXN0YW1wOiBcIjE2NDY0MTY1NTBcIlxuICAgIH1dXG4gIH0sXG4gIHNyY2lBY3Rpb25Db2RlOiBcIk5FV19VU0VSXCIgXG59O1xuXG5leHBvcnQgbGV0IHNyY1Byb2ZpbGVzID0gW107XG5cbmV4cG9ydCBjb25zdCBiZW5jaG1hcmsgPSB7XG4gIGluaXQ6IDAsXG4gIGlzUmVjb2duaXplZDogMCxcbiAgaWRlbnRpdHlMb29rdXA6IDAsXG4gIGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uOiAwLFxuICAvLyBVSVVYX3RvX09UUDogMCxcbiAgY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb246IDAsXG4gIGdldFNyY1Byb2ZpbGU6IDAsXG4gIC8vIFVJVVhfdG9fY2FyZExpc3Q6IDAsXG4gIGNoZWNrb3V0OiAwLFxuICBhZGRDYXJkOiAwLFxuICBlbnJvbGxVc2VyOiAwLFxuICB1bmJpbmQ6IDAsXG59O1xuXG5leHBvcnQgY29uc3QgYmVuY2htYXJrU3RhdGUgPSB7XG4gIHNka1VybDogJycsXG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRGbG93ID0gKCkgPT4ge1xuICBjb25zb2xlLmluZm8oJ1JFU0VUJylcbiAgaW5pdERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0RGF0YVJvb3QpO1xuICBpbnRlbnRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZW50UGF5bG9hZFJvb3QpO1xuICB1c2VySW5mby5PVFBfcGVyZm9ybWVkID0gZmFsc2U7XG4gIHVzZXJJbmZvLmNhcmRMaXN0X3BlcmZvcm1lZCA9IGZhbHNlO1xuICBzcmNQcm9maWxlcyA9IFtdO1xufTtcblxuXG5leHBvcnQgY29uc3QgZ2V0SW50ZW50UGF5bG9hZCA9ICgpID0+IHtcbiAgaWYgKCFpbnRlbnRQYXlsb2FkKSB7XG4gICAgaW50ZW50UGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIGludGVudFBheWxvYWRSb290KTtcbiAgfVxuXG4gIGlmIChnZWwoJ2NvbXBsaWFuY2VfdG9nZ2xlJykuY2hlY2tlZCkge1xuICAgIGluamVjdENvbXBsaWFuY2VTZXR0aW5ncygpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncygpO1xuICB9XG5cbiAgcmV0dXJuIGludGVudFBheWxvYWQ7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW50ZW50UGF5bG9hZCA9IHBheWxvYWQgPT4ge1xuICBpbnRlbnRQYXlsb2FkID0gcGF5bG9hZDtcbn1cbiIsImltcG9ydCB7IGNlbCwgZ2VsLCBxc2EgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJJbmZvLCBnZXRJbnRlbnRQYXlsb2FkIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5cbi8vIFRvIGF1dG9maWxsIHRoZSBlbWFpbCBpbiBpZGxvb2t1cCBmaWVsZFxuZXhwb3J0IGZ1bmN0aW9uIGVtYWlsU2V0dGVyKGVtYWlsKSB7XG4gIGlmIChlbWFpbCkge1xuICAgIGNvbnN0IGVtID0gZ2VsKCdlbWFpbElucHV0Jyk7XG4gICAgZW0udmFsdWUgPSBlbWFpbDtcblxuICAgIGF1dG9JZExvb2t1cEVtYWlsQWRkcmVzcyhlbWFpbCk7XG4gICAgYXV0b0ZpbGxFbWFpbEFkZHJlc3NJbkNoZWNrb3V0QXBpcmVxdWVzdChlbWFpbCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEhpc3RvcmljYWxFbWFpbHMoKSB7XG4gIGxldCBlbWFpbEhpc3RvcmljYWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZW1haWxfaGlzdG9yaWNhbCcpO1xuXG4gIGlmIChlbWFpbEhpc3RvcmljYWwpIHtcbiAgICBjb25zdCBoaXN0b3J5ID0gZ2VsKCdlbWFpbF9oaXN0b3JpY2FsJyk7XG4gICAgZW1haWxIaXN0b3JpY2FsID0gSlNPTi5wYXJzZShlbWFpbEhpc3RvcmljYWwpO1xuXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIG5vZGVcbiAgICBxc2EoJyNlbWFpbF9oaXN0b3JpY2FsIG9wdGlvbicpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8ZW1haWxIaXN0b3JpY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3B0aW9uID0gY2VsKCdvcHRpb24nKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGVtYWlsSGlzdG9yaWNhbFtpXTtcbiAgICAgIG9wdGlvbi5jbGFzc05hbWUgPSAnaGlzdG9yaWNhbF9lbWFpbF9vcHRpb24nO1xuICAgICAgb3B0aW9uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVtYWlsSGlzdG9yaWNhbFtpXSkpO1xuXG4gICAgICBoaXN0b3J5LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfVxuICB9XG59XG5cbi8vIHVwZGF0ZSBlbWFpbCBpbiBpZExvb2t1cCBwYXlsb2FkXG5mdW5jdGlvbiBhdXRvSWRMb29rdXBFbWFpbEFkZHJlc3MoZW1haWwpIHtcbiAgbGV0IGVtYWlsSGlzdG9yaWNhbDtcblxuICBpZiAodXNlckluZm8pIHtcbiAgICB1c2VySW5mby5pZGVudGl0eVZhbHVlID0gZW1haWw7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtYWlsJywgZW1haWwpO1xuXG4gICAgZW1haWxIaXN0b3JpY2FsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtYWlsX2hpc3RvcmljYWwnKTtcblxuICAgIGlmICghZW1haWxIaXN0b3JpY2FsKSB7XG4gICAgICBlbWFpbEhpc3RvcmljYWwgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1haWxIaXN0b3JpY2FsID0gSlNPTi5wYXJzZShlbWFpbEhpc3RvcmljYWwpO1xuICAgIH1cblxuICAgIGlmIChlbWFpbEhpc3RvcmljYWwuaW5kZXhPZihlbWFpbCkgPCAwKSB7XG4gICAgICBlbWFpbEhpc3RvcmljYWwucHVzaChlbWFpbCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZW1haWxfaGlzdG9yaWNhbCcsIEpTT04uc3RyaW5naWZ5KGVtYWlsSGlzdG9yaWNhbCkpO1xuICAgICAgc2V0SGlzdG9yaWNhbEVtYWlscygpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUbyBhdXRvZmlsbCB0aGUgZW1haWwgaW4gY2hlY2tvdXQgZmllbGRcbmV4cG9ydCBmdW5jdGlvbiBhdXRvRmlsbEVtYWlsQWRkcmVzc0luQ2hlY2tvdXRBcGlyZXF1ZXN0KGVtYWlsKSB7XG4gIGNvbnN0IGludGVudFBheWxvYWQgPSBnZXRJbnRlbnRQYXlsb2FkKCk7XG4gIFxuICBpZiAoaW50ZW50UGF5bG9hZCkge1xuICAgIGludGVudFBheWxvYWQuY29uc3VtZXIuZW1haWxBZGRyZXNzID0gZW1haWxJbnB1dC52YWx1ZTtcbiAgICBpbnRlbnRQYXlsb2FkLmNvbnN1bWVyLmNvbnN1bWVySWRlbnRpdHkuaWRlbnRpdHlWYWx1ZSA9IGVtYWlsSW5wdXQudmFsdWU7XG4gICAgaW50ZW50UGF5bG9hZC5jb25zdW1lci5tb2JpbGVOdW1iZXIucGhvbmVOdW1iZXIgPSAnNDE1MzMzNDQ0NCc7XG4gIH1cbn1cblxuXG5leHBvcnQgY29uc3Qgc2V0RW1haWxFcnJvck1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gIGdlbCgnZW1haWxfZXJyb3JfbWVzc2FnZScpLmlubmVySFRNTCA9IG1zZztcbn1cblxuLy8gYm9vdHN0cmFwXG5nZWwoJ2VtYWlsSW5wdXQnKS5vbmJsdXIgPSBmdW5jdGlvbiBwb3B1bGF0ZUVtYWlsKCkge1xuICBjb25zdCBlbWFpbCA9IHRoaXMudmFsdWU7XG4gIGVtYWlsU2V0dGVyKGVtYWlsKTtcbn1cbmdlbCgnZW1haWxJbnB1dCcpLm9uZm9jdXMgPSAoKSA9PiB7XG4gIGdlbCgnZW1haWxfZXJyb3JfbWVzc2FnZScpLmlubmVySFRNTCA9ICcnO1xufVxuIiwiZXhwb3J0IGNvbnN0IGVudmlyb25tZW50S2V5cyA9IHtcbiAgJ1FhUGVyZic6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzdIS0ZPU1Y5RzUyRlBPNFZHQjkyMTFsTzFZM0U1T1BfVHVmTVFteUNqV0pLeTFONjQnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJzdIS0ZPU1Y5RzUyRlBPNFZHQjkyMTFsTzFZM0U1T1BfVHVmTVFteUNqV0pLeTFONjQnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1FhUGVyZl9Eb2NrZXJFRSc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzdIS0ZPU1Y5RzUyRlBPNFZHQjkyMTFsTzFZM0U1T1BfVHVmTVFteUNqV0pLeTFONjQnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJzdIS0ZPU1Y5RzUyRlBPNFZHQjkyMTFsTzFZM0U1T1BfVHVmTVFteUNqV0pLeTFONjQnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ0RFVldLU1BDRSc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1FBV0tTUENFJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnMDc3NTA1OTUtZmNjMS0wZDJlLTczODgtMTFjNTc2OWUwMjAxJ1xuICB9LFxuICBcbiAgJ1Zib3g0NDRfQ29udGFpbmVyJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnMDc3NTA1OTUtZmNjMS0wZDJlLTczODgtMTFjNTc2OWUwMjAxJ1xuICB9LFxuICAnVmJveDY3MSc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJ1NXT0VKWDAyMlpQWFhRRDNTOFlOMTFGRDRveUJyNUluYkZXR25GeHJGR1hVRGpONkknLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0lQVzRXMURYNUQ0TjVFOExNQUM2MTE1bGE0NE51OXpZb2JfYmdyZzVFVU1rc2JnVDQnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3gyOCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJ0o2WERRUVFaNUNEU1NKSzA0NjJZMTF2LVlXV0ZKNE84Ry0zblRGd0lJRHdtcUJMTU0nLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o2WERRUVFaNUNEU1NKSzA0NjJZMTF2LVlXV0ZKNE84Ry0zblRGd0lJRHdtcUJMTU0nLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3g0NDEnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICczMlYzR0xUN01GUFFKWFhaQ09URDExOUxvS0VwbWxnUGFJQWlTZU1KRlFROW1VZy00JyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICczMlYzR0xUN01GUFFKWFhaQ09URDExOUxvS0VwbWxnUGFJQWlTZU1KRlFROW1VZy00JyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdWYm94NDQyX0FkeWVuJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnOFlQVzRTSERGWDVWTFo4TUxIREIyMThXbHZBd000ejJQZzFyX0RwWlk4bE5haWJlYycsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0Mic6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3g0NDRfRXh0ZXJuYWxTcmNpJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0NF9BZHllbic6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzhZUFc0U0hERlg1VkxaOE1MSERCMjE4V2x2QXdNNHoyUGcxcl9EcFpZOGxOYWliZWMnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3g0NDRfUFNQJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnVEMwM1VPNzg0WVlVSVIzQkFOVUcxMVdFMnBRRVdncjVQcHVJVmJVWkZCX29aTE9jbycsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnVmJveDQ0NF8zRFMnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICc4WVBXNFNIREZYNVZMWjhNTEhEQjIxOFdsdkF3TTR6MlBnMXJfRHBaWThsTmFpYmVjJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdKNUMwOVhCWkE2Rzg5MUs0RkdHNjExTmlaVmlPM2w5MDVHUHFBMDg4RENFQktrbFprJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICdhYjFhNGU2Zi05NTZjLWE3OTMtNzIxZi0xMzMzMzZkYzI3MCdcbiAgfSxcbiAgJ1Zib3g3MzQnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICdLWEwzRkYxSk5OWlUwT1JCMENERDExVFE1d1B4UHFkVUg0YzRrOFBGS3A3Z0ZPem04JyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdTWVowRTAxUFlISjRaU1hZVThGSDExYzhJa1F5cnJ3Z0hzaDNyV2pBRmhPYzFKLWxFJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdWYm94NzM0X1BTUCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJ0swMllFUVJPMExMSkJMSzZYRDBHMTF2UDJaX1B3TUtHUjRxU2VKVzhUQ1FoSlVkYmsnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ1NZWjBFMDFQWUhKNFpTWFlVOEZIMTFjOElrUXlycndnSHNoM3JXakFGaE9jMUotbEUnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1Zib3g0NjInOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICdJQlpPWllNVlNZOUpZVDZXSlZMNzExMUNVV21oYzVlZ2t3R2pIZ0JEX2tRdG82NlM4JyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdJQlpPWllNVlNZOUpZVDZXSlZMNzExMUNVV21oYzVlZ2t3R2pIZ0JEX2tRdG82NlM4JyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdRQUlOVCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJ0QyNTdHQ0FPUjNKR1BUR0FDT044MTFoTjVvZEJ0QmFXMFoxOE9uWGgzYmh3RnVIMTgnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0QyNTdHQ0FPUjNKR1BUR0FDT044MTFoTjVvZEJ0QmFXMFoxOE9uWGgzYmh3RnVIMTgnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ0NFUlQnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICczV1FSR1VTWTZDRVNKUzJLUVNXODExSlh4OVAxSkxzMkRyYk9LcVU5RVhiZmpyZVVvJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICczV1FSR1VTWTZDRVNKUzJLUVNXODExSlh4OVAxSkxzMkRyYk9LcVU5RVhiZmpyZVVvJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdDRVJUX09DQyc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNXUVJHVVNZNkNFU0pTMktRU1c4MTFKWHg5UDFKTHMyRHJiT0txVTlFWGJmanJlVW8nLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJzNXUVJHVVNZNkNFU0pTMktRU1c4MTFKWHg5UDFKTHMyRHJiT0txVTlFWGJmanJlVW8nLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ0NFUlRfT0NFJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM1dRUkdVU1k2Q0VTSlMyS1FTVzgxMUpYeDlQMUpMczJEcmJPS3FVOUVYYmZqcmVVbycsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnM1dRUkdVU1k2Q0VTSlMyS1FTVzgxMUpYeDlQMUpMczJEcmJPS3FVOUVYYmZqcmVVbycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnJ1xuICB9LFxuICAnQ0VSVDEnOiB7XG4gICAgc3JjSW5pdGlhdG9ySWQ6ICdCOFZGM0c1NDRNSzkwUE1RQUczSTExblItZVdRbWozdWhmczlkUVhQRWRqYm1ycGZvJyxcbiAgICBwYW5FbmNyeXB0aW9uSWQ6ICdMOUE4QUNXNERDVEs4M1UyVDRTQjExTmhRcFZrcDdtQWg5TnRuTjVtczB3WXU3d28wJyxcbiAgICBzcmNpRHBhSWQ6ICdEUEFJRCcsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdTYW5kQm94Jzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnVjZZUEwwREZKMlY1NkhJSDZRM0YxMzNmYlpXeUF5SUhqV1ZTZWN4NktNRjZpVEhHTScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnVjZZUEwwREZKMlY1NkhJSDZRM0YxMzNmYlpXeUF5SUhqV1ZTZWN4NktNRjZpVEhHTScsXG4gICAgc3JjaURwYUlkOiAnbWF0ZXN0ZHBhMicsXG4gICAgc3JjRHBhSWQ6ICcnXG4gIH0sXG4gICdWYm94NDQ0X0NvbnRhaW5lcl9Eb2NrZXJFRSc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJydcbiAgfSxcbiAgJ1FhX09wZW5TaGlmdCc6IHtcbiAgICBzcmNJbml0aWF0b3JJZDogJzNFWTcyMlFUVVBaQ1k1WDVBM0lZMjFPTHk0dGUwWlRPOUtCM1BKTVc5dWdkUTNaQVEnLFxuICAgIHBhbkVuY3J5cHRpb25JZDogJ0o1QzA5WEJaQTZHODkxSzRGR0c2MTFOaVpWaU8zbDkwNUdQcUEwODhEQ0VCS2tsWmsnLFxuICAgIHNyY2lEcGFJZDogJ0RQQUlEJyxcbiAgICBzcmNEcGFJZDogJzA3NzUwNTk1LWZjYzEtMGQyZS03Mzg4LTExYzU3NjllMDIwMSdcbiAgfSxcbiAgJ1FhX0RvY2tlckVFJzoge1xuICAgIHNyY0luaXRpYXRvcklkOiAnM0VZNzIyUVRVUFpDWTVYNUEzSVkyMU9MeTR0ZTBaVE85S0IzUEpNVzl1Z2RRM1pBUScsXG4gICAgcGFuRW5jcnlwdGlvbklkOiAnSjVDMDlYQlpBNkc4OTFLNEZHRzYxMU5pWlZpTzNsOTA1R1BxQTA4OERDRUJLa2xaaycsXG4gICAgc3JjaURwYUlkOiAnRFBBSUQnLFxuICAgIHNyY0RwYUlkOiAnMDc3NTA1OTUtZmNjMS0wZDJlLTczODgtMTFjNTc2OWUwMjAxJ1xuICB9XG59O1xuIiwiaW1wb3J0IHsgZW52aXJvbm1lbnRLZXlzIH0gZnJvbSAnLi4vc3R1YnMvZW52aXJvbm1lbnQta2V5cy5qcyc7XG5pbXBvcnQgeyBpbml0RGF0YSB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xudmFyIGdldEZyb21Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuZXhwb3J0IHZhciBnZXRFbnZpcm9ubWVudEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEZyb21Mb2NhbFN0b3JhZ2UoJ2Vudmlyb25tZW50S2V5cycpO1xufTtcbmV4cG9ydCB2YXIgZ2V0RW5jcnlwdGlvbktleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEZyb21Mb2NhbFN0b3JhZ2UoJ2tleXMnKTtcbn07XG5leHBvcnQgdmFyIGdldEVudmlyb25tZW50ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnZLZXlzID0gKGVudmlyb25tZW50S2V5cykgPyBlbnZpcm9ubWVudEtleXMgOiBnZXRFbnZpcm9ubWVudEtleXMoKTtcbiAgICB2YXIgZ2VuZXJpY0tleSA9IGtleS5yZXBsYWNlKC9TREt2WzAtOV0uKiQvaSwgJycpLnRyaW0oKTtcbiAgICBpZiAoZW52S2V5c1tnZW5lcmljS2V5XSkge1xuICAgICAgICByZXR1cm4gZW52S2V5c1tnZW5lcmljS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IHZhciBnZXRNZXJjaGFudEFwaUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5pdERhdGEuc3JjSW5pdGlhdG9ySWQpXG4gICAgICAgIHJldHVybiBpbml0RGF0YS5zcmNJbml0aWF0b3JJZDtcbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCJpbXBvcnQgeyBjZWwsIGdlbCB9IGZyb20gJy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuXG5jb25zdCBlbnZzID0ge1xuICAvLyBcIi0tLSBQaWNrXCI6IFwiXCIsXG4gIFFhUGVyZl9Eb2NrZXJFRTogXCJodHRwczovL3NyYy1xYXBlcmZiLms4cy1ucC1jbHMxLXAudHJ1c3RlZC52aXNhLmNvbVwiLFxuICBRQVdLU1BDRTogXCJodHRwczovL2IyY3AtdmNvLXFhYi5vY2UtbnAtc20tZGRwLXAtZW4udHJ1c3RlZC52aXNhLmNvbVwiLFxuICBERVZXS1NQQ0U6ICdodHRwczovL2IyY3AtdmNvLWRldndrc3BjZWIub2NlLW5wLXNtLWRkcC1wLWVuLnRydXN0ZWQudmlzYS5jb20nLCAvLyBEb2NrZXJFRVxuICBTYW5kQm94OiBcImh0dHBzOi8vc2FuZGJveC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcblxuICBDRVJUOiBcImh0dHBzOi8vY2VydC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgQ0VSVF9PQ0M6IFwiaHR0cHM6Ly9vY2MtY2VydC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgQ0VSVF9PQ0U6IFwiaHR0cHM6Ly9vY2UtY2VydC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gUWFQZXJmOiBcImh0dHBzOi8vcGVyZi5xYS5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gQ0VSVDE6IFwiaHR0cHM6Ly9jZXJ0MS5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbiAgLy8gSUNMOiBcImh0dHBzOi8vZGVtby5pY2wudmlzYS5jb21cIixcbiAgLy8gUUFJTlQ6IFwiaHR0cHM6Ly9pbnQucWEuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tXCIsXG4gIFZib3g0NDRfRXh0ZXJuYWxTcmNpOiBcImh0dHBzOi8vdmJveDQ0NC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb21cIixcbn07XG5cblxuZXhwb3J0IGNvbnN0IGJ1aWxkU2RrUGlja2VyID0gKCkgPT4ge1xuICBjb25zdCBzZGtTZWxlY3Rvcl92Ml9pbnRlZ3JhdGVkID0gZ2VsKCdzZGtfcGlja2VyX3YzJyk7XG4gIGNvbnN0IHN0b3JlZFNkayA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZGsnKTtcblxuICBmb3IgKGxldCBrIGluIGVudnMpIHtcbiAgICBjb25zdCBvcHRpb25fdjMgPSBjZWwoJ29wdGlvbicpO1xuICAgIG9wdGlvbl92My5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgYCR7ZW52c1trXX0vY2hlY2tvdXQtd2lkZ2V0L3Jlc291cmNlcy9qcy9zcmMtaS1hZGFwdGVyL3Zpc2FTZGsuanM/djJgKVxuICAgIG9wdGlvbl92My5pbm5lckhUTUwgPSBgJHtrfSBJTlRFR1JBVEVEYDtcbiAgICBvcHRpb25fdjMuc2VsZWN0ZWQgPSBzdG9yZWRTZGsgPT09IGAke2VudnNba119L2NoZWNrb3V0LXdpZGdldC9yZXNvdXJjZXMvanMvc3JjLWktYWRhcHRlci92aXNhU2RrLmpzP3YyYDtcbiAgICBzZGtTZWxlY3Rvcl92Ml9pbnRlZ3JhdGVkLmFwcGVuZENoaWxkKG9wdGlvbl92Myk7XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBjYW5Vc2VUZXN0Q2FyZEFwaSA9ICgpID0+IHtcbiAgc3dpdGNoICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpIHtcbiAgICAvLyBjYXNlICdsb2NhbGhvc3QnOlxuICAgIGNhc2UgJ2Nub2ppbWEuZ2l0aHViLmlvJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscyc7XG5pbXBvcnQgeyBjYW5Vc2VUZXN0Q2FyZEFwaSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvY2FuLXVzZS10ZXN0LWNhcmRzLWFwaSc7XG5cbmNvbnN0IGRlZmF1bHRCaW4gPSAnNDE0NzE4JztcbmNvbnN0IGJpbnMgPSB7XG4gICctLSA0MDA1NTIgKG5vbi10b2tlbml6YWJsZT8pJzogJzQwMDU1MicsXG4gICctLSA0MjA3NjcgKHRva2VuaXphYmxlKSc6ICc0MjA3NjcnLFxuICAnLS0gNDE0NzE4ICh0b2tlbml6YWJsZSknOiAnNDE0NzE4J1xufTtcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUJpblNlbGVjdGlvbiA9IGUgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYmluUmFuZ2UnLCBlLnRhcmdldC52YWx1ZSk7XG59XG5cbmV4cG9ydCBjb25zdCBpbml0QmluU2VsZWN0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IGJpblJhbmdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2JpblJhbmdlJyk7XG4gIGNvbnN0IHNlbGVjdCA9IGdlbCgnYmluX3JhbmdlJyk7XG5cbiAgZm9yIChsZXQgayBpbiBiaW5zKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gYmluc1trXTtcbiAgICBvcHRpb24ubGFiZWwgPSBrO1xuXG4gICAgaWYgKGJpblJhbmdlICYmIGJpblJhbmdlID09PSBiaW5zW2tdKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWJpblJhbmdlICYmIGJpbnNba10gPT09IGRlZmF1bHRCaW4pIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH1cblxuICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlQmluU2VsZWN0aW9uKTtcblxuICBpZiAoY2FuVXNlVGVzdENhcmRBcGkoKSkge1xuICAgIGdlbCgnYmluX3NlbGVjdG9yJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBpbml0RGF0YSwgZ2V0SW50ZW50UGF5bG9hZCB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnQgfSBmcm9tICcuL2dldC1rZXlzLnRzJztcblxuLy8gTWV0aG9kIHRvIGdlbmVyYXRlIHJhbmRvbSBVVUlEXG5leHBvcnQgZnVuY3Rpb24gdXVpZHY0KCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLy8gVG8gYXV0b2ZpbGwgVVVJRCBvbiBldmVyeSBwYWdlIHJlZnJlc2hcbmV4cG9ydCBmdW5jdGlvbiBhdXRvRmlsbFVVSUQoa2V5KSB7XG4gIGNvbnN0IGludGVudFBheWxvYWQgPSBnZXRJbnRlbnRQYXlsb2FkKCk7XG4gIGNvbnN0IHNyY2lUcmFuc2FjdGlvbklkID0gdXVpZHY0KCk7XG4gIGNvbnN0IGVudiA9IGdldEVudmlyb25tZW50KGtleSk7XG4gIGluaXREYXRhLnNyY2lUcmFuc2FjdGlvbklkID0gc3JjaVRyYW5zYWN0aW9uSWQ7XG4gIGludGVudFBheWxvYWQuc3JjaVRyYW5zYWN0aW9uSWQgPSBzcmNpVHJhbnNhY3Rpb25JZDtcblxuICBjb25zdCBiYWQgPSBbJ3NyY0RwYUlkJywgJ3BhbkVuY3J5cHRpb25JZCddO1xuICBmb3IgKGxldCBrIGluIGVudikge1xuICAgIGlmIChiYWQuaW5kZXhPZihrKSA9PT0gLTEpXG4gICAgICBpbml0RGF0YVtrXSA9IGVudltrXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYXV0b0ZpbGxVVUlEQXV0b21hdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgaW50ZW50UGF5bG9hZCA9IGdldEludGVudFBheWxvYWQoKTtcbiAgY29uc3Qgc3JjaVRyYW5zYWN0aW9uSWQgPSB1dWlkdjQoKTtcbiAgbGV0IGRwYUlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NyY2lEcGFJZCcpO1xuXG4gIGlmICghZHBhSWQpIHtcbiAgICBjb25zb2xlLndhcm4oJyAtLS0gc3JjRHBhSWQgbm90IHNldCAtIHVzaW5nIGRlZmF1bHQgRFBBSUQnKTtcbiAgICBkcGFJZCA9ICdEUEFJRCc7XG4gIH1cblxuICBpbml0RGF0YS5zcmNpVHJhbnNhY3Rpb25JZCA9IHNyY2lUcmFuc2FjdGlvbklkO1xuICBpbnRlbnRQYXlsb2FkLnNyY2lUcmFuc2FjdGlvbklkID0gc3JjaVRyYW5zYWN0aW9uSWQ7XG4gIGluaXREYXRhWydzcmNJbml0aWF0b3JJZCddID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2luaXRpYXRvcklkJyk7XG4gIGluaXREYXRhWydzcmNpRHBhSWQnXSA9IGRwYUlkO1xuXG4gIGRlbGV0ZSBpbml0RGF0YVsnYXBpa2V5J107XG59XG4iLCJpbXBvcnQgeyBxc2EsIGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCJcbmltcG9ydCB7IGJlbmNobWFyayB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xuaW1wb3J0IHsgY2FuVXNlVGVzdENhcmRBcGkgfSBmcm9tICcuLi9oZWxwZXJzL2Nhbi11c2UtdGVzdC1jYXJkcy1hcGkuanMnO1xuaW1wb3J0IHsgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzLCByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MgfSBmcm9tICcuLi9oZWxwZXJzL2NvbXBsaWFuY2Utc2V0dGluZ3MuanMnO1xuXG5jb25zdCB0YXJnZXRzID0gW1xuICAnaW5pdF9jb21wbGV0ZScsICdpc19yZWNvZ25pemVkX2NvbXBsZXRlJywgJ2F1dGhfY29tcGxldGUnLCAnZ2V0X3NyY19wcm9maWxlX2NvbXBsZXRlJywgJ2NoZWNrb3V0X2NvbXBsZXRlJywgJ3VuYmluZF9jb21wbGV0ZSdcbl07XG5cbmV4cG9ydCBjb25zdCByZXNldFVpID0gKCkgPT4ge1xuICB3aW5kb3cub3RwX2xpc3RlbmVyID0gZmFsc2U7XG5cbiAgdGFyZ2V0cy5mb3JFYWNoKGlkID0+IHtcbiAgICBnZWwoaWQpLmNoZWNrZWQgPSBmYWxzZTtcbiAgICBnZWwoYCR7aWR9X3RpbWluZ2ApLmlubmVySFRNTCA9ICcnO1xuICB9KTtcblxuICBBcnJheShxc2EoJy5tZXNzYWdpbmcnKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gIH0pO1xuXG4gIGdlbCgnYXV0aF9icmVha2Rvd24nKS5pbm5lckhUTUwgPSAnJztcbiAgZ2VsKCdlcnJvcl9sb2cnKS5pbm5lckhUTUwgPSAnJztcbiAgZ2VsKCdiZW5jaG1hcmtfZGF0YScpLnZhbHVlID0gJyc7XG4gIGdlbCgnb3RwX2VudHJ5Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZ2VsKCdwYXNzX2ZhaWwnKS5pbm5lckhUTUwgPSAnJztcbiAgZ2VsKCdwYXNzX2ZhaWwnKS5jbGFzc0xpc3QucmVtb3ZlKCdwYXNzJywgJ2ZhaWwnKTtcblxuICBmb3IgKGxldCBrIGluIGJlbmNobWFyaykge1xuICAgIGJlbmNobWFya1trXSA9IDA7XG4gIH1cblxuICAvLyBCSU4gc2VsZWN0b3JcbiAgaWYgKGNhblVzZVRlc3RDYXJkQXBpKCkpIHtcbiAgICBnZWwoJ2Jpbl9zZWxlY3RvcicpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICB9XG5cbiAgLy8gY29tcGxpYW5jZSBjYlxuICBpZiAoZ2VsKCdjb21wbGlhbmNlX3RvZ2dsZScpLmNoZWNrZWQpIHtcbiAgICBjb25zb2xlLmxvZygnLi4uaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzJyk7XG4gICAgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coJy4uLnJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncycpO1xuICAgIHJlbW92ZUNvbXBsaWFuY2VTZXR0aW5ncygpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjYXRjaEVyciwgZ2VsLCBxcyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgY2FuVXNlVGVzdENhcmRBcGkgfSBmcm9tICcuL2Nhbi11c2UtdGVzdC1jYXJkcy1hcGknO1xuZXhwb3J0IHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtYW51YWwsIGRvbid0IHVzZSBoZWxwZXJzIGhlcmVcbiAgICB2YXIgZmxvd1R5cGUgPSBxcygnaW5wdXRbbmFtZT1cImZsb3dfc2VsZWN0b3JcIl06Y2hlY2tlZCcpO1xuICAgIGlmICghZmxvd1R5cGUpIHtcbiAgICAgICAgY2F0Y2hFcnIoJ1NlbGVjdCBhIEZsb3cgdG8gc3RhcnQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZWRnZS1jYXNlcywgbm8gbG9jYWxTdG9yYWdlIHZhbHVlcyBzZXRcbiAgICB2YXIgc2RrVXJsID0gZ2VsKCdzZGtfcGlja2VyX3YzJyk7XG4gICAgdmFyIGVtYWlsID0gZ2VsKCdlbWFpbElucHV0Jyk7XG4gICAgdmFyIHJldHVybmluZ0Zsb3cgPSBnZWwoJ3JldHVybmluZ19mbG93Jyk7XG4gICAgdmFyIHBhbkpzb24gPSBnZWwoJ3Bhbl9qc29uJyk7XG4gICAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2RrJykgJiYgc2RrVXJsKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzZGsnLCBzZGtVcmwudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbWFpbCcpICYmIGVtYWlsKSB7XG4gICAgICAgIGlmIChlbWFpbCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtYWlsJywgZW1haWwudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXR1cm5pbmdGbG93LmNoZWNrZWQgPT09IGZhbHNlICYmXG4gICAgICAgICFjYW5Vc2VUZXN0Q2FyZEFwaSgpICYmIHBhbkpzb24udmFsdWUgPT09ICcnKSB7XG4gICAgICAgIGNhdGNoRXJyKCdQbGVhc2UgZ2VuZXJhdGUgYSB0ZXN0IGNhcmQgYmVmb3JlIHByb2NlZWRpbmcuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiaW1wb3J0IHsgY2F0Y2hFcnIsIGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBiZW5jaG1hcmssIGluaXREYXRhIH0gZnJvbSBcIi4uL3N0dWJzL2RhdGEuanNcIjtcbmltcG9ydCB7IGdldE1lcmNoYW50QXBpS2V5IH0gZnJvbSAnLi4vaGVscGVycy9nZXQta2V5cy50cyc7XG5pbXBvcnQgeyBzZXRQYXNzRmFpbCB9IGZyb20gXCIuLi91aS9ldmVudC1oYW5kbGVycy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdChhZGFwdGVyLCBzdGFydFRpbWUpIHtcbiAgY29uc29sZS5sb2coJ1tJTklUXSBzdGFydCcpO1xuICAvLyBjb25zdCBhcGlrZXkgPSBnZXRNZXJjaGFudEFwaUtleSgpO1xuICAvLyBpZiAoYXBpa2V5KSB7XG4gIC8vICAgaW5pdERhdGEuYXBpa2V5ID0gYXBpa2V5O1xuICAvLyB9XG5cbiAgY29uc29sZS5sb2coJ1tJTklUX0RBVEFdJywgaW5pdERhdGEpO1xuXG4gIGF3YWl0IGFkYXB0ZXIuaW5pdChpbml0RGF0YSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBiZW5jaG1hcmsuaW5pdCA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgY29uc29sZS5sb2coYFtpbml0XSB0dGFrZW46ICR7KGJlbmNobWFyay5pbml0KX1tc2AsIHJlc3BvbnNlKTtcblxuICAgIGlmICghT2JqZWN0LmtleXMocmVzcG9uc2UpLmxlbmd0aCkge1xuICAgICAgZ2VsKCdpbml0X2NvbXBsZXRlJykuY2hlY2tlZCA9IHRydWU7XG4gICAgICBnZWwoJ2luaXRfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7KGJlbmNobWFyay5pbml0KX1tc2A7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgc2V0UGFzc0ZhaWwoJ0ZBSUwnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdpbml0IGZhaWxlZCwgY2hlY2sgY29uc29sZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSkuY2F0Y2goY2F0Y2hFcnIpO1xufVxuIiwiXG5pbXBvcnQgeyBjYXRjaEVyciwgZ2VsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJlbmNobWFyayB9IGZyb20gXCIuLi9zdHVicy9kYXRhLmpzXCI7XG5pbXBvcnQgeyBzZXRQYXNzRmFpbCB9IGZyb20gXCIuLi91aS9ldmVudC1oYW5kbGVycy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNSZWNvZ25pemVkKGFkYXB0ZXIpIHtcbiAgY29uc29sZS5sb2coJ1tSRUNPR05JWkVdIHN0YXJ0Jyk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgbGV0IHRva2VuO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFkYXB0ZXIuaXNSZWNvZ25pemVkKCkuY2F0Y2goY2F0Y2hFcnIpO1xuICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBiZW5jaG1hcmsuaXNSZWNvZ25pemVkID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICBnZWwoJ2lzX3JlY29nbml6ZWRfY29tcGxldGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgZ2VsKCdpc19yZWNvZ25pemVkX2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAke2JlbmNobWFyay5pc1JlY29nbml6ZWR9bXNgO1xuXG4gIGlmIChyZXNwb25zZS5pZFRva2Vucykge1xuICAgIHRva2VuID0gcmVzcG9uc2UuaWRUb2tlbnNbMF07XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UucmVjb2duaXplZCA9PT0gZmFsc2UpIHtcbiAgICBnZWwoJ2lzX3JlY29nbml6ZWRfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7YmVuY2htYXJrLmlzUmVjb2duaXplZH1tcyAodW5yZWNvZ25pemVkKWA7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICB9XG5cbiAgY29uc29sZS5sb2coYFtyZWNvZ25pemVkXSB0dGFrZW46ICR7KGJlbmNobWFyay5pc1JlY29nbml6ZWQpfW1zYCk7XG4gIHJldHVybiB0b2tlbjtcbn1cbiIsIi8qXG4gIGNhbm5vdCBpbXBvcnQgdXRpbCBmcm9tIHZpc2Etc2RrOyBjb3BpZWQgdXRpbCBvdmVyIGZvciBub3dcbiovXG5cblxuLy8gVGhpcyBkdW1teSBVUkwgaXMgdXBkYXRlZCBieSBhIGRlcGxveSBzY3JpcHQgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LiBFLmcuXG4vLyB3aGVuIGRlcGxveWluZyB0byBwcm9kdWN0aW9uLCBDSSByZXBsYWNlcyBkZXYud3d3LnYubWUgd2l0aFxuLy8gc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tLCBidXQgd2hlbiBkZXBsb3lpbmcgdG8gY2VydCwgaXQgd2lsbCBiZVxuLy8gY2VydC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20uXG5leHBvcnQgY29uc3QgU1RBVElDX1JPT1RfRE9NQUlOID0gJ2h0dHBzOi8vZGV2Lnd3dy52Lm1lJztcblxuY29uc3Qgc2RrU2NyaXB0UmVnZXggPVxuICAvXmh0dHBzOlxcL1xcL1tcXHctXFwuXStcXC4/XFwudmlzYVxcLmNvbVxcL2NoZWNrb3V0XFwtd2lkZ2V0XFwvcmVzb3VyY2VzXFwvanNcXC9zcmMtaS1hZGFwdGVyXFwvdmlzYVtcXC1zU117MSwyfWRrXFwuanMvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U0RLU2NyaXB0RWwoKSB7XG4gIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblxuICBmb3IgKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKSB7XG4gICAgaWYgKHNjcmlwdC5zcmMubWF0Y2goc2RrU2NyaXB0UmVnZXgpKSB7XG4gICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBhc3NldHNNYXAgPSB7XG4gICcvL2Fzc2V0cy5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nOiAnLy9zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nLFxuICAnLy9jZXJ0LWFzc2V0cy5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nOiAnLy9jZXJ0LnNlY3VyZS5jaGVja291dC52aXNhLmNvbScsXG4gICcvL3NhbmRib3gtYXNzZXRzLnNlY3VyZS5jaGVja291dC52aXNhLmNvbSc6ICcvL3NhbmRib3guc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tJ1xufTtcblxuZnVuY3Rpb24gbWFwQXNzZXRzVXJsKHVybCkge1xuICBjb25zdCBhc3NldERvbWFpbnMgPSBPYmplY3Qua2V5cyhhc3NldHNNYXApO1xuXG4gIGZvciAoY29uc3QgYXNzZXREb21haW4gb2YgYXNzZXREb21haW5zKSB7XG4gICAgaWYgKHVybC5pbmRleE9mKGFzc2V0RG9tYWluKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB1cmwucmVwbGFjZShhc3NldERvbWFpbiwgYXNzZXRzTWFwW2Fzc2V0RG9tYWluXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLy8gUm9vdCBkb21haW4gaXMgdXBkYXRlZCBieSBhIGRlcGxveSBzY3JpcHQgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LiBFLmcuXG4vLyB3aGVuIGRlcGxveWluZyB0byBwcm9kdWN0aW9uLCBDSSByZXBsYWNlcyBkZXYud3d3LnYubWUgd2l0aFxuLy8gc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tLCBidXQgd2hlbiBkZXBsb3lpbmcgdG8gY2VydCwgQ0kgdXNlc1xuLy8gY2VydC5zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20uXG5jb25zdCBkdW1teVVybEhhc2ggPSAnYUhSMGNITTZMeTlrWlhZdWQzZDNMbll1YldVJzsgLy8gYnRvYSgnaHR0cHM6Ly9kZXYud3d3LnYubWUnKVxuY29uc3Qgd2FzRHVtbXlVcmxSZXBsYWNlZCA9IFNUQVRJQ19ST09UX0RPTUFJTiAhPT0gd2luZG93LmF0b2IoZHVtbXlVcmxIYXNoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Um9vdERvbWFpbigpIHtcbiAgaWYgKHdhc0R1bW15VXJsUmVwbGFjZWQpIHtcbiAgICByZXR1cm4gU1RBVElDX1JPT1RfRE9NQUlOO1xuICB9XG5cbiAgLy8gSW4gY29udGFpbmVyIGRlcGxveW1lbnRzLCB0aGUgZHVtbXkgdXJsIG1heSBub3QgaGF2ZSBiZWVuIHJlcGxhY2VkLiBJbiB0aGlzXG4gIC8vIGNhc2Ugd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlIGVudmlyb25tZW50IHVybCBmcm9tIHRoZSB2aXNhU2RrLmpzIHNjcmlwdCB0YWcuXG5cbiAgY29uc3Qgc2RrU2NyaXB0RWwgPSBnZXRTREtTY3JpcHRFbCgpO1xuXG4gIGlmIChzZGtTY3JpcHRFbCkge1xuICAgIHJldHVybiBtYXBBc3NldHNVcmwoc2RrU2NyaXB0RWwuc3JjLnNwbGl0KCcvJywgMykuam9pbignLycpKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgdG8gdGhlIHByb2QgVVJMIGZvciBhbnkgYWJub3JtYWwgaW50ZWdyYXRpb24uXG4gIHJldHVybiAnaHR0cHM6Ly9zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nO1xufVxuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSAnLi4vaGVscGVycy91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRTREtTY3JpcHRFbCB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0LXJvb3QtZG9tYWluLmpzJztcblxuY29uc3QgbG9hZFNkayA9IChzZGtVcmwsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGxvYWRTdGFydCA9IERhdGUubm93KCk7XG4gIGxldCBzZGtNb3VudCA9IGdldFNES1NjcmlwdEVsKCk7XG4gIGxldCB0YWc7XG5cbiAgaWYgKHNka01vdW50KSB7XG4gICAgY29uc29sZS5pbmZvKCc+Pj4+IHJlbW92aW5nIDxzY3JpcHQgLz4gdGFnIGZyb20gcHJpb3IgbG9hZCcpO1xuICAgIHNka01vdW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2RrTW91bnQpO1xuICB9XG5cbiAgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgdGFnLnNyYyA9IHNka1VybDtcbiAgdGFnLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgdGFnLmFzeW5jID0gZmFsc2U7XG4gIHRhZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgY2FsbGJhY2sobG9hZFN0YXJ0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgZ2VsKCdlcnJvcl9sb2cnKS5pbm5lckhUTUwgPSBlcnI7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAoaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZCh0YWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsb2FkU2RrO1xuIiwiaW1wb3J0IHsgYmVuY2htYXJrIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5pbXBvcnQgeyBnZWwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgbGV0IHN0YXJ0VGltZTtcblxuZXhwb3J0IGNvbnN0IHNldFN0YXJ0VGltZSA9ICgpID0+IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVCZW5jaG1hcmtzID0gKCkgPT4gZ2VsKCdiZW5jaG1hcmtfZGF0YScpLnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoYmVuY2htYXJrLCBudWxsLCAyKTtcbiIsImNvbnN0IGdlbklkID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuZXhwb3J0IGNvbnN0IHN5c3RlbUNvcnJlbGF0aW9uSWQgPSBgMV8xNDkyNTYxMTExXzc2Nl80OF8ke2dlbklkKCl9X0NIRUNLT1VULVdJREdFVGA7XG5leHBvcnQgY29uc3Qgc3lzdGVtU2Vzc2lvbklkID0gYHZtZV9xYV8wMDEke2dlbklkKCl9YDtcblxuZXhwb3J0IHZhciBmZXRjaFJlcSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgYm9keSxcbiAgICBtZXRob2QsXG4gICAgaGVhZGVyc1xuICB9ID0gb3B0aW9ucztcbiAgaGVhZGVyc1snWC1DT1JSRUxBVElPTi1JRCddID0gc3lzdGVtQ29ycmVsYXRpb25JZDtcbiAgaGVhZGVyc1snZGZwU2Vzc2lvbklkJ10gPSBzeXN0ZW1TZXNzaW9uSWQ7XG4gIGhlYWRlcnNbJ1gtVEhNSUQnXSA9IHN5c3RlbVNlc3Npb25JZDtcblxuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICBsZXQgZmluYWxCb2R5ID0ge307XG5cbiAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCd4LXd3dy1mb3JtLXVybGVuY29kZWQnKSkge1xuICAgIGZpbmFsQm9keSA9IHNlcmlhbGl6ZU9iamVjdChib2R5KTtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgfVxuICByZXR1cm4gZmV0Y2goXG4gICAgICB1cmwsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIGJvZHk6IGZpbmFsQm9keSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIG1ldGhvZFxuICAgICAgfSlcbiAgICApXG4gICAgLnRoZW4ocmVzID0+IGhhbmRsZUpzb25SZXNwb25zZShyZXMpKVxuICAgIC50aGVuKGRhdGEgPT4gZGF0YSlcbiAgICAuY2F0Y2goZXJyb3IgPT4ge3JldHVybiBlcnJvcn0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVKc29uUmVzcG9uc2UocmVzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgcmVzLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgIGhlYWRlcnNba10gPSB2O1xuICB9KTtcbiAgLy8gY29uc29sZS5sb2coJ2hlYWRlcnMgLSAnICsgSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpO1xuICByZXR1cm4gKFxuICAgIHJlc1xuICAgIC5qc29uKClcbiAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgY29uc29sZS5sb2coJ2RhdGEnLCBkYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgIH1cbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICB9XG4gICAgfSkpXG59O1xuXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmopIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgcyA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG9ialtrZXldICYmIG9ialtrZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgb2JqW2tleV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzLmpvaW4oJyYnKTtcbn07XG4iLCJpbXBvcnQgeyBiZW5jaG1hcmtTdGF0ZSB9IGZyb20gJy4uL3N0dWJzL2RhdGEuanMnO1xuaW1wb3J0IHsgc2V0UGFzc0ZhaWwgfSBmcm9tICcuLi91aS9ldmVudC1oYW5kbGVycy5qcyc7XG5pbXBvcnQgeyBmZXRjaFJlcSwgaGFuZGxlSnNvblJlc3BvbnNlIH0gZnJvbSAnLi9mZXRjaC5qcyc7XG5pbXBvcnQgeyBleHRyYWN0SG9zdG5hbWUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxubGV0IGlzUUFQZXJmID0gZmFsc2U7XG5jb25zdCB1c2VQcm94eSA9IHRydWU7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPVFAoZW1haWwpIHtcbiAgY29uc29sZS5pbmZvKCdAZ2V0T1RQIC0gYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBPVFAgY29kZSB2aWEgQVBJJyk7XG5cbiAgaXNRQVBlcmYgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2RrJykuaW5kZXhPZigncWFwZXJmJykgPiAtMTtcblxuICBpZiAoaXNRQVBlcmYpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2lkP2VtYWlsPSR7ZW1haWx9YCkudGhlbihoYW5kbGVKc29uUmVzcG9uc2UpO1xuXG4gICAgaWYgKHJlcy5kYXRhLnV1aWQpIHtcbiAgICAgIC8vIHNoYTI1NiBoYXNoIG9mIFVVSUQgKyBlbWFpbFxuICAgICAgLy8gbm8gdHJhbnNwaWxlIG9mIG5vZGUgY29kZSwgbGV2ZXJhZ2Ugc2ltcGxlIEFQSVxuICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IGZldGNoKGAvc2hhP3M9JHtyZXMuZGF0YS51dWlkfSR7ZW1haWwudG9Mb3dlckNhc2UoKX1gKS50aGVuKGhhbmRsZUpzb25SZXNwb25zZSk7XG4gICAgICAvLyBiYXNlNjQgZW5jb2RlIHNoYXN1bVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gYnRvYShoYXNoLmRhdGEuc2hhMjU2KTtcbiAgICAgICAgY29uc3Qgb3RwQm9keSA9IGF3YWl0IGZldGNoKGAvb3RwP2VuY3J5cHRlZD0ke2VuY3J5cHRlZH1gKS50aGVuKGhhbmRsZUpzb25SZXNwb25zZSk7XG4vLyBjb25zb2xlLmxvZygnb3RwJywgb3RwQm9keSk7UVxuXG4gICAgICAgIGlmIChvdHBCb2R5LmRhdGEub3RwVmFsdWUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgZ290IE9UUCB2YWx1ZSBbJHtvdHBCb2R5LmRhdGEub3RwVmFsdWV9XWApO1xuICAgICAgICAgIHJldHVybiBvdHBCb2R5LmRhdGEub3RwVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgc2V0UGFzc0ZhaWwoJ0ZBSUwnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT1RQIGZldGNoIGZhaWxlZGApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdG9rZW47XG4gICAgY29uc3QgcHJveHkgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX06JHt3aW5kb3cubG9jYXRpb24ucG9ydH0vcHJveHlgO1xuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3Zib3g2NzEuc2VjdXJlLmNoZWNrb3V0LnZpc2EuY29tL3NyY3Nka3Rlc3Rlci9nZW5lcmF0ZU90cCc7XG4gIFxuICAgIGNvbnN0IGVudmlyb25tZW50ID0gZXh0cmFjdEhvc3RuYW1lKGJlbmNobWFya1N0YXRlLnNka1VybCk7XG4gICAgLy8gY29uc29sZS5sb2coXCJFbnZpcm9ubWVudDpcIiwgZW52aXJvbm1lbnQpO1xuICBcbiAgICAvLyBNYWtlIGluZGlyZWN0IGNhbGwgdG8gZ2V0IE9UUFxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiB1c2VQcm94eSA/IGAke3Byb3h5fT91cmw9JHt1cmx9YCA6IHVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04JyxcbiAgICAgICAgJ2Vudm4nOiBlbnZpcm9ubWVudCxcbiAgICAgICAgJ2VtYWlsJzogZW1haWwsXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoUmVxKG9wdGlvbnMpLmNhdGNoKGVyciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdnZXRPVFAgZXJyb3I6JywgZXJyKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmRhdGEub3RwVmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YS5vdHBWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBjb3VsZCBub3QgYXV0b2dldCBPVFAgY29kZSBmcm9tIFske3VybH1dYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJcbmV4cG9ydCBjb25zdCBjYW5Vc2VPdHBBcGkgPSAoKSA9PiB7XG4gIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICBjb25zdCBzZGtVcmwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2RrJyk7XG5cbiAgc3dpdGNoKHRydWUpIHtcbiAgICBjYXNlIChob3N0bmFtZS5pbmRleE9mKCdnaXRodWInKSA+IC0xKTpcbiAgICBjYXNlIChob3N0bmFtZS5pbmRleE9mKCdoZXJva3UnKSA+IC0xKTpcbiAgICBjYXNlIChzZGtVcmwgJiYgc2RrVXJsLmluZGV4T2YoJ3FhcGVyZicpID4gLTEpOlxuICAgIGNhc2UgKGhvc3RuYW1lLmluZGV4T2YoJ2xvY2FsaG9zdCcpID4gLTEpOlxuICAgIGNhc2UgKGhvc3RuYW1lLmluZGV4T2YoJzEyNy4wLjAuMScpID4gLTEpOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgeyBiZW5jaG1hcmssIHVzZXJJbmZvIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5pbXBvcnQgeyBnZXRPVFAgfSBmcm9tICcuLi9oZWxwZXJzL2dldC1vdHAuanMnO1xuaW1wb3J0IHsgY2FuVXNlT3RwQXBpIH0gZnJvbSAnLi4vaGVscGVycy9jYW4tdXNlLW90cC1hcGkuanMnO1xuaW1wb3J0IHsgY2F0Y2hFcnIsIGdlbCB9IGZyb20gJy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RhcnRUaW1lIH0gZnJvbSAnLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qcyc7XG5pbXBvcnQgeyBzZXRQYXNzRmFpbCB9IGZyb20gJy4uL3VpL2V2ZW50LWhhbmRsZXJzLmpzJztcblxubGV0IGlzUUFQZXJmO1xuXG53aW5kb3cub3RwX2xpc3RlbmVyID0gZmFsc2U7XG5cblxuXG5hc3luYyBmdW5jdGlvbiBzdWJtaXRPdHAob3RwQ29kZSkge1xuICBjb25zb2xlLmluZm8oJy0tLS0gc3VibWl0T3RwJyk7XG4gIGNvbnN0IGNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uU3RhcnQgPSBEYXRlLm5vdygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbih3aW5kb3cuYzJwX2FkYXB0ZXIsIHtcbiAgICB2YWxpZGF0aW9uRGF0YTogb3RwQ29kZVxuICB9KS5jYXRjaChjYXRjaEVycik7XG4gIGJlbmNobWFyay5jb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbiA9IERhdGUubm93KCkgLSBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvblN0YXJ0O1xuXG4gIGdlbCgnYXV0aF9jb21wbGV0ZScpLmNoZWNrZWQgPSB0cnVlO1xuICBnZWwoJ2F1dGhfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7KGJlbmNobWFyay5pZGVudGl0eUxvb2t1cCArIGJlbmNobWFyay5pbml0aWF0ZUlkZW50aXR5VmFsaWRhdGlvbiArIGJlbmNobWFyay5jb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbikgLyAxMDAwfXNgO1xuICBnZWwoJ2F1dGhfYnJlYWtkb3duJykuaW5uZXJIVE1MID0gYFsgaWRlbnRpdHlMb29rdXA6ICR7YmVuY2htYXJrLmlkZW50aXR5TG9va3VwfW1zIF08YnIvPlsgaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb246ICR7YmVuY2htYXJrLmluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9ufW1zIF08YnIvPlsgY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb246ICR7YmVuY2htYXJrLmNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9ufW1zIF1gO1xuXG4gIGNvbnNvbGUubG9nKGAvcHJvYmVgLCByZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZUlkZW50aXR5VmFsaWRhdGlvbihhZGFwdGVyLCBjb2RlKSB7XG4gIGNvbnNvbGUubG9nKFwiQGNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uIC0gVmFsaWRhdGlvbiBEYXRhID0+IFwiLCBjb2RlKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmNvbXBsZXRlSWRlbnRpdHlWYWxpZGF0aW9uKGNvZGUpLmNhdGNoKGNhdGNoRXJyKTtcbiAgY29uc29sZS5sb2coYC0tLS0gY29tcGxldGVJZGVudGl0eVZhbGlkYXRpb24gLSByZXNwb25zZWAsIHJlc3BvbnNlKTtcblxuICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChyZXNwb25zZVsncmVhc29uJ10pIHtcbiAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHZlcmlmeSBPVFA6ICVvJywgcmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBmcm9tIFZlcmlmeSBPVFA6ICVvJywgcmVzcG9uc2UpO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb24oYWRhcHRlcikge1xuICBjb25zb2xlLmxvZygnQGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uJyk7XG4gIHJldHVybiBhd2FpdCBhZGFwdGVyLmluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uKCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgcmVzcG9uc2UgZnJvbSBpbml0aWF0ZUlkZW50eVZhbGlkYXRpb25gLCByZXNwb25zZSk7XG4gICAgaWYgKHJlc3BvbnNlWydyZWFzb24nXSkge1xuICAgICAgc2V0UGFzc0ZhaWwoJ0ZBSUwnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgSWRlbnRpdHkgdmFsaWRhdGlvbiwgZXJyb3I6ICVvJywgcmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0pLmNhdGNoKGNhdGNoRXJyKTtcbn1cblxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRoRmxvdyhhZnRlckF1dGgsIHVwZGF0ZUJlbmNobWFya3MpIHtcbiAgY29uc29sZS5sb2coJ1tBVVRIX0ZMT1ddIHN0YXJ0Jyk7XG4gIGxldCBvdHBDb2RlO1xuICBjb25zdCBlbWFpbCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbWFpbCcpO1xuXG4gIC8vIGlkTG9va3VwXG4gIGNvbnN0IGlkZW50aXR5TG9va3VwU3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gIGNvbnNvbGUubG9nKCctLSBzdGFydGluZyBhc3luYyBpZGVudGl0eUxvb2t1cCcpO1xuICBjb25zdCByZXMgPSBhd2FpdCB3aW5kb3cuYzJwX2FkYXB0ZXIuaWRlbnRpdHlMb29rdXAoe1xuICAgIGlkZW50aXR5UHJvdmlkZXI6IFwiU1JDXCIsXG4gICAgaWRlbnRpdHlWYWx1ZTogZW1haWwsXG4gICAgdHlwZTogXCJFTUFJTFwiXG4gIH0pLmNhdGNoKGNhdGNoRXJyKTtcbiAgY29uc29sZS5sb2coJy0tIGlkZW50aXR5TG9va3VwIHJldHVybicsIHJlcyk7XG5cbiAgYmVuY2htYXJrLmlkZW50aXR5TG9va3VwID0gRGF0ZS5ub3coKSAtIGlkZW50aXR5TG9va3VwU3RhcnQ7XG4gIHVwZGF0ZUJlbmNobWFya3MoKTtcblxuICBpZiAocmVzLmVycm9yKSB7XG4gICAgc2V0UGFzc0ZhaWwoJ0ZBSUwnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzLCBudWxsLCAyKSk7XG4gIH0gZWxzZSBpZiAocmVzLmNvbnN1bWVyUHJlc2VudCB8fCByZXMuYWNjZXNzVG9rZW4pIHtcbiAgICAvLyByZWlzc3VhbmNlXG4gICAgY29uc29sZS5sb2coJy0tLSByZWlzc3VhbmNlJyk7XG4gICAgY29uc3QgaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb25TdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaW5pdGlhdGVJZGVudGl0eVZhbGlkYXRpb24od2luZG93LmMycF9hZGFwdGVyKS5jYXRjaChjYXRjaEVycik7XG4gICAgYmVuY2htYXJrLmluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uID0gRGF0ZS5ub3coKSAtIGluaXRpYXRlSWRlbnRpdHlWYWxpZGF0aW9uU3RhcnQ7XG4gICAgYmVuY2htYXJrLlVJVVhfdG9fT1RQID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICB1c2VySW5mby5PVFBfcGVyZm9ybWVkID0gdHJ1ZTtcbiAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG5cbiAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHJlcywgbnVsbCwgMikpO1xuICAgIH0gZWxzZSBpZiAocmVzICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGNhblVzZU90cEFwaSgpID09PSBmYWxzZSkge1xuICAgICAgICBpZiAod2luZG93Lm90cF9saXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnaW5zdGFudGlhdGluZyBtYW51YWwgT1RQIGZvcm0nKVxuICAgICAgICAgIHdpbmRvdy5vdHBfbGlzdGVuZXIgPSB0cnVlO1xuXG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBjb25zdCBvdHAgPSBnZWwoJ290cF92YWx1ZScpLnZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE9UUCBzdWJtaXR0ZWQgWyR7b3RwfV1gKTtcblxuICAgICAgICAgICAgaWYgKG90cCkge1xuICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBzdWJtaXRPdHAob3RwKS5jYXRjaChjYXRjaEVycik7XG4gICAgICAgICAgICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcblxuICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgLy8gdmlzYS1zZGsgPiAyMy4wNy4wMCBubyBsb25nZXIgcmV0dXJucyBpZFRva2VuP1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gcmVzPy5pZFRva2VuIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZnRlckF1dGgod2luZG93LmMycF9hZGFwdGVyLCB0b2tlbikuY2F0Y2goY2F0Y2hFcnIpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhdGNoRXJyKCdObyBPVFAgdmFsdWUgZGV0ZWN0ZWQuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ2xvYmFsSGFuZGxlciA9IGFzeW5jIGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuc3JjRWxlbWVudC5pZCA9PT0gJ290cF9zdWJtaXQnKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2hvdyBPVFAgZmllbGQgKyBidXR0b25cbiAgICAgICAgICB3aW5kb3cuX21hbnVhbF9vdHAgPSB0cnVlO1xuICAgICAgICAgIGdlbCgnb3RwX2VudHJ5Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnbG9iYWxIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ21hbnVhbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnLS0tIGF1dG9tYXRpYyBPVFAgc2hvd24nKTtcbiAgICAgICAgb3RwQ29kZSA9IGF3YWl0IGdldE9UUChlbWFpbCk7XG5cbiAgICAgICAgLy8gbWFudWFsbHkgZW50ZXIgZm9yIHNhbmRib3grXG4gICAgICAgIGlmICghb3RwQ29kZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0gcHJvbXB0IE9UUCBzaG93bicpO1xuICAgICAgICAgIG90cENvZGUgPSBhd2FpdCBwcm9tcHQoJ0VudGVyIE9UUCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJtaXRPdHAob3RwQ29kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5pbmZvKCdbQVVUSF9GTE9XXSBjb25zdW1lciBub3QgcHJlc2VudCcpO1xuICByZXR1cm4gcmVzO1xufVxuIiwiaW1wb3J0IHsgZ2VsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGF1dG9GaWxsRW1haWxBZGRyZXNzSW5DaGVja291dEFwaXJlcXVlc3QgfSBmcm9tICcuLi9oZWxwZXJzL2VtYWlsLmpzJztcbmltcG9ydCB7IGJlbmNobWFyaywgZ2V0SW50ZW50UGF5bG9hZCwgdXNlckluZm8gfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuaW1wb3J0IHsgc2V0UGFzc0ZhaWwgfSBmcm9tICcuLi91aS9ldmVudC1oYW5kbGVycy5qcyc7XG5pbXBvcnQgeyBzdGFydFRpbWUgfSBmcm9tIFwiLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tvdXQoYWRhcHRlcikge1xuICBjb25zdCBpbnRlbnRQYXlsb2FkID0gZ2V0SW50ZW50UGF5bG9hZCgpO1xuICBjb25zb2xlLmxvZygnW0NIRUNLT1VUXSBzdGFydCcpO1xuICBjb25zdCBlbWFpbCA9IGdlbCgnZW1haWxJbnB1dCcpLnZhbHVlO1xuICBhdXRvRmlsbEVtYWlsQWRkcmVzc0luQ2hlY2tvdXRBcGlyZXF1ZXN0KGVtYWlsKTtcblxuICBjb25zb2xlLmxvZygnLS0gaW50ZW50IHBheWxvYWQnLCBpbnRlbnRQYXlsb2FkKTtcbiAgY29uc3QgZW5yb2xsU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmNoZWNrb3V0KGludGVudFBheWxvYWQpO1xuICBjb25zdCBlbnJvbGxFbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBiZW5jaG1hcmsuY2hlY2tvdXQgPSBlbnJvbGxFbmRUaW1lIC0gZW5yb2xsU3RhcnRUaW1lO1xuXG4gIGlmICh1c2VySW5mby5jYXJkTGlzdF9wZXJmb3JtZWQgPT09IGZhbHNlICYmIHVzZXJJbmZvLk9UUF9wZXJmb3JtZWQgPT09IGZhbHNlKSB7XG4gICAgYmVuY2htYXJrLlVJVVhfZW5yb2xsTmV3VXNlciA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIH1cblxuICBjb25zb2xlLmxvZyhgW2NoZWNrb3V0XSB0dGFrZW46ICR7KGJlbmNobWFyay5jaGVja291dCl9bXNgKTtcbiAgXG4gIGlmIChyZXNwb25zZS5lcnJvciB8fCByZXNwb25zZVsncmVhc29uJ10pIHtcbiAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICB9IGVsc2Uge1xuICAgIGdlbCgnY2hlY2tvdXRfY29tcGxldGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICBnZWwoJ2NoZWNrb3V0X2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAkeyhiZW5jaG1hcmsuY2hlY2tvdXQpfW1zYDtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59XG4iLCJcbmltcG9ydCB7IGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBzdGFydFRpbWUgfSBmcm9tICcuLi9oZWxwZXJzL3VwZGF0ZS1iZW5jaG1hcmtzLmpzJztcbmltcG9ydCB7IGJlbmNobWFyaywgZ2V0SW50ZW50UGF5bG9hZCwgc3JjUHJvZmlsZXMsIHVzZXJJbmZvIH0gZnJvbSBcIi4uL3N0dWJzL2RhdGEuanNcIjtcbmltcG9ydCB7IHNldFBhc3NGYWlsIH0gZnJvbSAnLi4vdWkvZXZlbnQtaGFuZGxlcnMuanMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3JjUHJvZmlsZShhZGFwdGVyLCBhdXRoVG9rZW4pIHtcbiAgY29uc29sZS5sb2coJ1tHRVRfU1JDX1BST0ZJTEVdIHN0YXJ0Jyk7XG4gIGNvbnN0IGludGVudFBheWxvYWQgPSBnZXRJbnRlbnRQYXlsb2FkKCk7XG5cbiAgY29uc3QgZ3NwU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGFwdGVyLmdldFNyY1Byb2ZpbGUoYXV0aFRva2VuKTtcbiAgY29uc3QgZ3NwRW5kVGltZSA9IERhdGUubm93KCk7XG4gIGJlbmNobWFyay5nZXRTcmNQcm9maWxlID0gZ3NwRW5kVGltZSAtIGdzcFN0YXJ0VGltZTtcbiAgdXNlckluZm8uY2FyZExpc3RfcGVyZm9ybWVkID0gdHJ1ZTtcblxuICBpZiAodXNlckluZm8uT1RQX3BlcmZvcm1lZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBvbmx5IG1hcmsgVFRGSSBmb3IgQ0wgaWYgT1RQIGhhcyBub3QgYmVlbiBzZW50L3N1Ym1pdHRlZFxuICAgIGJlbmNobWFyay5VSVVYX3RvX2NhcmRMaXN0ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgfVxuICBjb25zb2xlLmxvZyhgW2dldFNyY1Byb2ZpbGVdIHR0YWtlbjogJHsoYmVuY2htYXJrLmdldFNyY1Byb2ZpbGUpfW1zYCk7XG5cbiAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgc2V0UGFzc0ZhaWwoJ0ZBSUwnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpKTtcbiAgfSBlbHNlIGlmIChyZXNwb25zZVsncmVhc29uJ10pIHtcbiAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBnZXQgY2FyZCBsaXN0OiAlbycsIHJlc3BvbnNlKTtcbiAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICB9IGVsc2Uge1xuICAgIGdlbCgnZ2V0X3NyY19wcm9maWxlX2NvbXBsZXRlJykuY2hlY2tlZCA9IHRydWU7XG4gICAgZ2VsKCdnZXRfc3JjX3Byb2ZpbGVfY29tcGxldGVfdGltaW5nJykuaW5uZXJIVE1MID0gYCR7KGJlbmNobWFyay5nZXRTcmNQcm9maWxlKX1tc2A7XG4gIH1cblxuICByZXNwb25zZS5wcm9maWxlcy5mb3JFYWNoKHByb2ZpbGUgPT4gc3JjUHJvZmlsZXMucHVzaChwcm9maWxlKSk7XG5cbiAgLy8gc2V0IGZpcnN0IGNhcmRcbiAgdHJ5IHtcbiAgICBpbnRlbnRQYXlsb2FkLnNyY0RpZ2l0YWxDYXJkSWQgPSBzcmNQcm9maWxlc1swXS5tYXNrZWRDYXJkc1swXS5zcmNEaWdpdGFsQ2FyZElkO1xuICB9IGNhdGNoIChleCkge1xuICAgIGNvbnNvbGUud2FybignU1JDIFByb2ZpbGUgY29udGFpbmVkIG5vIGNhcmRzJyk7XG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKCdwcm9maWxlIG1hc2tlZCBjYXJkIG1pc3Npbmcgc3JjRGlnaXRhbENhcmRJZCcsIEpTT04uc3RyaW5naWZ5KHNyY1Byb2ZpbGVzLCBudWxsLCAyKSk7XG4gIH1cbiAgaW50ZW50UGF5bG9hZC5pZFRva2VuID0gc3JjUHJvZmlsZXNbMF0uaWRUb2tlbjtcbiAgaW50ZW50UGF5bG9hZC5zcmNDb3JyZWxhdGlvbklkID0gcmVzcG9uc2Uuc3JjQ29ycmVsYXRpb25JZDtcbiAgaW50ZW50UGF5bG9hZC5wcm9maWxlcyA9IHNyY1Byb2ZpbGVzO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn1cbiIsImltcG9ydCB7IGdlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBiZW5jaG1hcmsgfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuaW1wb3J0IHsgdXBkYXRlQmVuY2htYXJrcyB9IGZyb20gXCIuLi9oZWxwZXJzL3VwZGF0ZS1iZW5jaG1hcmtzXCI7XG5pbXBvcnQgeyBzZXRQYXNzRmFpbCB9IGZyb20gXCIuLi91aS9ldmVudC1oYW5kbGVycy5qc1wiO1xuXG5leHBvcnQgY29uc3QgdW5iaW5kID0gYXN5bmMgKGFkYXB0ZXIsIHRva2VuKSA9PiB7XG4gIGlmICh0b2tlbikge1xuICAgIGNvbnNvbGUubG9nKCdbVU5CSU5EXScpO1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFkYXB0ZXIudW5iaW5kQXBwSW5zdGFuY2Uoe30pO1xuICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XG5cbiAgICBiZW5jaG1hcmsudW5iaW5kID0gZW5kIC0gc3RhcnQ7XG5cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHNldFBhc3NGYWlsKCdGQUlMJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VsKCd1bmJpbmRfY29tcGxldGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGdlbCgndW5iaW5kX2NvbXBsZXRlX3RpbWluZycpLmlubmVySFRNTCA9IGAke2JlbmNobWFyay51bmJpbmR9bXNgO1xuXG4gICAgICBjb25zb2xlLmxvZygnVW5iaW5kIHJlc3VsdCByZWNlaXZlZCBmcm9tIFZpc2EgU1JDIFN5c3RlbScpO1xuLy8gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgRGF0YScsIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICByZXR1cm47XG59XG4iLCJleHBvcnQgY29uc3Qga2V5cyA9IHtcbiAgc2FuZGJveDoge1xuICAgIC8vIGtpZDogXCIxYmRhYjNjY1wiLFxuICAgIGtpZDogJ1Y2WVBMMERGSjJWNTZISUg2UTNGMTMzZmJaV3lBeUlIaldWU2VjeDZLTUY2aVRIR00nLCAvLyBBUElrZXkvc3JjSW5pdGlhdG9ySWRcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDY1NTM3LFxuICAgICAgbjogXCIwMDpiMTo5MzpjODpiYTpjMDpkZjplZjoyNDoyNzo5ZToxMDo2NDo1MzpkOTphZTpkNzo4NTo0ZTozYjo3MDphYjpiYToyZDpkYjplZTpiMDoxZjpkODphNjoxZTphMTpiNToxMTo5OTo3MDozNTplZDpiZDo0OTo1ZjpkODplMDpkMDoyNzo3ZTpiZTowYTo2NjpiYjoyNDplYjpjNDoxNToxMjo3MzplZToxYjpkMzplNTowZjo4MToyYzowNjoxNjphMzpkNjo1Mjo5Yzo3NDpmMDo0Yzo2YTphZjowMzpjMzozYTpmMTo2ODo4YzoxYToyZTpkYjowOTo3MjphYjpjNjpkYzpjYjo0NToyYzpmODoxNzpkZTowYjozNDo4NDplNjo1MzoxNTo3NToyNTpkMzo1ZDo3NTpkYzozNjphYjpiZTphOTpiZDpiNjo4YzoyMDo4MjoyNDowMjplOTpjNjpjMDoyYjpiMTpiYTowYzozOTo3YjowYjo3OTpkODo3NzozMzo4NTpjZDo0Mzo5NTpjNjowMjpkNDo1ZjplZDpiZjpiZTpiOTozNjozOTowZTpiZjo0YToyZDo4Yzo5NDpiZDo5Mjo4MDo5ZDo4ZDozODozMDphMjo0ZjoxMDplZTo3ODo2MjoyMjowNTozMzo5MDpkMzowMjoxMzo0ZTo5YTpjZDozYzpmNjozNzo0Yzo3NzoxZjo5NDo0NDo4Mjo4OTo4YzpmNTozNjpmOToxYTo0NzoxYjo1YjpiYzoyYzoyMTpiNDpkYjpjNDo1MzoyMjo5MzplYzozNTpiNDo1YTo5ZTplNDpiOTo0YzowNjozZjpjZTo1Yzo0Mzo4MTpiZDo2MToyODo5ZDpmYTo2MTpiNjo0NDozNDo3MjplMDpmNDpmNTpkMzowNjoxNzo0ZTozMjo1NTozZDpkMDozNDpjYjo5NTpmNzoxYjoyZDozNjpiZTowZjpiMDplMDo5NjozMDoxYTo1ODoyYjphZjpjYzpiMzpkYToxYlwiXG4gICAgfVxuICB9LFxuICBxYV9wZXJmOiB7XG4gICAgLy8ga2lkOiAnYTc0ZTIzZWUnLFxuICAgIC8vIGtpZDogJ1VCSEJONlVHU09LMVhZUVRaUE5VMTF5cnphNVlOb2FzT1EyQW9sbWFsOUJxVTNHSzQnLFxuICAgIC8vIGtpZDogJzdIS0ZPU1Y5RzUyRlBPNFZHQjkyMTFsTzFZM0U1T1BfVHVmTVFteUNqV0pLeTFONjQnLFxuICAgIC8vIGtpZDogJ0ZGSzhXSjZZSUtZNzBOQ0FRVEtaMTF1VzcxTkhkS09EcTlEbEtYNVNZcFNNNjN4QVknLFxuICAgIGtpZDogJ0w2TUxBM1AyNjNOQzhBRlVKR1c0MTF4OXFvN05WQ1VqTDkyc0VsWjN2ZElsc1NueTAnLFxuICAgIHB1YmxpY0tleToge1xuICAgICAgZTogNjU1MzcsXG4gICAgICAvLyBuOiAnY2Y6YzQ6ZGE6ZTY6YzU6ZjI6NTc6NDQ6ZTM6MzI6OTE6ZTM6MTg6YTE6ODc6ZmQ6M2I6YmU6ZjI6YWE6Njc6ZDQ6MTM6N2M6Y2Q6NTY6YmE6MTE6ZmI6OGY6Njc6Nzg6MjQ6Y2Y6YzA6NjU6NTQ6MzI6OGE6YWQ6ZDY6MTE6OWU6M2E6ZjM6Mzk6MWQ6ZmQ6YzE6OWM6MzQ6NDU6NjI6ZTg6Y2I6MjQ6NjI6ZGY6OGE6NWU6ZmY6YjI6ZjY6OGE6M2E6NWM6NjY6M2Y6YmQ6NWU6YTk6MWQ6NzM6NTY6OGY6YmY6ZDc6MTA6Y2U6OWI6MGY6M2Y6N2E6Y2Y6NGQ6MTg6YjA6MGY6OWI6Y2Q6Mjk6YzY6NmE6MDY6ZmM6Mzc6MGE6Zjc6YmQ6NDk6N2Q6ZjE6Yjc6OGU6N2Y6YWE6OWQ6MTc6Njk6MWY6ZmY6YjU6Y2Q6YTY6MjY6NDg6NDA6MDM6YmE6NTQ6N2E6NTQ6NDQ6MDI6NTU6YTQ6ZjU6YWQ6MjU6OTU6MDI6NzY6NDU6ZTA6ODI6MzU6NzA6MGU6NDk6NzE6ZjM6NzE6NzE6Yzk6MTQ6Nzk6N2Q6YWU6MWE6ZWY6OTk6Yzk6ZDE6ODY6OWI6MjA6MTE6MGU6NmE6ZWI6N2E6NjQ6Y2E6ZmM6YTI6Njk6YWU6ZmE6YmQ6ZTY6YjA6ZGQ6OTY6MDM6ZjI6ZTE6YzU6YTA6YzQ6YmY6YTk6N2M6NDE6YzU6YzY6OWI6MTA6OGY6ZTg6ODY6MDg6N2Y6M2Y6MWQ6Njk6ZWU6Nzg6M2Y6ZmM6NTI6YWM6NWM6YTI6NTE6NzY6NGI6Mzg6NmU6Mzk6ODA6N2Y6Yjk6MjQ6Njc6NjM6OWU6ZTk6ZTY6ODk6OTY6Mzk6MDg6ZmY6MmI6MTE6MTU6MGU6Zjc6ZTE6ZTg6Yzc6ZWQ6YTA6YTM6MmI6MDI6NzE6NmI6MDU6ZDg6ZmM6ODU6NWE6ZTg6YzM6NGE6M2U6MGI6ODM6MDQ6NGE6NjU6ZWU6MjM6NGU6YTcnXG4gICAgICAvLyBuOiAnMDBjNmVjMmFmNzRlOTZkMDg5MGQzYTUwY2ZiYjgwNTA1NDRmODYwNTljNTI1ZGY3YzU4MzEwM2E3ZTEzMzlkOGRiYWM4MWRkMDY1MGY4M2ZhM2U2OGIxZjFjNjc3ZTEwZGI4N2Y3MTIyMmRhYzMzODE3NzA5ZWRiMGQxYzRhY2RmYmIyY2IxZDlkNjc0ODRlOTFmNjY4OGFlOWMzZjc4YzRmNThhODA2MmNhNTMzZjg4YWMzOWRjODgzMjIyYWNlODk3NzZlMWNiYjhlZDEzOWI5NmQwYzNlN2EzYTRlNTMwYmJiMDIyMGU3MmQwOTI0MTBlYWYwOTUxZTAwOTRmYzgyMjg5ODE4MmY1YWU5ODNiZjQ0Y2IxMzZmYzNiM2JiOWI5NWZkYzQ4ZjY2ODEyYjEzNWM1ZTlkMTYwNWVmOTk2MzRhYzEyYjk5MDhjMmM1ZGMyZWJhNWMyYTczZTc3ZjAwMzJiNTk1YWEzNmM1MzZhZTc0YTEzYTYxNzFlYjBjY2Y3NjMxNGFlZDY2ZGRhNmIxYzlmNjkyYjhiOTJiZWUyNTBlOTExNGM5M2QxNjliOWNhYzFhZDEwY2EyZDFiNzkzNzFkM2RkZjRhNjk4YTJiNDAyMTdlNDNjYzQyODVjYmZlOWRlOGQxZTljMjBiMTRjYjZhMzcxMjlmOTJmN2U0ZCcsXG4gICAgICBuOiAnMDA6YzY6ZWM6MmE6Zjc6NGU6OTY6ZDA6ODk6MGQ6M2E6NTA6Y2Y6YmI6ODA6NTA6NTQ6NGY6ODY6MDU6OWM6NTI6NWQ6Zjc6YzU6ODM6MTA6M2E6N2U6MTM6Mzk6ZDg6ZGI6YWM6ODE6ZGQ6MDY6NTA6Zjg6M2Y6YTM6ZTY6OGI6MWY6MWM6Njc6N2U6MTA6ZGI6ODc6Zjc6MTI6MjI6ZGE6YzM6Mzg6MTc6NzA6OWU6ZGI6MGQ6MWM6NGE6Y2Q6ZmI6YjI6Y2I6MWQ6OWQ6Njc6NDg6NGU6OTE6ZjY6Njg6OGE6ZTk6YzM6Zjc6OGM6NGY6NTg6YTg6MDY6MmM6YTU6MzM6Zjg6OGE6YzM6OWQ6Yzg6ODM6MjI6MmE6Y2U6ODk6Nzc6NmU6MWM6YmI6OGU6ZDE6Mzk6Yjk6NmQ6MGM6M2U6N2E6M2E6NGU6NTM6MGI6YmI6MDI6MjA6ZTc6MmQ6MDk6MjQ6MTA6ZWE6ZjA6OTU6MWU6MDA6OTQ6ZmM6ODI6Mjg6OTg6MTg6MmY6NWE6ZTk6ODM6YmY6NDQ6Y2I6MTM6NmY6YzM6YjM6YmI6OWI6OTU6ZmQ6YzQ6OGY6NjY6ODE6MmI6MTM6NWM6NWU6OWQ6MTY6MDU6ZWY6OTk6NjM6NGE6YzE6MmI6OTk6MDg6YzI6YzU6ZGM6MmU6YmE6NWM6MmE6NzM6ZTc6N2Y6MDA6MzI6YjU6OTU6YWE6MzY6YzU6MzY6YWU6NzQ6YTE6M2E6NjE6NzE6ZWI6MGM6Y2Y6NzY6MzE6NGE6ZWQ6NjY6ZGQ6YTY6YjE6Yzk6ZjY6OTI6Yjg6Yjk6MmI6ZWU6MjU6MGU6OTE6MTQ6Yzk6M2Q6MTY6OWI6OWM6YWM6MWE6ZDE6MGM6YTI6ZDE6Yjc6OTM6NzE6ZDM6ZGQ6ZjQ6YTY6OTg6YTI6YjQ6MDI6MTc6ZTQ6M2M6YzQ6Mjg6NWM6YmY6ZTk6ZGU6OGQ6MWU6OWM6MjA6YjE6NGM6YjY6YTM6NzE6Mjk6Zjk6MmY6N2U6NGQnXG4gICAgfVxuICB9LFxuICBxYV9wZXJmX09MRDoge1xuICAgIC8vIGtpZDogJ2E3NGUyM2VlJyxcbiAgICBraWQ6ICdVQkhCTjZVR1NPSzFYWVFUWlBOVTExeXJ6YTVZTm9hc09RMkFvbG1hbDlCcVUzR0s0JyxcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDB4MDEwMDAxLFxuICAgICAgbjogJ2NmYzRkYWU2YzVmMjU3NDRlMzMyOTFlMzE4YTE4N2ZkM2JiZWYyYWE2N2Q0MTM3Y2NkNTZiYTExZmI4ZjY3NzgyNGNmYzA2NTU0MzI4YWFkZDYxMTllM2FmMzM5MWRmZGMxOWMzNDQ1NjJlOGNiMjQ2MmRmOGE1ZWZmYjJmNjhhM2E1YzY2M2ZiZDVlYTkxZDczNTY4ZmJmZDcxMGNlOWIwZjNmN2FjZjRkMThiMDBmOWJjZDI5YzY2YTA2ZmMzNzBhZjdiZDQ5N2RmMWI3OGU3ZmFhOWQxNzY5MWZmZmI1Y2RhNjI2NDg0MDAzYmE1NDdhNTQ0NDAyNTVhNGY1YWQyNTk1MDI3NjQ1ZTA4MjM1NzAwZTQ5NzFmMzcxNzFjOTE0Nzk3ZGFlMWFlZjk5YzlkMTg2OWIyMDExMGU2YWViN2E2NGNhZmNhMjY5YWVmYWJkZTZiMGRkOTYwM2YyZTFjNWEwYzRiZmE5N2M0MWM1YzY5YjEwOGZlODg2MDg3ZjNmMWQ2OWVlNzgzZmZjNTJhYzVjYTI1MTc2NGIzODZlMzk4MDdmYjkyNDY3NjM5ZWU5ZTY4OTk2MzkwOGZmMmIxMTE1MGVmN2UxZThjN2VkYTBhMzJiMDI3MTZiMDVkOGZjODU1YWU4YzM0YTNlMGI4MzA0NGE2NWVlMjM0ZWE3J1xuICAgICAgLy9uOiAnY2Y6YzQ6ZGE6ZTY6YzU6ZjI6NTc6NDQ6ZTM6MzI6OTE6ZTM6MTg6YTE6ODc6ZmQ6M2I6YmU6ZjI6YWE6Njc6ZDQ6MTM6N2M6Y2Q6NTY6YmE6MTE6ZmI6OGY6Njc6Nzg6MjQ6Y2Y6YzA6NjU6NTQ6MzI6OGE6YWQ6ZDY6MTE6OWU6M2E6ZjM6Mzk6MWQ6ZmQ6YzE6OWM6MzQ6NDU6NjI6ZTg6Y2I6MjQ6NjI6ZGY6OGE6NWU6ZmY6YjI6ZjY6OGE6M2E6NWM6NjY6M2Y6YmQ6NWU6YTk6MWQ6NzM6NTY6OGY6YmY6ZDc6MTA6Y2U6OWI6MGY6M2Y6N2E6Y2Y6NGQ6MTg6YjA6MGY6OWI6Y2Q6Mjk6YzY6NmE6MDY6ZmM6Mzc6MGE6Zjc6YmQ6NDk6N2Q6ZjE6Yjc6OGU6N2Y6YWE6OWQ6MTc6Njk6MWY6ZmY6YjU6Y2Q6YTY6MjY6NDg6NDA6MDM6YmE6NTQ6N2E6NTQ6NDQ6MDI6NTU6YTQ6ZjU6YWQ6MjU6OTU6MDI6NzY6NDU6ZTA6ODI6MzU6NzA6MGU6NDk6NzE6ZjM6NzE6NzE6Yzk6MTQ6Nzk6N2Q6YWU6MWE6ZWY6OTk6Yzk6ZDE6ODY6OWI6MjA6MTE6MGU6NmE6ZWI6N2E6NjQ6Y2E6ZmM6YTI6Njk6YWU6ZmE6YmQ6ZTY6YjA6ZGQ6OTY6MDM6ZjI6ZTE6YzU6YTA6YzQ6YmY6YTk6N2M6NDE6YzU6YzY6OWI6MTA6OGY6ZTg6ODY6MDg6N2Y6M2Y6MWQ6Njk6ZWU6Nzg6M2Y6ZmM6NTI6YWM6NWM6YTI6NTE6NzY6NGI6Mzg6NmU6Mzk6ODA6N2Y6Yjk6MjQ6Njc6NjM6OWU6ZTk6ZTY6ODk6OTY6Mzk6MDg6ZmY6MmI6MTE6MTU6MGU6Zjc6ZTE6ZTg6Yzc6ZWQ6YTA6YTM6MmI6MDI6NzE6NmI6MDU6ZDg6ZmM6ODU6NWE6ZTg6YzM6NGE6M2U6MGI6ODM6MDQ6NGE6NjU6ZWU6MjM6NGU6YTcnXG4gICAgfVxuICB9LFxuICBwcm9kdWN0aW9uOiB7XG4gICAga2lkOiBcIkpIQTEwTEFLRUZHMFQ3Q0lCUzFPMTRDaG42bHEzY2RPeHEtV3dxYTYyWlV3S3ZubTRcIixcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDY1NTM3LFxuICAgICAgbjogXCIwMDo5MDpmYjphMzpjMTo1Mjo2Mzo3YTpmMjozZjphMTplNjo3MDo2Njo4MDozNjo1YTozYjo3ZDplMDozMTo1YzozMjpmNDo0Mjo2OTpiZjoyMjo0NjoyMTowNjphYzo2NzpjYTo1YTpkMzo0MjpjMTowNjoyNDpjYTo1YzphZTo0Njo4MDo3YTpkNzo5NzoxODo5Yjo2MDo1NTo2ZTpmYTowYToxZjpjNjozMjpiZjo0Njo4MjpkZDpkYzoxYTo4NzphNToyNjozOTpkMjo2YzpjZTo2MjpmNDphNTo1ZjpkYzo2ZjoxZjplZDo1ZjozNTphMDo2MjowZDplYzo2MDpkYjoyOTpkMjpjMDo3MTo1MDo1NzoxMDpkNDowZTo4Mzo1NTpiYzo4ZTpjNzoxMjo1Yjo5YTo3YzoyNToxYzo2MTozOTo3ZTo0YjpiMzoyNjpiZjphYTphYTplOTo3Nzo0NjpjYzoyYzowODo2ZjphZjozZTpiODo3ZjpmYjplZDpiZjo0NToyODphOTo2YjpkOTo1NTphZjpkODoyZjo3Yzo4ZTowMDo2Yzo1MDowMToyZDozYTo4YTo3YTpkYTozNDphZDo2MzpkYjoyMDoxMjo5ZDo4NTpjMTo5MDplYzo5MzowZjpjNzozYTpiYzpkYjo3Zjo0YTozZDo0Njo1Zjo0YjoyMzo2ZTo3ODowNzoxZDoyZjplYzo4NzowMDozODpiNzoyZjo2NTo1MjpjZDpkMTo3YjpiNToyZTplYzo4Yjo3Yjo5ZTpmYzo4MTo2ODo1YzozYTo1Yjo4MjowYjowNTpjNjpmMToyZDplZjpkNToyNTowNDozMzo4MTpiMTphODoxYzpmZTo2YjozZDpmZDo5YjoxODo5NDo5Njo4YTowOTozZjoxOTo4ZjowODo1YTo5MDpjYTozZjpmOTo5Nzo1YzpmNzpiOTphZTo3NTo1ODpmNTo4ZjozZDpiZjoyZjo5OTo3ODo5NzpmYzplMjo2Yzo1ZTo2Yjo4YlwiXG4gICAgfVxuICB9LFxuICBkZXZlbG9wbWVudDoge1xuICAgIGtpZDogXCJJUFc0VzFEWDVENE41RThMTUFDNjExNWxhNDROdTl6WW9iX2Jncmc1RVVNa3NiZ1Q0XCIsXG4gICAgcHVibGljS2V5OiB7XG4gICAgICBlOiA2NTUzNyxcbiAgICAgIG46IFwiMDA6YmE6N2U6ZWQ6OGE6OTg6ZTk6OTk6ZmI6YmI6MGQ6ZDg6YmY6YjM6ODk6NGM6MTM6NzQ6OTM6Njc6MGM6MDI6Yzk6ZTg6MzI6OGQ6NDI6MmM6NWE6ZmQ6YWM6Y2I6Njc6MGU6Yzk6NGI6MmU6NzM6NjU6N2E6MWE6ZDI6NDU6NmM6Yjg6Mjg6ZDc6MDY6YWM6MWQ6OGI6MGQ6MWI6ODg6OTY6MjI6MzU6YzE6NmY6NWY6OTU6Yzc6MDk6MGE6ZDU6ZmQ6OTI6YmU6NjU6ZmM6MzY6MTQ6ZWQ6NGE6NjA6NWY6ZjM6YmM6Yjk6MjA6YTU6N2U6Y2I6OWM6MzU6YzQ6ZWY6MDk6MjY6Nzg6M2M6MTk6M2U6ZDI6YTI6OWI6ZGQ6YjQ6MTU6NjM6YjI6YTY6NDk6MjE6OTQ6MTU6ZTQ6Mzc6ZDQ6MWU6ZTA6ZDk6ZjE6Nzk6ZTc6MDE6YTc6NTY6ODM6M2I6Mzc6NTk6YmU6OWU6NTc6ZTg6OWM6YTg6ODQ6MmI6NDk6ZGQ6NWQ6M2Q6MDQ6Mzc6ZmQ6MDk6NWY6NTk6OTM6MjA6ZjY6MDE6ZDI6ZDI6MWE6NTc6MWQ6YWE6NmY6NTg6NWM6ZWM6ZTI6ZGY6Nzc6YWU6MDI6YmY6OWU6ZjM6YmI6NGU6ZTk6OTA6NjA6OTk6NjQ6MDg6YTQ6ODQ6NzE6YzA6MTk6ZjA6ZWU6NjQ6Mzk6ODk6NmQ6YmM6MzQ6YmY6MDM6ZjA6MmU6Njk6OGE6Nzg6NmQ6MjA6OWE6MTU6OGY6NjQ6YjY6ZWU6NWQ6MWE6NGQ6NWI6MmM6Yzk6ODc6YTE6NDE6ZWU6OTI6ZjM6YjQ6NTY6MjQ6MzU6NzM6NTM6ZTE6OGM6NGI6OTE6ZDY6ZjE6OWY6MzE6NmQ6Yzg6YTU6NTA6MTI6YmY6ZDg6YzE6YTM6NjE6N2Y6NGY6YTU6NmE6NWI6OTg6OTE6OTQ6Njg6YmY6OGY6NDk6NWY6ZDU6ZTM6NjI6YTE6YTU6Y2M6OTg6N2Q6OTE6YmJcIlxuICAgIH1cbiAgfSxcbiAgY2VydDoge1xuICAgIFwia2lkXCI6IFwiYmI5MTdkOThcIixcbiAgICBcIm5hbWVcIjogXCJxYS1jYnAtcnNhLWVuYy1jc3ItMVwiLFxuICAgIFwicHVibGljS2V5XCI6IHtcbiAgICAgIFwiZVwiOiA2NTUzNyxcbiAgICAgIFwiblwiOiBcIjAwOmJhOjdlOmVkOjhhOjk4OmU5Ojk5OmZiOmJiOjBkOmQ4OmJmOmIzOjg5OjRjOjEzOjc0OjkzOjY3OjBjOjAyOmM5OmU4OjMyOjhkOjQyOjJjOjVhOmZkOmFjOmNiOjY3OjBlOmM5OjRiOjJlOjczOjY1OjdhOjFhOmQyOjQ1OjZjOmI4OjI4OmQ3OjA2OmFjOjFkOjhiOjBkOjFiOjg4Ojk2OjIyOjM1OmMxOjZmOjVmOjk1OmM3OjA5OjBhOmQ1OmZkOjkyOmJlOjY1OmZjOjM2OjE0OmVkOjRhOjYwOjVmOmYzOmJjOmI5OjIwOmE1OjdlOmNiOjljOjM1OmM0OmVmOjA5OjI2Ojc4OjNjOjE5OjNlOmQyOmEyOjliOmRkOmI0OjE1OjYzOmIyOmE2OjQ5OjIxOjk0OjE1OmU0OjM3OmQ0OjFlOmUwOmQ5OmYxOjc5OmU3OjAxOmE3OjU2OjgzOjNiOjM3OjU5OmJlOjllOjU3OmU4OjljOmE4Ojg0OjJiOjQ5OmRkOjVkOjNkOjA0OjM3OmZkOjA5OjVmOjU5OjkzOjIwOmY2OjAxOmQyOmQyOjFhOjU3OjFkOmFhOjZmOjU4OjVjOmVjOmUyOmRmOjc3OmFlOjAyOmJmOjllOmYzOmJiOjRlOmU5OjkwOjYwOjk5OjY0OjA4OmE0Ojg0OjcxOmMwOjE5OmYwOmVlOjY0OjM5Ojg5OjZkOmJjOjM0OmJmOjAzOmYwOjJlOjY5OjhhOjc4OjZkOjIwOjlhOjE1OjhmOjY0OmI2OmVlOjVkOjFhOjRkOjViOjJjOmM5Ojg3OmExOjQxOmVlOjkyOmYzOmI0OjU2OjI0OjM1OjczOjUzOmUxOjhjOjRiOjkxOmQ2OmYxOjlmOjMxOjZkOmM4OmE1OjUwOjEyOmJmOmQ4OmMxOmEzOjYxOjdmOjRmOmE1OjZhOjViOjk4OjkxOjk0OjY4OmJmOjhmOjQ5OjVmOmQ1OmUzOjYyOmExOmE1OmNjOjk4OjdkOjkxOmJiXCJcbiAgICB9XG4gIH0sXG4gIC8vIGNlcnQ6IHtcbiAgLy8gICBraWQ6IFwiSVBXNFcxRFg1RDRONUU4TE1BQzYxMTVsYTQ0TnU5ellvYl9iZ3JnNUVVTWtzYmdUNFwiLFxuICAvLyAgIHB1YmxpY0tleToge1xuICAvLyAgICAgZTogNjU1MzcsXG4gIC8vICAgICBuOiBcIjF1MjloNnYyYmN3TnFDRGF0blFtNlQ0U192S2ZYTy1Ic3AyNmFiZzlOOUQtRU5LS3QzY1FSUUg4UHE2U2VJNzRZNlZ0V1NZR28yYnBLMXA5ZFdYS0hlcC1hOUw2dWd4TzNVaGlsRkZFX1pvc0wwS0tPZEFMbjRWLUdXdklVUGM3Rml0dEJuX19JV1M5OWVQMU5KZHR1ODlXSDRNYkN1U0diS2ptbW9hazM1R3hDNWNKVGU4NThuVnlUTTdPcXlISDUyckR4cEQzY3NsN0dTZ0E1NlJIZG9aTUFCa2YzaEgybWVuM0RPamk4bDM2Z1phQ1BxbEhLYzZNUDRiNVJ4UC11R2FWTmF4U2QxNlBzWjE1aXM4X19FZ1FBS19QWFA0bVdVRkdiRVlGdS01TlVoam13bmdzeXdqYzBIVDlVbmNjenZnZVB0S09oMHZlczQ5b0ZxUURNd1wiXG4gIC8vICAgfVxuICAvLyB9LFxuICBzYW5kYm94OiB7XG4gICAgLy8ga2lkOiBcIjFiZGFiM2NjXCIsXG4gICAga2lkOiAnVjZZUEwwREZKMlY1NkhJSDZRM0YxMzNmYlpXeUF5SUhqV1ZTZWN4NktNRjZpVEhHTScsXG4gICAgcHVibGljS2V5OiB7XG4gICAgICBlOiA2NTUzNyxcbiAgICAgIG46IFwiMDA6YjE6OTM6Yzg6YmE6YzA6ZGY6ZWY6MjQ6Mjc6OWU6MTA6NjQ6NTM6ZDk6YWU6ZDc6ODU6NGU6M2I6NzA6YWI6YmE6MmQ6ZGI6ZWU6YjA6MWY6ZDg6YTY6MWU6YTE6YjU6MTE6OTk6NzA6MzU6ZWQ6YmQ6NDk6NWY6ZDg6ZTA6ZDA6Mjc6N2U6YmU6MGE6NjY6YmI6MjQ6ZWI6YzQ6MTU6MTI6NzM6ZWU6MWI6ZDM6ZTU6MGY6ODE6MmM6MDY6MTY6YTM6ZDY6NTI6OWM6NzQ6ZjA6NGM6NmE6YWY6MDM6YzM6M2E6ZjE6Njg6OGM6MWE6MmU6ZGI6MDk6NzI6YWI6YzY6ZGM6Y2I6NDU6MmM6Zjg6MTc6ZGU6MGI6MzQ6ODQ6ZTY6NTM6MTU6NzU6MjU6ZDM6NWQ6NzU6ZGM6MzY6YWI6YmU6YTk6YmQ6YjY6OGM6MjA6ODI6MjQ6MDI6ZTk6YzY6YzA6MmI6YjE6YmE6MGM6Mzk6N2I6MGI6Nzk6ZDg6Nzc6MzM6ODU6Y2Q6NDM6OTU6YzY6MDI6ZDQ6NWY6ZWQ6YmY6YmU6Yjk6MzY6Mzk6MGU6YmY6NGE6MmQ6OGM6OTQ6YmQ6OTI6ODA6OWQ6OGQ6Mzg6MzA6YTI6NGY6MTA6ZWU6Nzg6NjI6MjI6MDU6MzM6OTA6ZDM6MDI6MTM6NGU6OWE6Y2Q6M2M6ZjY6Mzc6NGM6Nzc6MWY6OTQ6NDQ6ODI6ODk6OGM6ZjU6MzY6Zjk6MWE6NDc6MWI6NWI6YmM6MmM6MjE6YjQ6ZGI6YzQ6NTM6MjI6OTM6ZWM6MzU6YjQ6NWE6OWU6ZTQ6Yjk6NGM6MDY6M2Y6Y2U6NWM6NDM6ODE6YmQ6NjE6Mjg6OWQ6ZmE6NjE6YjY6NDQ6MzQ6NzI6ZTA6ZjQ6ZjU6ZDM6MDY6MTc6NGU6MzI6NTU6M2Q6ZDA6MzQ6Y2I6OTU6Zjc6MWI6MmQ6MzY6YmU6MGY6YjA6ZTA6OTY6MzA6MWE6NTg6MmI6YWY6Y2M6YjM6ZGE6MWJcIlxuICAgIH1cbiAgfSxcbiAgYW1leDoge1xuICAgIGtpZDogXCJzcmMtYW1leC1jYXJkLWVuYy0wMVwiLFxuICAgIHB1YmxpY0tleToge1xuICAgICAgZTogNjU1MzcsXG4gICAgICBuOiBcIjk4OjE2OmJjOmM0OmQ3OjFjOjBhOjI1OmE1OjMzOjA3OmQ5OjA1Ojg5OmNhOjc5OjRjOmI4OmUwOjliOmIwOmZkOmE3OjRlOjViOjc2OmQzOjBiOjQ2OjNiOjE3OjNhOjA0OmFiOmE3OmVlOjA4OmYwOmEyOmM1OjdmOmNkOjE4OjM5Ojk4OjkzOmVjOmY4OmY5OjI1OjZhOjk2OjNkOmJmOjIwOmI1OjY2OjRiOjcyOjNjOjYwOmVmOmNkOjQ1Ojc1OjY0OmM4OmZjOjBmOjE3OjQ4OmQ5OmI2OjllOjhmOjRkOmRlOjk3OjgyOmQ0OjRmOmQ1OmNjOmViOjk3OmZiOmYyOjNmOjRiOmFiOjQwOjYzOjE3OmNjOjA5OjMzOmM2OjlkOjA1OjNlOjI4OmMzOmI1OmQ2OmM1OjBmOjcyOjBkOjNkOmM3OmZlOmU1OmVkOjdiOjI2OjU3OmY2OjQ0OjVlOjk4OmNlOmE4OjMxOjg1OjFiOjU2OmNhOmJjOjMzOjY2OjU4OjY2OjBlOjExOjUwOjZkOjZmOjU1OmFjOmYyOmVlOjVlOmQwOjFiOjYxOjk5Ojk0OjljOjE0OjI3OjA4OjZhOmFjOmM2OjViOjVmOjk1OjRmOmFiOmNjOjhjOjMxOmY1OmI1OjcwOjhiOmI5OjZjOmI1OjIyOmNjOjZjOmJmOjIyOjAwOjNiOmQxOjFiOjU5OjZiOjUwOmIyOmY5OjFmOjRjOjk0OjkzOjc1OmYyOmQ0OjM5OjcwOjdlOjE4OjlkOjA0OjBjOmUzOjlhOjY5OjNmOjg5OmQzOjQzOmQxOjY0OmI2OmE2OjU5OjdmOmJmOjFmOjViOmY5OjIxOjlhOmJlOjUzOjg1Ojc1OmFkOjYwOjVjOmZiOjA5OmY2OmY5OmI3OmE3OmZkOmU5OjM1OmE3OjVkOmZlOjA0Ojc3OjEyOjU1OjVmOjBlOmY1OjkwOmNhOjAxOjU5OmZkOjE4OmVjOjBiOjM1OjA1OjU4OmQ2OmE5OjA2OmI2OmFmOjE4OjkwOjYwOjA2OjdlOmYyOmI1OjkyOjQzOjc3OmVjOjllOjU0Ojg0OjZkOjQ3OjUwOjA0OjE4OjE4OmY5OmIwOjFlOjdhOmQ1OmM1OjM3OmVlOmYxOmYxOmIzOmExOmVmOmYzOmFhOmRiOmQxOmQxOmQ4OjBkOjI2OmE2OjFmOjdiOjFhOmZlOmExOjc2OjlkOmQ5Ojk0OjQ4OmRmOjU2OjEwOjJiOjdkOjI4OjM1OmExOmYwOjQ3OjExOmFmOjZiOmY3OmRiOmFlOjdiOjk5OmMxOjgwOmQ3OjA1OmJjOjIyOmQ1OjZjOjNmOjhjOjQxOmJkOjc1OmY0OjJkOmRiOjQwOjg0OjBlOjVjOmFlOmZhOjcwOjQwOjk3OjQ5OmI1OmQxOmIxOmYzOmUxOjgxOjgxOjRkOjZlOjFhOjMyOjZkOjRmOjZiOmUxOjcwOjYzOmIyOjMyOjQwOmI1OjI4OjcyOmM0OjAwOjk5OjMzOmU1Ojc2OjhkXCJcbiAgICB9XG4gIH0sXG4gIG1hc3RlckNhcmQ6IHtcbiAgICBraWQ6IFwiMTQ5MTIzLXNyYy1mcGFuLWVuY3J5cHRpb25cIixcbiAgICBwdWJsaWNLZXk6IHtcbiAgICAgIGU6IDY1NTM3LFxuICAgICAgbjogXCJ2dDRuRFNQU3RUbE0xTk5jeWN2SXFVZjR4MTRJNGppVHFNVEtQakd0YXkweWZhMXZCeU5DaG11cHBEd0VUNWdHR2xwTDhjY2ozWVZzQmk5X2JXb2VfYXBwa1B3aHhkN3dSOVJ5d1Yzem1XdU1JaE13bGswbG5IQU1MNjVuc0hWTTNvRXBFdkNmQVBzMU5YbHRUeWZqbmtnRkVOSTN0SHF0d2R0TThlUDAycHAwanZXNjlmeWJ2eVZoTHpYd1NPZ0pudGp0alJWN2hRcjVsZWRfaldiNXp6WEk0OE9WVFRfRjlpaW5EZHRYNXkzRS1pZjVXdEdaVUZFVGJfdFpGWlluTUxhTGxId3ZiNlprcjg0UlN3d3NNZjJuQUxfNHpQMlVhaE13emFtaEJvT1NhcXl4R3hFcTY3SHIxVTh6QUM1aGw5RDhOYmdTd3BXeHNPRFVySHg5cndcIlxuICAgIH1cbiAgfSxcbiAgZGlzY292ZXI6IHtcbiAgICBraWQ6IFwiTlRka01EQTFZVFZqTTJVeU9Ua3pNbUZpWkRkbU1XRTBZMkl5WkdFNE5UTXlObU5qTlRWbVpETTFaR1JrTURFME5tRmpOMkZpWXpneVlqYzRPV1ExTkFvXCIsXG4gICAgcHVibGljS2V5OiB7XG4gICAgICBlOiA2NTUzNyxcbiAgICAgIG46IFwiMDA6OWI6NTI6ZDQ6Y2Y6YTI6NzQ6YmY6YzY6ZjI6NTg6YWE6MGI6OWM6NTk6Mzk6ODg6ZGQ6MDI6M2M6ZDA6MjM6NWY6MzI6MWE6OGM6M2I6YWY6MmY6OWU6ZDE6YWQ6NjM6MGE6ZDE6N2M6ZGQ6ZmM6YTU6Njk6NGE6ODY6NmM6YTk6MzU6ZTI6ZDU6MzU6NDA6MWE6NmQ6MTI6ZDg6NWU6ZjI6YTc6MDY6ZjE6ODM6MTQ6MTM6Yjg6Njc6ZDU6MTI6MDI6ZTI6Yjc6YzA6ZTE6ODM6Yzk6ZmQ6NzI6ZDk6MjM6MDg6MjI6Njc6MTU6ZmM6ZTQ6Y2M6NTk6MGQ6NTE6YWE6MDg6MjE6NTM6Mzc6OTk6OWQ6NmQ6MTM6OGE6MzM6OGE6NjY6ODc6ODI6Yjc6YzU6NzE6NWM6N2Q6NTE6NGI6OGU6MGQ6MGE6MzU6OWY6ZDE6ZjI6NzY6NDE6ZjA6MWY6OTI6MDU6M2M6Njg6NWE6YTA6Mjg6NTI6NjY6ZjM6NGY6ZTI6MGQ6NTg6OTM6NDU6Yjk6Njg6ODQ6NzE6Yjg6Njc6ODQ6OTI6NDk6ZTY6ZWQ6NDk6ZDQ6NGU6OWI6MDA6NGI6Yjg6Nzc6ZjA6NjA6ZTc6Y2E6OWM6NzM6ODU6Nzk6MGM6ZjM6YmU6OWQ6NDc6NjU6OGE6ZDY6NzU6MTU6YzE6MWE6YjE6YzA6MDM6YmM6ZDI6ZDM6NjU6MzI6ZWE6NDY6OTc6M2E6MWY6Njc6NDY6MzY6ZDM6OTU6N2I6ZjM6YzU6ZGE6MDI6NWE6ZDk6YWE6ZDc6MDQ6MDM6MWQ6YWI6ZTg6NDM6MDU6MDI6Y2Y6YmE6MWE6MzU6Zjk6ZjE6MTU6NTk6NmM6NjA6YWE6YTk6ODA6MDI6NjU6MTg6MDE6MmU6NWM6OTI6ODE6YTI6YjI6NDM6NjI6Mzg6MjU6Yjc6NzI6ZDA6OGY6NGQ6ZjQ6NWU6Zjk6MTY6ZWQ6NWI6N2Q6NzQ6ODM6NzU6ZmE6MWU6YzM6Mjg6ZjU6MDVcIlxuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IFBBTkpXRSB9IGZyb20gJy4uL2pvc2UvdmlzYS1lbmNyeXB0LmpzJztcbmltcG9ydCB7IGtleXMgfSBmcm9tICcuLi9zdHVicy9wYW4tZW5jcnlwdGlvbi1rZXlzLmpzJztcbmltcG9ydCBnZXRSb290RG9tYWluIGZyb20gJy4vZ2V0LXJvb3QtZG9tYWluLmpzJztcbmltcG9ydCB7IGdldEVuY3J5cHRpb25LZXlzIH0gZnJvbSAnLi9nZXQta2V5cy50cyc7XG5cbi8vIGV4dGVybmFsLCBzY3J1YmJlZCBzaXRlc1xuY29uc3QgZW5jcnlwdGlvbktleXMgPSAoa2V5cykgPyBrZXlzIDogZ2V0RW5jcnlwdGlvbktleXMoKTtcblxuY29uc3QgZ2V0UnNhS2V5RnJvbURvbWFpbiA9ICgpID0+IHtcbiAgY29uc3QgZG9tYWluID0gZ2V0Um9vdERvbWFpbigpO1xuICBjb25zb2xlLmxvZyhgLS0gZGV0ZWN0ZWQgJHtkb21haW59IGZyb20gdmlzYSBzZGsgdXJsYCk7XG5cbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSAnaHR0cHM6Ly9zZWN1cmUuY2hlY2tvdXQudmlzYS5jb20nOlxuICAgICAgcmV0dXJuIGVuY3J5cHRpb25LZXlzLnByb2R1Y3Rpb247XG4gICAgY2FzZSBkb21haW4uaW5kZXhPZigncWFwZXJmJykgPiAtMTpcbiAgICAgIHJldHVybiBlbmNyeXB0aW9uS2V5cy5xYV9wZXJmO1xuICAgIGNhc2UgZG9tYWluLmluZGV4T2YoJ2NlcnQuJykgPiAtMTpcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBjZXJ0IGVuYyBlbmNyeXB0aW9uS2V5cycpO1xuICAgICAgcmV0dXJuIGVuY3J5cHRpb25LZXlzLmNlcnQ7XG4gICAgY2FzZSBkb21haW4uaW5kZXhPZignc2FuZGJveC4nKSA+IC0xOlxuICAgICAgY29uc29sZS5sb2coJ3VzaW5nIHNieCBlbmMgZW5jcnlwdGlvbktleXMnKTtcbiAgICAgIHJldHVybiBlbmNyeXB0aW9uS2V5cy5zYW5kYm94O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZW5jcnlwdGlvbktleXMuY2VydDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUEFOSldFX3Zpc2EgPSBhc3luYyAocykgPT4ge1xuICBjb25zdCB7IHB1YmxpY0tleSwga2lkIH0gPSBnZXRSc2FLZXlGcm9tRG9tYWluKCk7XG4gIGNvbnNvbGUuaW5mbyhgW1BBTkpXRV0ga2lkOiAke2tpZH1gKTtcbiAgY29uc29sZS5pbmZvKCdbUEFOSldFXSBwdWJsaWNLZXk6ICcsIHB1YmxpY0tleSk7XG4gIGNvbnN0IGNyeXB0ID0gbmV3IFBBTkpXRShraWQsIHB1YmxpY0tleSk7XG4gIHJldHVybiBjcnlwdC5lbmNyeXB0KHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoY2FyZERhdGFPYmplY3QpID0+IGF3YWl0IFBBTkpXRV92aXNhKEpTT04uc3RyaW5naWZ5KGNhcmREYXRhT2JqZWN0KSk7XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzJztcbmltcG9ydCBlbmNyeXB0Q2FyZCBmcm9tICcuL2VuY3J5cHQtY2FyZCc7XG5pbXBvcnQgeyBoYW5kbGVKc29uUmVzcG9uc2UgfSBmcm9tICcuL2ZldGNoLmpzJztcblxuXG5leHBvcnQgY29uc3QgaGFuZGxlQ2FyZERhdGEgPSBhc3luYyBjYXJkRGF0YSA9PiB7XG4gIGNvbnN0IHJldCA9IHsgY2FyZERhdGE6IG51bGwsIGVuY3J5cHRlZENhcmQ6IG51bGwgfTtcbiAgY29uc3QgZCA9IGNhcmREYXRhLnBhbiB8fCBjYXJkRGF0YS5kYXRhPy5wYW4gfHwgY2FyZERhdGEuZGF0YTtcbiAgY29uc3QgZXhwRGF0ZUFycmF5ID0gZC5FeHBpcmF0aW9uRGF0ZS5zcGxpdCgnLycpO1xuICBjb25zdCB2Y29DYXJkID0ge1xuICAgIGNhcmQgOiB7XG4gICAgICBjYXJkU2VjdXJpdHlDb2RlOiBkLkN2djJWYWx1ZSxcbiAgICAgIGNhcmRob2xkZXJGdWxsTmFtZTogZC5DYXJkaG9sZGVyTmFtZSB8fCBcIlNSQyBTREtcIixcbiAgICAgIHBhbkV4cGlyYXRpb25Nb250aDogcGFyc2VJbnQoZXhwRGF0ZUFycmF5WzBdKSxcbiAgICAgIHBhbkV4cGlyYXRpb25ZZWFyOiBwYXJzZUludCgnMjAnICsgZXhwRGF0ZUFycmF5WzFdKSxcbiAgICAgIHByaW1hcnlBY2NvdW50TnVtYmVyOiBkLlByaW1hcnlBY2NvdW50TnVtYmVyLFxuICAgICAgY2FyZGhvbGRlckZpcnN0TmFtZTogXCJUZXN0VG9vbFwiLFxuICAgICAgY2FyZGhvbGRlckxhc3ROYW1lOiBcIlNhbXBsZURhdGFcIixcbiAgICAgIHBheW1lbnRBY2NvdW50UmVmZXJlbmNlOiBcIlwiLFxuXG4gICAgICBiaWxsaW5nQWRkcmVzczoge1xuICAgICAgICBhZGRyZXNzSWQ6IFwiXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIGxpbmUxOiBkLkFkZHJlc3NTdHJlZXQsXG4gICAgICAgIGxpbmUyOiBkLkFkZHJlc3NTdHJlZXQyLFxuICAgICAgICBsaW5lMzogZC5BZGRyZXNzU3RyZWV0MyxcbiAgICAgICAgY2l0eTogZC5DaXR5LFxuICAgICAgICBzdGF0ZTogZC5TdGF0ZSxcbiAgICAgICAgY291bnRyeUNvZGU6IGQuQ291bnRyeSxcbiAgICAgICAgemlwOiBkLkFkZHJlc3NQb3N0YWxDb2RlLFxuICAgICAgICBjcmVhdGVUaW1lOiBcIlwiLFxuICAgICAgICBsYXN0VXNlZFRpbWU6IFwiXCIsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnNvbGUubG9nKCdvYmplY3QgdG8gZW5jcnlwdDogJywgdmNvQ2FyZCk7XG4gIHJldC5lbmNyeXB0ZWRDYXJkID0gYXdhaXQgZW5jcnlwdENhcmQodmNvQ2FyZCk7XG4gIGNvbnNvbGUubG9nKHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICgpID0+IHtcbiAgY29uc3QgYmluUmFuZ2UgPSBnZWwoJ2Jpbl9yYW5nZScpLnZhbHVlO1xuICBjb25zdCBjYXJkRGF0YSA9IGF3YWl0IGZldGNoKGAvY2FyZHM/YmluPSR7YmluUmFuZ2V9YCkudGhlbihoYW5kbGVKc29uUmVzcG9uc2UpO1xuICByZXR1cm4gYXdhaXQgaGFuZGxlQ2FyZERhdGEoY2FyZERhdGEpO1xufTtcbiIsImltcG9ydCB7IGhhbmRsZUNhcmREYXRhIH0gZnJvbSAnLi9nZXQtdmlzYS1jYXJkJztcbmltcG9ydCB7IGNhdGNoRXJyLCBnZWwgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgY29uc3QgZW5jcnlwdE1hbnVhbENhcmRFbnRyeSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgcyA9IGdlbCgncGFuX2pzb24nKS52YWx1ZTtcbiAgbGV0IHBhbjtcblxuICB0cnkge1xuICAgIHBhbiA9IEpTT04ucGFyc2Uocyk7XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZUNhcmREYXRhKHBhbik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYXRjaEVycignbWFudWFsIFBBTiBKU09OIHBhcnNlIGZhaWxlZC4nKTtcbiAgICByZXR1cm4geyBlbmNyeXB0ZWRDYXJkOiBudWxsIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY2hlY2tvdXQgfSBmcm9tICcuLi9hc3luYy9jaGVja291dC5qcyc7XG5pbXBvcnQgeyBnZXRTcmNQcm9maWxlIH0gZnJvbSAnLi4vYXN5bmMvZ2V0LXNyYy1wcm9maWxlLmpzJztcbmltcG9ydCB7IHVuYmluZCB9IGZyb20gJy4uL2FzeW5jL3VuYmluZC5qcyc7XG5pbXBvcnQgZ2V0VmlzYUNhcmQgZnJvbSAnLi4vaGVscGVycy9nZXQtdmlzYS1jYXJkJztcbmltcG9ydCB7IGNhdGNoRXJyLCBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IHVwZGF0ZUJlbmNobWFya3MgfSBmcm9tICcuLi9oZWxwZXJzL3VwZGF0ZS1iZW5jaG1hcmtzLmpzJztcbmltcG9ydCB7IGdldEludGVudFBheWxvYWQgfSBmcm9tICcuLi9zdHVicy9kYXRhJztcbmltcG9ydCB7IGNhblVzZVRlc3RDYXJkQXBpIH0gZnJvbSAnLi4vaGVscGVycy9jYW4tdXNlLXRlc3QtY2FyZHMtYXBpLmpzJztcbmltcG9ydCB7IGVuY3J5cHRNYW51YWxDYXJkRW50cnkgfSBmcm9tICcuLi9oZWxwZXJzL2dldC12aXNhLWNhcmQtbWFudWFsLmpzJztcbmltcG9ydCB7IHNldFBhc3NGYWlsIH0gZnJvbSAnLi4vdWkvZXZlbnQtaGFuZGxlcnMuanMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWZ0ZXJBdXRoTmV3VXNlcihhZGFwdGVyLCBsYWJlbCkge1xuICBjb25zdCBpbnRlbnRQYXlsb2FkID0gZ2V0SW50ZW50UGF5bG9hZCgpO1xuICBjb25zb2xlLmluZm8oYFtBRERfQ0FSRF0gJHtsYWJlbCB8fCAnbmV3IHVzZXIgKyBlbnJvbGwnfWApO1xuXG4gIGlmIChjYW5Vc2VUZXN0Q2FyZEFwaSgpKSB7XG4gICAgaW50ZW50UGF5bG9hZC5lbmNyeXB0ZWRDYXJkID0gKGF3YWl0IGdldFZpc2FDYXJkKCkpLmVuY3J5cHRlZENhcmQ7XG4gIH0gZWxzZSB7XG4gICAgaW50ZW50UGF5bG9hZC5lbmNyeXB0ZWRDYXJkID0gKGF3YWl0IGVuY3J5cHRNYW51YWxDYXJkRW50cnkoKSkuZW5jcnlwdGVkQ2FyZDtcbiAgfVxuICAvLyBjb25zb2xlLmxvZygnaW50ZW50IHBheWxvYWQgYWZ0ZXIgZ2V0VmlzYUNhcmQ6ICcsIGludGVudFBheWxvYWQpO1xuXG4gIGlmIChpbnRlbnRQYXlsb2FkLnNyY0RpZ2l0YWxDYXJkSWQpIHtcbiAgICBjb25zb2xlLmluZm8oJ2NhcmQgYWxyZWFkeSBhc3NpZ25lZCwgdW5kZWZpbmluZyBpbnRlbnRQYXlsb2FkLnNyY0RpZ2l0YWxDYXJkSWQnKVxuICAgIGludGVudFBheWxvYWQuc3JjRGlnaXRhbENhcmRJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnNvbGUuaW5mbyhgW0NIRUNLT1VUXSAke2xhYmVsIHx8ICduZXcgdXNlciArIGVucm9sbCd9YCk7XG4gIGNvbnN0IGNoZWNrb3V0U3VjY2VzcyA9IGF3YWl0IGNoZWNrb3V0KGFkYXB0ZXIpLmNhdGNoKGNhdGNoRXJyKTtcblxuICBpZiAoIWNoZWNrb3V0U3VjY2VzcyB8fCBjaGVja291dFN1Y2Nlc3MuZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBjaGVja291dCBlcnJvciBkZXRlY3RlZDogYCwgY2hlY2tvdXRTdWNjZXNzKTtcbiAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShjaGVja291dFN1Y2Nlc3MpKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG4gIH1cblxuICBpZiAoY2hlY2tvdXRTdWNjZXNzICYmIGNoZWNrb3V0U3VjY2Vzcy51bmJpbmRBcHBJbnN0YW5jZSkge1xuICAgIGF3YWl0IHVuYmluZChhZGFwdGVyLCBjaGVja291dFN1Y2Nlc3MpLmNhdGNoKGNhdGNoRXJyKTtcbiAgfVxuICBzZXRQYXNzRmFpbCgnUEFTUycpO1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZnRlckF1dGhSZXR1cm5pbmcoYWRhcHRlciwgdG9rZW4pIHtcbiAgY29uc29sZS5pbmZvKCdbQ0FSRF9MSVNUXScpO1xuICAvLyBnZXRTcmNQcm9maWxlXG4gIGNvbnN0IHNyY1Byb2ZpbGVzID0gYXdhaXQgZ2V0U3JjUHJvZmlsZShhZGFwdGVyLCB0b2tlbikuY2F0Y2goY2F0Y2hFcnIpO1xuICB1cGRhdGVCZW5jaG1hcmtzKCk7XG5cbiAgY29uc29sZS5sb2coXCItLS0tLS1cIiwgc3JjUHJvZmlsZXMpO1xuXG4gIGlmIChzcmNQcm9maWxlcy5lcnJvcikge1xuICAgIHNldFBhc3NGYWlsKCdGQUlMJyk7XG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKHNyY1Byb2ZpbGVzLmVycm9yKTtcbiAgICBjb25zb2xlLndhcm4oc3JjUHJvZmlsZXMuZXJyb3IpO1xuICB9XG5cbiAgY29uc3QgcHJlZmVyQWRkQ2FyZCA9IGdlbCgnYWRkX2NhcmRfZmxvdycpLmNoZWNrZWQ7XG5cbiAgLy8gY2hlY2tvdXRcbiAgaWYgKFxuICAgIGZhbHNlID09PSBwcmVmZXJBZGRDYXJkICYmXG4gICAgc3JjUHJvZmlsZXMgJiZcbiAgICAhc3JjUHJvZmlsZXMuZXJyb3IgJiZcbiAgICBzcmNQcm9maWxlcy5wcm9maWxlc1swXS5tYXNrZWRDYXJkcy5sZW5ndGggPiAwXG4gICkge1xuICAgIGNvbnNvbGUuaW5mbygnW0NIRUNLT1VUXSByZXR1cm5pbmcgdXNlcicpO1xuICAgIGNvbnN0IGNoZWNrb3V0U3VjY2VzcyA9IGF3YWl0IGNoZWNrb3V0KGFkYXB0ZXIpLmNhdGNoKGNhdGNoRXJyKTtcblxuICAgIGlmICghY2hlY2tvdXRTdWNjZXNzIHx8IGNoZWNrb3V0U3VjY2Vzcy5lcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgY2hlY2tvdXQgZXJyb3IgZGV0ZWN0ZWQ6IGAsIGNoZWNrb3V0U3VjY2Vzcyk7XG4gICAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGNoZWNrb3V0U3VjY2VzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrb3V0U3VjY2VzcyAmJiBjaGVja291dFN1Y2Nlc3MudW5iaW5kQXBwSW5zdGFuY2UpIHtcbiAgICAgIGF3YWl0IHVuYmluZChhZGFwdGVyLCBjaGVja291dFN1Y2Nlc3MpLmNhdGNoKGNhdGNoRXJyKTtcbiAgICB9XG4gICAgc2V0UGFzc0ZhaWwoJ1BBU1MnKTtcbiAgfSBlbHNlIHtcbiAgICBhZnRlckF1dGhOZXdVc2VyKGFkYXB0ZXIsICdyZXR1cm5pbmcgdXNlciBhZGQgY2FyZCcpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IGFmdGVyQXV0aFJldHVybmluZyB9IGZyb20gJy4vYWZ0ZXItYXV0aC5qcyc7XG5pbXBvcnQgeyB1cGRhdGVCZW5jaG1hcmtzIH0gZnJvbSAnLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qcyc7XG5pbXBvcnQgeyBiZW5jaG1hcmsgfSBmcm9tIFwiLi4vc3R1YnMvZGF0YS5qc1wiO1xuXG5leHBvcnQgY29uc3QgcmV0dXJuaW5nRmxvdyA9IGFzeW5jIChhY2Nlc3NUb2tlbikgPT4ge1xuICBhd2FpdCBhZnRlckF1dGhSZXR1cm5pbmcod2luZG93LmMycF9hZGFwdGVyLCBhY2Nlc3NUb2tlbik7XG5cbiAgZ2VsKCdjcml0aWNhbF9hcGlzJykuaW5uZXJIVE1MID0gYENyaXRpY2FsIEFQSSB0aW1pbmdzOiAkeyhiZW5jaG1hcmsuaW5pdCArIGJlbmNobWFyay5pc1JlY29nbml6ZWQgKyBiZW5jaG1hcmsuZ2V0U3JjUHJvZmlsZSkgLyAxMDAwfXNgO1xuICBnZWwoJ2NoZWNrb3V0X2FwaXMnKS5pbm5lckhUTUwgPSBgQ2hlY2tvdXQgQVBJIHRpbWluZ3M6ICR7KGJlbmNobWFyay5jaGVja291dCArIGJlbmNobWFyay51bmJpbmQpIC8gMTAwMH1zYDtcbiAgdXBkYXRlQmVuY2htYXJrcygpO1xufTtcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IGluaXQgfSBmcm9tICcuLi9hc3luYy9pbml0LmpzJztcbmltcG9ydCB7IGlzUmVjb2duaXplZCB9IGZyb20gJy4uL2FzeW5jL2lzLXJlY29nbml6ZWQuanMnO1xuaW1wb3J0IGxvYWRTZGsgZnJvbSAnLi4vYXN5bmMvbG9hZC1zZGsuanMnO1xuaW1wb3J0IHsgc2V0U3RhcnRUaW1lLCB1cGRhdGVCZW5jaG1hcmtzIH0gZnJvbSAnLi4vaGVscGVycy91cGRhdGUtYmVuY2htYXJrcy5qcyc7XG5pbXBvcnQgeyBjYXRjaEVyciB9IGZyb20gJy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuaW1wb3J0IHsgYXV0aEZsb3cgfSBmcm9tICcuL2F1dGgtZmxvdy5qcyc7XG5pbXBvcnQgeyBhZnRlckF1dGhOZXdVc2VyLCBhZnRlckF1dGhSZXR1cm5pbmcgfSBmcm9tICcuL2FmdGVyLWF1dGguanMnO1xuaW1wb3J0IHsgcmV0dXJuaW5nRmxvdyB9IGZyb20gJy4vcmV0dXJuaW5nLmpzJztcbmltcG9ydCB7IHNldFBhc3NGYWlsIH0gZnJvbSAnLi4vdWkvZXZlbnQtaGFuZGxlcnMuanMnO1xuZXhwb3J0IHZhciBsb2FkU2RrQmVuY2htYXJrID0gZnVuY3Rpb24gKHNka1VybCkge1xuICAgIHNldFN0YXJ0VGltZSgpO1xuICAgIHZhciBsb2FkU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxvYWRTZGsoc2RrVXJsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWNjZXNzVG9rZW4sIGNvbnN1bWVyUHJlc2VudCwgdmNvQWRhcHRlciwgYWRhcHRlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdmNvQWRhcHRlciA9IHdpbmRvdy52QWRhcHRlcnMuVmlzYVNSQ0k7XG4gICAgICAgICAgICAgICAgICAgIGFkYXB0ZXIgPSBuZXcgdmNvQWRhcHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYzJwX2FkYXB0ZXIgPSBhZGFwdGVyO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbml0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGluaXQoYWRhcHRlciwgbG9hZFN0YXJ0KS5jYXRjaChjYXRjaEVycildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdFxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaXNSZWNvZ25pemVkKGFkYXB0ZXIpLmNhdGNoKGNhdGNoRXJyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBpc1JlY29nbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlbmNobWFya3MoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhYWNjZXNzVG9rZW4pIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicmVjb2duaXplIDIwNCAtIG5vIGFjY2VzcyB0b2tlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXV0aEZsb3coYWZ0ZXJBdXRoUmV0dXJuaW5nLCB1cGRhdGVCZW5jaG1hcmtzKS5jYXRjaChjYXRjaEVycildO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZXJQcmVzZW50ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZW5jaG1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uc3VtZXJQcmVzZW50KSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNvbnN1bWVyUHJlc2VudCA9PT0gJ21hbnVhbCcpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyAtLS0gYXdhaXRpbmcgbWFudWFsIE9UUCBlbnRyeScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb25zdW1lclByZXNlbnQuY29uc3VtZXJQcmVzZW50ID09PSBmYWxzZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhZnRlckF1dGhOZXdVc2VyKGFkYXB0ZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25zdW1lclByZXNlbnQuaWRUb2tlbikgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFmdGVyQXV0aFJldHVybmluZyhhZGFwdGVyLCBjb25zdW1lclByZXNlbnQuaWRUb2tlbildO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBhZnRlckF1dGhSZXR1cm5pbmcoYWRhcHRlcildO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBzZXRQYXNzRmFpbCgnRkFJTCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhGbG93IGZhaWx1cmUgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tSZXR1cm5pbmdSZWNvZ25pemVkXSBnb3QgYWNjZXNzVG9rZW4nLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmluZ0Zsb3coYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0pO1xufTtcbiIsImltcG9ydCB7IGF1dG9GaWxsVVVJRCB9IGZyb20gJy4uL2hlbHBlcnMvdXVpZC5qcyc7XG5pbXBvcnQgeyBiZW5jaG1hcmtTdGF0ZSwgcmVzZXRGbG93IH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5pbXBvcnQgeyByZXNldFVpIH0gZnJvbSAnLi4vdWkvcmVzZXQtdWkuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGUgfSBmcm9tICcuLi9oZWxwZXJzL3ZhbGlkYXRlLXN0YXJ0LW9wdGlvbnMnO1xuaW1wb3J0IHsgbG9hZFNka0JlbmNobWFyayB9IGZyb20gJy4vbG9hZC1zZGsnO1xuXG4vKipcbiAqIENhbGxlZCBpbiBjb250ZXh0IG9mIFwiR09cIiBidXR0b25cbiAqIGB0aGlzYCBpcyBIVE1MU2VsZWN0RWxlbWVudCBpZDogXCJzZGtfcGlja2VyX3YzXCJcbiAqL1xuY29uc3Qgc3RhcnRCZW5jaG1hcmsgPSBmdW5jdGlvbigpIHtcbiAgcmVzZXRVaSgpO1xuICByZXNldEZsb3coKTtcblxuICBpZiAodmFsaWRhdGUoKSkge1xuICAgIGNvbnN0IHNka1VybCA9IHRoaXMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0uaW5uZXJIVE1MLnRyaW0oKTtcbiAgICAvLyB1cGRhdGUgaW5pdERhdGEgZnJvbSBlbnYgY29uZmlnXG4gICAgYXV0b0ZpbGxVVUlEKGtleSk7XG5cbiAgICBpZiAoc2RrVXJsKSB7XG4gICAgICBjb25zb2xlLmxvZyhgQmVuY2htYXJrIHVzaW5nIFske3Nka1VybH1dYCk7XG4gICAgICBiZW5jaG1hcmtTdGF0ZS5zZGtVcmwgPSBzZGtVcmw7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2RrJywgc2RrVXJsKTtcbiAgICAgIGxvYWRTZGtCZW5jaG1hcmsoc2RrVXJsLCBrZXkpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RhcnRCZW5jaG1hcms7XG4iLCJpbXBvcnQgc3RhcnRCZW5jaG1hcmsgZnJvbSAnLi4vLi4vZmxvd3Mvc3RhcnQtYmVuY2htYXJrJztcbmltcG9ydCB7IGdlbCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMuanMnO1xuXG5leHBvcnQgY29uc3QgYmluZFNka0dvID0gKCkgPT4ge1xuICBjb25zdCBnb0J1dHRvbiA9IGdlbCgnZ29fdjMnKTtcbiAgXG4gIGlmIChnb0J1dHRvbikge1xuICAgIGdvQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBzdGFydEJlbmNobWFyay5jYWxsKGdlbCgnc2RrX3BpY2tlcl92MycpKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVTZGtTZWxlY3Rpb24gPSBlID0+IHtcbiAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2RrLXBpY2tlcicpKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NkaycsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICBnZWwoJ2NvbmZpZ191cmwnKS52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmluZFNka1NlbGVjdGlvbiA9ICgpID0+IHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlU2RrU2VsZWN0aW9uKTtcbn1cbiIsImltcG9ydCB7IGdlbCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMnO1xuaW1wb3J0IHsgY2FuVXNlVGVzdENhcmRBcGkgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2Nhbi11c2UtdGVzdC1jYXJkcy1hcGknO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlSGFuZGxlciA9IGFzeW5jIGUgPT4ge1xuICBpZiAoZS50YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3RvZ2dsZS1oZWFkZXInKSA+IC0xKSB7XG4gICAgZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QudG9nZ2xlKFwib3BlblwiKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmlmICghY2FuVXNlVGVzdENhcmRBcGkoKSkge1xuICBnZWwoJ3Bhbl9lbnRyeScpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufVxuIiwiaW1wb3J0IHsgdXVpZHY0IH0gZnJvbSAnLi91dWlkJztcblxuLy8gZXhwb3J0IGRlZmF1bHQgKCkgPT4gYCR7dXVpZHY0KCl9QG1haWxpbmF0b3IuY29tYDtcbmV4cG9ydCBkZWZhdWx0ICgpID0+IGBjMnBfJHtEYXRlLm5vdygpfUBtYWlsaW5hdG9yLmNvbWA7XG4iLCJpbXBvcnQgeyBnZWwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlscy5qc1wiO1xuaW1wb3J0IHsgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzLCByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MgfSBmcm9tICcuLi9oZWxwZXJzL2NvbXBsaWFuY2Utc2V0dGluZ3MuanMnO1xuXG5leHBvcnQgY29uc3QgYmluZENvbXBsaWFuY2VUb2dnbGUgPSAoKSA9PiB7XG4gIGdlbCgnY29tcGxpYW5jZV90b2dnbGUnKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgaW5qZWN0Q29tcGxpYW5jZVNldHRpbmdzKCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2V0Q29tcGxpYW5jZScsICdvbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVDb21wbGlhbmNlU2V0dGluZ3MoKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzZXRDb21wbGlhbmNlJywgJ29mZicpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZXRDb21wbGlhbmNlJykgPT09ICdvbicpIHtcbiAgICBnZWwoJ2NvbXBsaWFuY2VfdG9nZ2xlJykuY2hlY2tlZCA9IHRydWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IGluaXRCaW5TZWxlY3RvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvY2FyZC1iaW4tc2VsZWN0b3InO1xuaW1wb3J0IHsgYmluZFNka0dvLCBiaW5kU2RrU2VsZWN0aW9uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9zZGstc2VsZWN0b3InO1xuaW1wb3J0IHsgdG9nZ2xlSGFuZGxlciB9IGZyb20gJy4uL2NvbXBvbmVudHMvdG9nZ2xlJztcblxuaW1wb3J0IHsgY2F0Y2hFcnIsIGdlbCwgcXMgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzLmpzJztcbmltcG9ydCB7IGVtYWlsU2V0dGVyIH0gZnJvbSAnLi4vaGVscGVycy9lbWFpbC5qcyc7XG5pbXBvcnQgZ2VuZXJhdGVFbWFpbEFkZHJlc3MgZnJvbSAnLi4vaGVscGVycy9nZW5lcmF0ZS1lbWFpbC1hZGRyZXNzLmpzJztcbmltcG9ydCB7IGluaXREYXRhIH0gZnJvbSAnLi4vc3R1YnMvZGF0YS5qcyc7XG5pbXBvcnQgeyBiaW5kQ29tcGxpYW5jZVRvZ2dsZSB9IGZyb20gJy4vYmluZC1jb21wbGlhbmNlLmpzJztcblxubGV0IGF1dG9tYXRlVGltZW91dDtcbmxldCBhdXRvbWF0ZUNsaWNrVGltZW91dDtcbmxldCB0aW1lckludGVydmFsO1xuXG5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gIHRyeSB7XG4gICAgdG9nZ2xlSGFuZGxlcihlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhdGNoRXJyKGUpO1xuICB9XG59KTtcblxuXG5leHBvcnQgY29uc3Qgc2V0UGFzc0ZhaWwgPSBzdGF0dXMgPT4ge1xuICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KCdwYXNzZmFpbCcsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiBzdGF0dXMgfSk7XG4gIGdlbCgncGFzc19mYWlsJykuZGlzcGF0Y2hFdmVudChlKTtcbn1cbmNvbnN0IGhhbmRsZVBhc3NGYWlsID0gZSA9PiB7XG4gIGdlbCgncGFzc19mYWlsJykuaW5uZXJIVE1MID0gZS5kZXRhaWw7XG4gIGdlbCgncGFzc19mYWlsJykuY2xhc3NMaXN0LmFkZCgoZS5kZXRhaWwgPT09ICdQQVNTJykgPyAncGFzcycgOiAnZmFpbCcpO1xufVxuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdwYXNzZmFpbCcsIGhhbmRsZVBhc3NGYWlsKTtcblxuXG5jb25zdCBoYW5kbGVCdWJibGVkQ2hhbmdlRXZlbnRzID0gYXN5bmMgZSA9PiB7XG4gIHN3aXRjaCAoZS50YXJnZXQuaWQpIHtcbiAgICBjYXNlICdhZGRfY2FyZF9mbG93JzpcbiAgICBjYXNlICdyZXR1cm5pbmdfZmxvdyc6XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZmxvd19zZWxlY3RvcicsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0b21hdGUnOlxuICAgICAgbGV0IHRpbWVyVmFsdWUgPSAzMDAwMDtcbiAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRvbWF0ZScsICd0cnVlJyk7XG4gICAgICAgIGF1dG9tYXRlQ2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZ2VsKCdnb192MycpLmNsaWNrKCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICBhdXRvbWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0sIHRpbWVyVmFsdWUpO1xuICAgICAgICBsZXQgZGlzcGxheVRpbWVyID0gdGltZXJWYWx1ZSAvIDEwMDA7XG4gICAgICAgIHRpbWVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgZGlzcGxheVRpbWVyIC09IDE7XG4gICAgICAgICAgZ2VsKCd0aW1lcicpLmlubmVySFRNTCA9IGAke2Rpc3BsYXlUaW1lcn1zIHVudGlsIHJlZnJlc2hgO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSAnZGlzYWJsZS11aSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0b21hdGUnLCAnZmFsc2UnKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9tYXRlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9tYXRlVGltZW91dCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJbnRlcnZhbCk7XG4gICAgICAgIGdlbCgndGltZXInKS5pbm5lckhUTUwgPSBgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cblxuXG5cbmV4cG9ydCBjb25zdCBoYW5kbGVDb25maWdBcmVhID0gKCkgPT4ge1xuICBnZWwoJ2NvbmZpZycpLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGluaXREYXRhLCBudWxsLCAyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdHRhY2hFdmVudEhhbmRsZXJzID0gKCkgPT4ge1xuICBjb25zdCBsc0VtYWlsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtYWlsJyk7XG4gIGNvbnN0IGF1dG9tYXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dG9tYXRlJyk7XG4gIGNvbnN0IHVzZXJUeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfZmxvd19zZWxlY3RvcicpO1xuICBjb25zdCBmbG93VHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmbG93X3NlbGVjdG9yJyk7XG4gIFxuICBiaW5kQ29tcGxpYW5jZVRvZ2dsZSgpO1xuICBiaW5kU2RrR28oKTtcbiAgYmluZFNka1NlbGVjdGlvbigpO1xuXG4gIGluaXRCaW5TZWxlY3RvcigpO1xuXG5cbiAgLy8gbXVsdGlzZWxlY3RcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gJ09QVElPTicgJiYgZS50YXJnZXQuY2xhc3NOYW1lID09PSAnaGlzdG9yaWNhbF9lbWFpbF9vcHRpb24nKSB7XG4gICAgICBlLnRhcmdldC52YWx1ZSAmJiBlbWFpbFNldHRlcihlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIGRyb3Bkb3duXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnU0VMRUNUJyAmJiBlLnRhcmdldC5pZCA9PT0gJ2VtYWlsX2hpc3RvcmljYWwnKSB7XG4gICAgICBlLnRhcmdldC52YWx1ZSAmJiBlbWFpbFNldHRlcihlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBuZXcgdXNlclxuICBnZWwoJ25ld191c2VyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgbmV3RW1haWwgPSBnZW5lcmF0ZUVtYWlsQWRkcmVzcygpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdlbWFpbCcsIG5ld0VtYWlsKTtcbiAgICBnZWwoJ2VtYWlsSW5wdXQnKS52YWx1ZSA9IG5ld0VtYWlsO1xuICB9KTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICBoYW5kbGVCdWJibGVkQ2hhbmdlRXZlbnRzKGUpO1xuICB9KTtcblxuICBpZiAobHNFbWFpbCkge1xuICAgIGVtYWlsU2V0dGVyKGxzRW1haWwpO1xuICB9XG5cbiAgaWYgKGF1dG9tYXRlID09PSAndHJ1ZScpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYXV0b21hdGUgaXMgdHJ1ZScpO1xuICAgIGNvbnN0IGNiID0gZ2VsKCdhdXRvbWF0ZScpO1xuICAgIGNiICYmIChjYi5jaGVja2VkID0gdHJ1ZSk7XG4gICAgY29uc3QgZXZ0ID0gbmV3IEV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfSk7XG4gICAgY2IuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgaGFuZGxlQ29uZmlnQXJlYSgpO1xuXG4gIGlmICh1c2VyVHlwZSkge1xuICAgIHFzKGBpbnB1dFt2YWx1ZT1cIiR7dXNlclR5cGV9XCJdYCkgJiYgKHFzKGBpbnB1dFt2YWx1ZT1cIiR7dXNlclR5cGV9XCJdYCkuY2hlY2tlZCA9IHRydWUpO1xuICB9XG4gIGlmIChmbG93VHlwZSkge1xuICAgIHFzKGBpbnB1dFt2YWx1ZT1cIiR7Zmxvd1R5cGV9XCJdYCkgJiYgKHFzKGBpbnB1dFt2YWx1ZT1cIiR7Zmxvd1R5cGV9XCJdYCkuY2hlY2tlZCA9IHRydWUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBzZXRIaXN0b3JpY2FsRW1haWxzIH0gZnJvbSAnLi9oZWxwZXJzL2VtYWlsLmpzJztcbmltcG9ydCB7IGdlbCB9IGZyb20gJy4vaGVscGVycy91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudEtleXMsIGdldEVuY3J5cHRpb25LZXlzIH0gZnJvbSAnLi9oZWxwZXJzL2dldC1rZXlzJztcbmltcG9ydCB7IGJ1aWxkU2RrUGlja2VyIH0gZnJvbSAnLi91aS9nZW5lcmF0ZS1zZGstbGlzdC5qcyc7XG5pbXBvcnQgeyBhdHRhY2hFdmVudEhhbmRsZXJzIH0gZnJvbSAnLi91aS9ldmVudC1oYW5kbGVycyc7XG5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG5idWlsZFNka1BpY2tlcigpO1xuc2V0SGlzdG9yaWNhbEVtYWlscygpO1xuaWYgKGxvY2F0aW9uLmhvc3RuYW1lLmluZGV4T2YoJ3Zpc2EuY29tJykgPCAwICYmXG4gICAgbG9jYXRpb24uaG9zdG5hbWUuaW5kZXhPZignbG9jYWxob3N0JykgPCAwKSB7XG4gICAgdmFyIGVuY0tleXMgPSBnZXRFbmNyeXB0aW9uS2V5cygpO1xuICAgIHZhciBlbnZLZXlzID0gZ2V0RW52aXJvbm1lbnRLZXlzKCk7XG4gICAgaWYgKCEoZW5jS2V5cyA9PT0gbnVsbCB8fCBlbmNLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmNLZXlzLnNhbmRib3gpIHx8ICEoZW52S2V5cyA9PT0gbnVsbCB8fCBlbnZLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnZLZXlzLlNhbmRCb3gpKSB7XG4gICAgICAgIGdlbCgnbWFpbicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGdlbCgnbmVlZF9tZXRhZGF0YScpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")}},__webpack_module_cache__={};function __webpack_require__(n){var c=__webpack_module_cache__[n];if(void 0!==c)return c.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}var __webpack_exports__=__webpack_require__(5)})();
